[
  {
    "url": "buffer.js",
    "ranges": [
      {
        "start": 0,
        "end": 2784
      },
      {
        "start": 2868,
        "end": 4821
      },
      {
        "start": 5501,
        "end": 5503
      },
      {
        "start": 5721,
        "end": 5723
      },
      {
        "start": 6988,
        "end": 6990
      },
      {
        "start": 7592,
        "end": 8168
      },
      {
        "start": 8501,
        "end": 8594
      },
      {
        "start": 8622,
        "end": 10214
      },
      {
        "start": 10366,
        "end": 10655
      },
      {
        "start": 10876,
        "end": 10979
      },
      {
        "start": 11224,
        "end": 11403
      },
      {
        "start": 11478,
        "end": 11719
      },
      {
        "start": 11808,
        "end": 11904
      },
      {
        "start": 11994,
        "end": 12108
      },
      {
        "start": 12440,
        "end": 13445
      },
      {
        "start": 14142,
        "end": 14144
      },
      {
        "start": 14518,
        "end": 14520
      },
      {
        "start": 14826,
        "end": 14939
      },
      {
        "start": 15264,
        "end": 15287
      },
      {
        "start": 15438,
        "end": 15504
      },
      {
        "start": 16708,
        "end": 16711
      },
      {
        "start": 16947,
        "end": 17159
      },
      {
        "start": 17205,
        "end": 17220
      },
      {
        "start": 17316,
        "end": 17409
      },
      {
        "start": 17438,
        "end": 17451
      },
      {
        "start": 17515,
        "end": 17528
      },
      {
        "start": 17574,
        "end": 17589
      },
      {
        "start": 17688,
        "end": 17787
      },
      {
        "start": 17816,
        "end": 17829
      },
      {
        "start": 17893,
        "end": 17906
      },
      {
        "start": 17952,
        "end": 17967
      },
      {
        "start": 18066,
        "end": 18162
      },
      {
        "start": 18187,
        "end": 18200
      },
      {
        "start": 18266,
        "end": 18279
      },
      {
        "start": 18327,
        "end": 18342
      },
      {
        "start": 18440,
        "end": 18533
      },
      {
        "start": 18558,
        "end": 18571
      },
      {
        "start": 18636,
        "end": 18649
      },
      {
        "start": 18696,
        "end": 18711
      },
      {
        "start": 18923,
        "end": 19019
      },
      {
        "start": 19070,
        "end": 19083
      },
      {
        "start": 19149,
        "end": 19162
      },
      {
        "start": 19210,
        "end": 19225
      },
      {
        "start": 19439,
        "end": 19526
      },
      {
        "start": 19557,
        "end": 19570
      },
      {
        "start": 19633,
        "end": 19646
      },
      {
        "start": 19691,
        "end": 19706
      },
      {
        "start": 19914,
        "end": 19922
      },
      {
        "start": 21477,
        "end": 21479
      },
      {
        "start": 22136,
        "end": 22276
      },
      {
        "start": 22370,
        "end": 22448
      },
      {
        "start": 22546,
        "end": 22578
      },
      {
        "start": 22711,
        "end": 22992
      },
      {
        "start": 23571,
        "end": 23600
      },
      {
        "start": 23954,
        "end": 24082
      },
      {
        "start": 25077,
        "end": 25173
      },
      {
        "start": 26322,
        "end": 26750
      },
      {
        "start": 28057,
        "end": 28086
      },
      {
        "start": 28203,
        "end": 28237
      },
      {
        "start": 28359,
        "end": 28390
      },
      {
        "start": 28495,
        "end": 28673
      },
      {
        "start": 28772,
        "end": 28775
      },
      {
        "start": 30684,
        "end": 30711
      },
      {
        "start": 31726,
        "end": 31755
      },
      {
        "start": 31989,
        "end": 31992
      },
      {
        "start": 32426,
        "end": 32453
      },
      {
        "start": 32753,
        "end": 32756
      },
      {
        "start": 32827,
        "end": 32855
      },
      {
        "start": 33259,
        "end": 33288
      },
      {
        "start": 33732,
        "end": 33761
      },
      {
        "start": 34269,
        "end": 34582
      },
      {
        "start": 35322,
        "end": 35634
      },
      {
        "start": 35669,
        "end": 35675
      },
      {
        "start": 35712,
        "end": 35721
      }
    ],
    "text": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  Array,\n  ArrayIsArray,\n  Error,\n  MathFloor,\n  MathMin,\n  MathTrunc,\n  NumberIsNaN,\n  NumberMAX_SAFE_INTEGER,\n  NumberMIN_SAFE_INTEGER,\n  ObjectCreate,\n  ObjectDefineProperties,\n  ObjectDefineProperty,\n  ObjectGetOwnPropertyDescriptor,\n  ObjectGetPrototypeOf,\n  ObjectSetPrototypeOf,\n  SymbolSpecies,\n  SymbolToPrimitive,\n  Uint8Array,\n  Uint8ArrayPrototype,\n} = primordials;\n\nconst {\n  byteLengthUtf8,\n  compare: _compare,\n  compareOffset,\n  createFromString,\n  fill: bindingFill,\n  indexOfBuffer,\n  indexOfNumber,\n  indexOfString,\n  swap16: _swap16,\n  swap32: _swap32,\n  swap64: _swap64,\n  kMaxLength,\n  kStringMaxLength,\n  zeroFill: bindingZeroFill\n} = internalBinding('buffer');\nconst {\n  getOwnNonIndexProperties,\n  propertyFilter: {\n    ALL_PROPERTIES,\n    ONLY_ENUMERABLE\n  },\n} = internalBinding('util');\nconst {\n  customInspectSymbol,\n  isInsideNodeModules,\n  normalizeEncoding,\n  kIsEncodingSymbol\n} = require('internal/util');\nconst {\n  isAnyArrayBuffer,\n  isArrayBufferView,\n  isUint8Array\n} = require('internal/util/types');\nconst {\n  inspect: utilInspect\n} = require('internal/util/inspect');\nconst { encodings } = internalBinding('string_decoder');\n\nconst {\n  codes: {\n    ERR_BUFFER_OUT_OF_BOUNDS,\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_ARG_VALUE,\n    ERR_INVALID_BUFFER_SIZE,\n    ERR_INVALID_OPT_VALUE,\n    ERR_OUT_OF_RANGE,\n    ERR_UNKNOWN_ENCODING\n  },\n  hideStackFrames\n} = require('internal/errors');\nconst {\n  validateBuffer,\n  validateInteger,\n  validateString\n} = require('internal/validators');\n// Provide validateInteger() but with kMaxLength as the default maximum value.\nconst validateOffset = (value, name, min = 0, max = kMaxLength) =>\n  validateInteger(value, name, min, max);\n\nconst {\n  FastBuffer,\n  markAsUntransferable,\n  addBufferPrototypeMethods\n} = require('internal/buffer');\n\nconst TypedArrayPrototype = ObjectGetPrototypeOf(Uint8ArrayPrototype);\n\nconst TypedArrayProto_byteLength =\n      ObjectGetOwnPropertyDescriptor(TypedArrayPrototype,\n                                     'byteLength').get;\nconst TypedArrayFill = TypedArrayPrototype.fill;\n\nFastBuffer.prototype.constructor = Buffer;\nBuffer.prototype = FastBuffer.prototype;\naddBufferPrototypeMethods(Buffer.prototype);\n\nconst constants = ObjectDefineProperties({}, {\n  MAX_LENGTH: {\n    value: kMaxLength,\n    writable: false,\n    enumerable: true\n  },\n  MAX_STRING_LENGTH: {\n    value: kStringMaxLength,\n    writable: false,\n    enumerable: true\n  }\n});\n\nBuffer.poolSize = 8 * 1024;\nlet poolSize, poolOffset, allocPool;\n\n// A toggle used to access the zero fill setting of the array buffer allocator\n// in C++.\n// |zeroFill| can be undefined when running inside an isolate where we\n// do not own the ArrayBuffer allocator.  Zero fill is always on in that case.\nconst zeroFill = bindingZeroFill || [0];\n\nconst encodingsMap = ObjectCreate(null);\nfor (let i = 0; i < encodings.length; ++i)\n  encodingsMap[encodings[i]] = i;\n\nfunction createUnsafeBuffer(size) {\n  zeroFill[0] = 0;\n  try {\n    return new FastBuffer(size);\n  } finally {\n    zeroFill[0] = 1;\n  }\n}\n\nfunction createPool() {\n  poolSize = Buffer.poolSize;\n  allocPool = createUnsafeBuffer(poolSize).buffer;\n  markAsUntransferable(allocPool);\n  poolOffset = 0;\n}\ncreatePool();\n\nfunction alignPool() {\n  // Ensure aligned slices\n  if (poolOffset & 0x7) {\n    poolOffset |= 0x7;\n    poolOffset++;\n  }\n}\n\nlet bufferWarningAlreadyEmitted = false;\nlet nodeModulesCheckCounter = 0;\nconst bufferWarning = 'Buffer() is deprecated due to security and usability ' +\n                      'issues. Please use the Buffer.alloc(), ' +\n                      'Buffer.allocUnsafe(), or Buffer.from() methods instead.';\n\nfunction showFlaggedDeprecation() {\n  if (bufferWarningAlreadyEmitted ||\n      ++nodeModulesCheckCounter > 10000 ||\n      (!require('internal/options').getOptionValue('--pending-deprecation') &&\n       isInsideNodeModules())) {\n    // We don't emit a warning, because we either:\n    // - Already did so, or\n    // - Already checked too many times whether a call is coming\n    //   from node_modules and want to stop slowing down things, or\n    // - We aren't running with `--pending-deprecation` enabled,\n    //   and the code is inside `node_modules`.\n    return;\n  }\n\n  process.emitWarning(bufferWarning, 'DeprecationWarning', 'DEP0005');\n  bufferWarningAlreadyEmitted = true;\n}\n\nfunction toInteger(n, defaultVal) {\n  n = +n;\n  if (!NumberIsNaN(n) &&\n      n >= NumberMIN_SAFE_INTEGER &&\n      n <= NumberMAX_SAFE_INTEGER) {\n    return ((n % 1) === 0 ? n : MathFloor(n));\n  }\n  return defaultVal;\n}\n\nfunction _copy(source, target, targetStart, sourceStart, sourceEnd) {\n  if (!isUint8Array(source))\n    throw new ERR_INVALID_ARG_TYPE('source', ['Buffer', 'Uint8Array'], source);\n  if (!isUint8Array(target))\n    throw new ERR_INVALID_ARG_TYPE('target', ['Buffer', 'Uint8Array'], target);\n\n  if (targetStart === undefined) {\n    targetStart = 0;\n  } else {\n    targetStart = toInteger(targetStart, 0);\n    if (targetStart < 0)\n      throw new ERR_OUT_OF_RANGE('targetStart', '>= 0', targetStart);\n  }\n\n  if (sourceStart === undefined) {\n    sourceStart = 0;\n  } else {\n    sourceStart = toInteger(sourceStart, 0);\n    if (sourceStart < 0)\n      throw new ERR_OUT_OF_RANGE('sourceStart', '>= 0', sourceStart);\n  }\n\n  if (sourceEnd === undefined) {\n    sourceEnd = source.length;\n  } else {\n    sourceEnd = toInteger(sourceEnd, 0);\n    if (sourceEnd < 0)\n      throw new ERR_OUT_OF_RANGE('sourceEnd', '>= 0', sourceEnd);\n  }\n\n  if (targetStart >= target.length || sourceStart >= sourceEnd)\n    return 0;\n\n  if (sourceStart > source.length) {\n    throw new ERR_OUT_OF_RANGE('sourceStart',\n                               `<= ${source.length}`,\n                               sourceStart);\n  }\n\n  return _copyActual(source, target, targetStart, sourceStart, sourceEnd);\n}\n\nfunction _copyActual(source, target, targetStart, sourceStart, sourceEnd) {\n  if (sourceEnd - sourceStart > target.length - targetStart)\n    sourceEnd = sourceStart + target.length - targetStart;\n\n  let nb = sourceEnd - sourceStart;\n  const targetLen = target.length - targetStart;\n  const sourceLen = source.length - sourceStart;\n  if (nb > targetLen)\n    nb = targetLen;\n  if (nb > sourceLen)\n    nb = sourceLen;\n\n  if (sourceStart !== 0 || sourceEnd < source.length)\n    source = new Uint8Array(source.buffer, source.byteOffset + sourceStart, nb);\n\n  target.set(source, targetStart);\n\n  return nb;\n}\n\n/**\n * The Buffer() constructor is deprecated in documentation and should not be\n * used moving forward. Rather, developers should use one of the three new\n * factory APIs: Buffer.from(), Buffer.allocUnsafe() or Buffer.alloc() based on\n * their specific needs. There is no runtime deprecation because of the extent\n * to which the Buffer constructor is used in the ecosystem currently -- a\n * runtime deprecation would introduce too much breakage at this time. It's not\n * likely that the Buffer constructors would ever actually be removed.\n * Deprecation Code: DEP0005\n */\nfunction Buffer(arg, encodingOrOffset, length) {\n  showFlaggedDeprecation();\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new ERR_INVALID_ARG_TYPE('string', 'string', arg);\n    }\n    return Buffer.alloc(arg);\n  }\n  return Buffer.from(arg, encodingOrOffset, length);\n}\n\nObjectDefineProperty(Buffer, SymbolSpecies, {\n  enumerable: false,\n  configurable: true,\n  get() { return FastBuffer; }\n});\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n */\nBuffer.from = function from(value, encodingOrOffset, length) {\n  if (typeof value === 'string')\n    return fromString(value, encodingOrOffset);\n\n  if (typeof value === 'object' && value !== null) {\n    if (isAnyArrayBuffer(value))\n      return fromArrayBuffer(value, encodingOrOffset, length);\n\n    const valueOf = value.valueOf && value.valueOf();\n    if (valueOf != null &&\n        valueOf !== value &&\n        (typeof valueOf === 'string' || typeof valueOf === 'object')) {\n      return from(valueOf, encodingOrOffset, length);\n    }\n\n    const b = fromObject(value);\n    if (b)\n      return b;\n\n    if (typeof value[SymbolToPrimitive] === 'function') {\n      const primitive = value[SymbolToPrimitive]('string');\n      if (typeof primitive === 'string') {\n        return fromString(primitive, encodingOrOffset);\n      }\n    }\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    'first argument',\n    ['string', 'Buffer', 'ArrayBuffer', 'Array', 'Array-like Object'],\n    value\n  );\n};\n\n// Identical to the built-in %TypedArray%.of(), but avoids using the deprecated\n// Buffer() constructor. Must use arrow function syntax to avoid automatically\n// adding a `prototype` property and making the function a constructor.\n//\n// Refs: https://tc39.github.io/ecma262/#sec-%typedarray%.of\n// Refs: https://esdiscuss.org/topic/isconstructor#content-11\nconst of = (...items) => {\n  const newObj = createUnsafeBuffer(items.length);\n  for (let k = 0; k < items.length; k++)\n    newObj[k] = items[k];\n  return newObj;\n};\nBuffer.of = of;\n\nObjectSetPrototypeOf(Buffer, Uint8Array);\n\n// The 'assertSize' method will remove itself from the callstack when an error\n// occurs. This is done simply to keep the internal details of the\n// implementation from bleeding out to users.\nconst assertSize = hideStackFrames((size) => {\n  if (typeof size !== 'number') {\n    throw new ERR_INVALID_ARG_TYPE('size', 'number', size);\n  }\n  if (!(size >= 0 && size <= kMaxLength)) {\n    throw new ERR_INVALID_OPT_VALUE.RangeError('size', size);\n  }\n});\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n */\nBuffer.alloc = function alloc(size, fill, encoding) {\n  assertSize(size);\n  if (fill !== undefined && fill !== 0 && size > 0) {\n    const buf = createUnsafeBuffer(size);\n    return _fill(buf, fill, 0, buf.length, encoding);\n  }\n  return new FastBuffer(size);\n};\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer\n * instance. If `--zero-fill-buffers` is set, will zero-fill the buffer.\n */\nBuffer.allocUnsafe = function allocUnsafe(size) {\n  assertSize(size);\n  return allocate(size);\n};\n\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled\n * Buffer instance that is not allocated off the pre-initialized pool.\n * If `--zero-fill-buffers` is set, will zero-fill the buffer.\n */\nBuffer.allocUnsafeSlow = function allocUnsafeSlow(size) {\n  assertSize(size);\n  return createUnsafeBuffer(size);\n};\n\n// If --zero-fill-buffers command line argument is set, a zero-filled\n// buffer is returned.\nfunction SlowBuffer(length) {\n  assertSize(length);\n  return createUnsafeBuffer(length);\n}\n\nObjectSetPrototypeOf(SlowBuffer.prototype, Uint8ArrayPrototype);\nObjectSetPrototypeOf(SlowBuffer, Uint8Array);\n\nfunction allocate(size) {\n  if (size <= 0) {\n    return new FastBuffer();\n  }\n  if (size < (Buffer.poolSize >>> 1)) {\n    if (size > (poolSize - poolOffset))\n      createPool();\n    const b = new FastBuffer(allocPool, poolOffset, size);\n    poolOffset += size;\n    alignPool();\n    return b;\n  }\n  return createUnsafeBuffer(size);\n}\n\nfunction fromStringFast(string, ops) {\n  const length = ops.byteLength(string);\n\n  if (length >= (Buffer.poolSize >>> 1))\n    return createFromString(string, ops.encodingVal);\n\n  if (length > (poolSize - poolOffset))\n    createPool();\n  let b = new FastBuffer(allocPool, poolOffset, length);\n  const actual = ops.write(b, string, 0, length);\n  if (actual !== length) {\n    // byteLength() may overestimate. That's a rare case, though.\n    b = new FastBuffer(allocPool, poolOffset, actual);\n  }\n  poolOffset += actual;\n  alignPool();\n  return b;\n}\n\nfunction fromString(string, encoding) {\n  let ops;\n  if (typeof encoding !== 'string' || encoding.length === 0) {\n    if (string.length === 0)\n      return new FastBuffer();\n    ops = encodingOps.utf8;\n    encoding = undefined;\n  } else {\n    ops = getEncodingOps(encoding);\n    if (ops === undefined)\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    if (string.length === 0)\n      return new FastBuffer();\n  }\n  return fromStringFast(string, ops);\n}\n\nfunction fromArrayBuffer(obj, byteOffset, length) {\n  // Convert byteOffset to integer\n  if (byteOffset === undefined) {\n    byteOffset = 0;\n  } else {\n    byteOffset = +byteOffset;\n    if (NumberIsNaN(byteOffset))\n      byteOffset = 0;\n  }\n\n  const maxLength = obj.byteLength - byteOffset;\n\n  if (maxLength < 0)\n    throw new ERR_BUFFER_OUT_OF_BOUNDS('offset');\n\n  if (length === undefined) {\n    length = maxLength;\n  } else {\n    // Convert length to non-negative integer.\n    length = +length;\n    if (length > 0) {\n      if (length > maxLength)\n        throw new ERR_BUFFER_OUT_OF_BOUNDS('length');\n    } else {\n      length = 0;\n    }\n  }\n\n  return new FastBuffer(obj, byteOffset, length);\n}\n\nfunction fromArrayLike(obj) {\n  if (obj.length <= 0)\n    return new FastBuffer();\n  if (obj.length < (Buffer.poolSize >>> 1)) {\n    if (obj.length > (poolSize - poolOffset))\n      createPool();\n    const b = new FastBuffer(allocPool, poolOffset, obj.length);\n    b.set(obj, 0);\n    poolOffset += obj.length;\n    alignPool();\n    return b;\n  }\n  return new FastBuffer(obj);\n}\n\nfunction fromObject(obj) {\n  if (obj.length !== undefined || isAnyArrayBuffer(obj.buffer)) {\n    if (typeof obj.length !== 'number') {\n      return new FastBuffer();\n    }\n    return fromArrayLike(obj);\n  }\n\n  if (obj.type === 'Buffer' && ArrayIsArray(obj.data)) {\n    return fromArrayLike(obj.data);\n  }\n}\n\n// Static methods\n\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer;\n};\n\nBuffer.compare = function compare(buf1, buf2) {\n  if (!isUint8Array(buf1)) {\n    throw new ERR_INVALID_ARG_TYPE('buf1', ['Buffer', 'Uint8Array'], buf1);\n  }\n\n  if (!isUint8Array(buf2)) {\n    throw new ERR_INVALID_ARG_TYPE('buf2', ['Buffer', 'Uint8Array'], buf2);\n  }\n\n  if (buf1 === buf2) {\n    return 0;\n  }\n\n  return _compare(buf1, buf2);\n};\n\nBuffer.isEncoding = function isEncoding(encoding) {\n  return typeof encoding === 'string' && encoding.length !== 0 &&\n         normalizeEncoding(encoding) !== undefined;\n};\nBuffer[kIsEncodingSymbol] = Buffer.isEncoding;\n\nBuffer.concat = function concat(list, length) {\n  if (!ArrayIsArray(list)) {\n    throw new ERR_INVALID_ARG_TYPE('list', 'Array', list);\n  }\n\n  if (list.length === 0)\n    return new FastBuffer();\n\n  if (length === undefined) {\n    length = 0;\n    for (let i = 0; i < list.length; i++) {\n      if (list[i].length) {\n        length += list[i].length;\n      }\n    }\n  } else {\n    validateOffset(length, 'length');\n  }\n\n  const buffer = Buffer.allocUnsafe(length);\n  let pos = 0;\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    if (!isUint8Array(buf)) {\n      // TODO(BridgeAR): This should not be of type ERR_INVALID_ARG_TYPE.\n      // Instead, find the proper error code for this.\n      throw new ERR_INVALID_ARG_TYPE(\n        `list[${i}]`, ['Buffer', 'Uint8Array'], list[i]);\n    }\n    pos += _copyActual(buf, buffer, pos, 0, buf.length);\n  }\n\n  // Note: `length` is always equal to `buffer.length` at this point\n  if (pos < length) {\n    // Zero-fill the remaining bytes if the specified `length` was more than\n    // the actual total length, i.e. if we have some remaining allocated bytes\n    // there were not initialized.\n    TypedArrayFill.call(buffer, 0, pos, length);\n  }\n\n  return buffer;\n};\n\nfunction base64ByteLength(str, bytes) {\n  // Handle padding\n  if (str.charCodeAt(bytes - 1) === 0x3D)\n    bytes--;\n  if (bytes > 1 && str.charCodeAt(bytes - 1) === 0x3D)\n    bytes--;\n\n  // Base64 ratio: 3/4\n  return (bytes * 3) >>> 2;\n}\n\nconst encodingOps = {\n  utf8: {\n    encoding: 'utf8',\n    encodingVal: encodingsMap.utf8,\n    byteLength: byteLengthUtf8,\n    write: (buf, string, offset, len) => buf.utf8Write(string, offset, len),\n    slice: (buf, start, end) => buf.utf8Slice(start, end),\n    indexOf: (buf, val, byteOffset, dir) =>\n      indexOfString(buf, val, byteOffset, encodingsMap.utf8, dir)\n  },\n  ucs2: {\n    encoding: 'ucs2',\n    encodingVal: encodingsMap.utf16le,\n    byteLength: (string) => string.length * 2,\n    write: (buf, string, offset, len) => buf.ucs2Write(string, offset, len),\n    slice: (buf, start, end) => buf.ucs2Slice(start, end),\n    indexOf: (buf, val, byteOffset, dir) =>\n      indexOfString(buf, val, byteOffset, encodingsMap.utf16le, dir)\n  },\n  utf16le: {\n    encoding: 'utf16le',\n    encodingVal: encodingsMap.utf16le,\n    byteLength: (string) => string.length * 2,\n    write: (buf, string, offset, len) => buf.ucs2Write(string, offset, len),\n    slice: (buf, start, end) => buf.ucs2Slice(start, end),\n    indexOf: (buf, val, byteOffset, dir) =>\n      indexOfString(buf, val, byteOffset, encodingsMap.utf16le, dir)\n  },\n  latin1: {\n    encoding: 'latin1',\n    encodingVal: encodingsMap.latin1,\n    byteLength: (string) => string.length,\n    write: (buf, string, offset, len) => buf.latin1Write(string, offset, len),\n    slice: (buf, start, end) => buf.latin1Slice(start, end),\n    indexOf: (buf, val, byteOffset, dir) =>\n      indexOfString(buf, val, byteOffset, encodingsMap.latin1, dir)\n  },\n  ascii: {\n    encoding: 'ascii',\n    encodingVal: encodingsMap.ascii,\n    byteLength: (string) => string.length,\n    write: (buf, string, offset, len) => buf.asciiWrite(string, offset, len),\n    slice: (buf, start, end) => buf.asciiSlice(start, end),\n    indexOf: (buf, val, byteOffset, dir) =>\n      indexOfBuffer(buf,\n                    fromStringFast(val, encodingOps.ascii),\n                    byteOffset,\n                    encodingsMap.ascii,\n                    dir)\n  },\n  base64: {\n    encoding: 'base64',\n    encodingVal: encodingsMap.base64,\n    byteLength: (string) => base64ByteLength(string, string.length),\n    write: (buf, string, offset, len) => buf.base64Write(string, offset, len),\n    slice: (buf, start, end) => buf.base64Slice(start, end),\n    indexOf: (buf, val, byteOffset, dir) =>\n      indexOfBuffer(buf,\n                    fromStringFast(val, encodingOps.base64),\n                    byteOffset,\n                    encodingsMap.base64,\n                    dir)\n  },\n  hex: {\n    encoding: 'hex',\n    encodingVal: encodingsMap.hex,\n    byteLength: (string) => string.length >>> 1,\n    write: (buf, string, offset, len) => buf.hexWrite(string, offset, len),\n    slice: (buf, start, end) => buf.hexSlice(start, end),\n    indexOf: (buf, val, byteOffset, dir) =>\n      indexOfBuffer(buf,\n                    fromStringFast(val, encodingOps.hex),\n                    byteOffset,\n                    encodingsMap.hex,\n                    dir)\n  }\n};\nfunction getEncodingOps(encoding) {\n  encoding += '';\n  switch (encoding.length) {\n    case 4:\n      if (encoding === 'utf8') return encodingOps.utf8;\n      if (encoding === 'ucs2') return encodingOps.ucs2;\n      encoding = encoding.toLowerCase();\n      if (encoding === 'utf8') return encodingOps.utf8;\n      if (encoding === 'ucs2') return encodingOps.ucs2;\n      break;\n    case 5:\n      if (encoding === 'utf-8') return encodingOps.utf8;\n      if (encoding === 'ascii') return encodingOps.ascii;\n      if (encoding === 'ucs-2') return encodingOps.ucs2;\n      encoding = encoding.toLowerCase();\n      if (encoding === 'utf-8') return encodingOps.utf8;\n      if (encoding === 'ascii') return encodingOps.ascii;\n      if (encoding === 'ucs-2') return encodingOps.ucs2;\n      break;\n    case 7:\n      if (encoding === 'utf16le' || encoding.toLowerCase() === 'utf16le')\n        return encodingOps.utf16le;\n      break;\n    case 8:\n      if (encoding === 'utf-16le' || encoding.toLowerCase() === 'utf-16le')\n        return encodingOps.utf16le;\n      break;\n    case 6:\n      if (encoding === 'latin1' || encoding === 'binary')\n        return encodingOps.latin1;\n      if (encoding === 'base64') return encodingOps.base64;\n      encoding = encoding.toLowerCase();\n      if (encoding === 'latin1' || encoding === 'binary')\n        return encodingOps.latin1;\n      if (encoding === 'base64') return encodingOps.base64;\n      break;\n    case 3:\n      if (encoding === 'hex' || encoding.toLowerCase() === 'hex')\n        return encodingOps.hex;\n      break;\n  }\n}\n\nfunction byteLength(string, encoding) {\n  if (typeof string !== 'string') {\n    if (isArrayBufferView(string) || isAnyArrayBuffer(string)) {\n      return string.byteLength;\n    }\n\n    throw new ERR_INVALID_ARG_TYPE(\n      'string', ['string', 'Buffer', 'ArrayBuffer'], string\n    );\n  }\n\n  const len = string.length;\n  const mustMatch = (arguments.length > 2 && arguments[2] === true);\n  if (!mustMatch && len === 0)\n    return 0;\n\n  if (!encoding)\n    return (mustMatch ? -1 : byteLengthUtf8(string));\n\n  const ops = getEncodingOps(encoding);\n  if (ops === undefined)\n    return (mustMatch ? -1 : byteLengthUtf8(string));\n  return ops.byteLength(string);\n}\n\nBuffer.byteLength = byteLength;\n\n// For backwards compatibility.\nObjectDefineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get() {\n    if (!(this instanceof Buffer))\n      return undefined;\n    return this.buffer;\n  }\n});\nObjectDefineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get() {\n    if (!(this instanceof Buffer))\n      return undefined;\n    return this.byteOffset;\n  }\n});\n\nBuffer.prototype.copy =\n  function copy(target, targetStart, sourceStart, sourceEnd) {\n    return _copy(this, target, targetStart, sourceStart, sourceEnd);\n  };\n\n// No need to verify that \"buf.length <= MAX_UINT32\" since it's a read-only\n// property of a typed array.\n// This behaves neither like String nor Uint8Array in that we set start/end\n// to their upper/lower bounds if the value passed is out of range.\nBuffer.prototype.toString = function toString(encoding, start, end) {\n  if (arguments.length === 0) {\n    return this.utf8Slice(0, this.length);\n  }\n\n  const len = this.length;\n\n  if (start <= 0)\n    start = 0;\n  else if (start >= len)\n    return '';\n  else\n    start |= 0;\n\n  if (end === undefined || end > len)\n    end = len;\n  else\n    end |= 0;\n\n  if (end <= start)\n    return '';\n\n  if (encoding === undefined)\n    return this.utf8Slice(start, end);\n\n  const ops = getEncodingOps(encoding);\n  if (ops === undefined)\n    throw new ERR_UNKNOWN_ENCODING(encoding);\n\n  return ops.slice(this, start, end);\n};\n\nBuffer.prototype.equals = function equals(otherBuffer) {\n  if (!isUint8Array(otherBuffer)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'otherBuffer', ['Buffer', 'Uint8Array'], otherBuffer);\n  }\n\n  if (this === otherBuffer)\n    return true;\n\n  if (this.byteLength !== otherBuffer.byteLength)\n    return false;\n\n  return this.byteLength === 0 || _compare(this, otherBuffer) === 0;\n};\n\nlet INSPECT_MAX_BYTES = 50;\n// Override how buffers are presented by util.inspect().\nBuffer.prototype[customInspectSymbol] = function inspect(recurseTimes, ctx) {\n  const max = INSPECT_MAX_BYTES;\n  const actualMax = MathMin(max, this.length);\n  const remaining = this.length - max;\n  let str = this.hexSlice(0, actualMax).replace(/(.{2})/g, '$1 ').trim();\n  if (remaining > 0)\n    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;\n  // Inspect special properties as well, if possible.\n  if (ctx) {\n    let extras = false;\n    const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;\n    const obj = getOwnNonIndexProperties(this, filter).reduce((obj, key) => {\n      extras = true;\n      obj[key] = this[key];\n      return obj;\n    }, ObjectCreate(null));\n    if (extras) {\n      if (this.length !== 0)\n        str += ', ';\n      // '[Object: null prototype] {'.length === 26\n      // This is guarded with a test.\n      str += utilInspect(obj, {\n        ...ctx,\n        breakLength: Infinity,\n        compact: true\n      }).slice(27, -2);\n    }\n  }\n  return `<${this.constructor.name} ${str}>`;\n};\nBuffer.prototype.inspect = Buffer.prototype[customInspectSymbol];\n\nBuffer.prototype.compare = function compare(target,\n                                            targetStart,\n                                            targetEnd,\n                                            sourceStart,\n                                            sourceEnd) {\n  if (!isUint8Array(target)) {\n    throw new ERR_INVALID_ARG_TYPE('target', ['Buffer', 'Uint8Array'], target);\n  }\n  if (arguments.length === 1)\n    return _compare(this, target);\n\n  if (targetStart === undefined)\n    targetStart = 0;\n  else\n    validateOffset(targetStart, 'targetStart');\n\n  if (targetEnd === undefined)\n    targetEnd = target.length;\n  else\n    validateOffset(targetEnd, 'targetEnd', 0, target.length);\n\n  if (sourceStart === undefined)\n    sourceStart = 0;\n  else\n    validateOffset(sourceStart, 'sourceStart');\n\n  if (sourceEnd === undefined)\n    sourceEnd = this.length;\n  else\n    validateOffset(sourceEnd, 'sourceEnd', 0, this.length);\n\n  if (sourceStart >= sourceEnd)\n    return (targetStart >= targetEnd ? 0 : -1);\n  if (targetStart >= targetEnd)\n    return 1;\n\n  return compareOffset(this, target, targetStart, sourceStart, targetEnd,\n                       sourceEnd);\n};\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant if val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n  validateBuffer(buffer);\n\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset;\n    byteOffset = undefined;\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff;\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000;\n  }\n  // Coerce to Number. Values like null and [] become 0.\n  byteOffset = +byteOffset;\n  // If the offset is undefined, \"foo\", {}, coerces to NaN, search whole buffer.\n  if (NumberIsNaN(byteOffset)) {\n    byteOffset = dir ? 0 : (buffer.length || buffer.byteLength);\n  }\n  dir = !!dir;  // Cast to bool.\n\n  if (typeof val === 'number')\n    return indexOfNumber(buffer, val >>> 0, byteOffset, dir);\n\n  let ops;\n  if (encoding === undefined)\n    ops = encodingOps.utf8;\n  else\n    ops = getEncodingOps(encoding);\n\n  if (typeof val === 'string') {\n    if (ops === undefined)\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    return ops.indexOf(buffer, val, byteOffset, dir);\n  }\n\n  if (isUint8Array(val)) {\n    const encodingVal =\n      (ops === undefined ? encodingsMap.utf8 : ops.encodingVal);\n    return indexOfBuffer(buffer, val, byteOffset, encodingVal, dir);\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    'value', ['number', 'string', 'Buffer', 'Uint8Array'], val\n  );\n}\n\nBuffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n};\n\nBuffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n};\n\nBuffer.prototype.includes = function includes(val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1;\n};\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill(value, offset, end, encoding) {\n  return _fill(this, value, offset, end, encoding);\n};\n\nfunction _fill(buf, value, offset, end, encoding) {\n  if (typeof value === 'string') {\n    if (offset === undefined || typeof offset === 'string') {\n      encoding = offset;\n      offset = 0;\n      end = buf.length;\n    } else if (typeof end === 'string') {\n      encoding = end;\n      end = buf.length;\n    }\n\n    const normalizedEncoding = normalizeEncoding(encoding);\n    if (normalizedEncoding === undefined) {\n      validateString(encoding, 'encoding');\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    }\n\n    if (value.length === 0) {\n      // If value === '' default to zero.\n      value = 0;\n    } else if (value.length === 1) {\n      // Fast path: If `value` fits into a single byte, use that numeric value.\n      if (normalizedEncoding === 'utf8') {\n        const code = value.charCodeAt(0);\n        if (code < 128) {\n          value = code;\n        }\n      } else if (normalizedEncoding === 'latin1') {\n        value = value.charCodeAt(0);\n      }\n    }\n  } else {\n    encoding = undefined;\n  }\n\n  if (offset === undefined) {\n    offset = 0;\n    end = buf.length;\n  } else {\n    validateOffset(offset, 'offset');\n    // Invalid ranges are not set to a default, so can range check early.\n    if (end === undefined) {\n      end = buf.length;\n    } else {\n      validateOffset(end, 'end', 0, buf.length);\n    }\n    if (offset >= end)\n      return buf;\n  }\n\n\n  if (typeof value === 'number') {\n    // OOB check\n    const byteLen = TypedArrayProto_byteLength.call(buf);\n    const fillLength = end - offset;\n    if (offset > end || fillLength + offset > byteLen)\n      throw new ERR_BUFFER_OUT_OF_BOUNDS();\n\n    TypedArrayFill.call(buf, value, offset, end);\n  } else {\n    const res = bindingFill(buf, value, offset, end, encoding);\n    if (res < 0) {\n      if (res === -1)\n        throw new ERR_INVALID_ARG_VALUE('value', value);\n      throw new ERR_BUFFER_OUT_OF_BOUNDS();\n    }\n  }\n\n  return buf;\n}\n\nBuffer.prototype.write = function write(string, offset, length, encoding) {\n  // Buffer#write(string);\n  if (offset === undefined) {\n    return this.utf8Write(string, 0, this.length);\n  }\n  // Buffer#write(string, encoding)\n  if (length === undefined && typeof offset === 'string') {\n    encoding = offset;\n    length = this.length;\n    offset = 0;\n\n  // Buffer#write(string, offset[, length][, encoding])\n  } else {\n    validateOffset(offset, 'offset', 0, this.length);\n\n    const remaining = this.length - offset;\n\n    if (length === undefined) {\n      length = remaining;\n    } else if (typeof length === 'string') {\n      encoding = length;\n      length = remaining;\n    } else {\n      validateOffset(length, 'length', 0, this.length);\n      if (length > remaining)\n        length = remaining;\n    }\n  }\n\n  if (!encoding)\n    return this.utf8Write(string, offset, length);\n\n  const ops = getEncodingOps(encoding);\n  if (ops === undefined)\n    throw new ERR_UNKNOWN_ENCODING(encoding);\n  return ops.write(this, string, offset, length);\n};\n\nBuffer.prototype.toJSON = function toJSON() {\n  if (this.length > 0) {\n    const data = new Array(this.length);\n    for (let i = 0; i < this.length; ++i)\n      data[i] = this[i];\n    return { type: 'Buffer', data };\n  }\n  return { type: 'Buffer', data: [] };\n};\n\nfunction adjustOffset(offset, length) {\n  // Use Math.trunc() to convert offset to an integer value that can be larger\n  // than an Int32. Hence, don't use offset | 0 or similar techniques.\n  offset = MathTrunc(offset);\n  if (offset === 0) {\n    return 0;\n  }\n  if (offset < 0) {\n    offset += length;\n    return offset > 0 ? offset : 0;\n  }\n  if (offset < length) {\n    return offset;\n  }\n  return NumberIsNaN(offset) ? 0 : length;\n}\n\nBuffer.prototype.slice = function slice(start, end) {\n  const srcLength = this.length;\n  start = adjustOffset(start, srcLength);\n  end = end !== undefined ? adjustOffset(end, srcLength) : srcLength;\n  const newLength = end > start ? end - start : 0;\n  return new FastBuffer(this.buffer, this.byteOffset + start, newLength);\n};\n\nfunction swap(b, n, m) {\n  const i = b[n];\n  b[n] = b[m];\n  b[m] = i;\n}\n\nBuffer.prototype.swap16 = function swap16() {\n  // For Buffer.length < 128, it's generally faster to\n  // do the swap in javascript. For larger buffers,\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 2 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE('16-bits');\n  if (len < 128) {\n    for (let i = 0; i < len; i += 2)\n      swap(this, i, i + 1);\n    return this;\n  }\n  return _swap16(this);\n};\n\nBuffer.prototype.swap32 = function swap32() {\n  // For Buffer.length < 192, it's generally faster to\n  // do the swap in javascript. For larger buffers,\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 4 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE('32-bits');\n  if (len < 192) {\n    for (let i = 0; i < len; i += 4) {\n      swap(this, i, i + 3);\n      swap(this, i + 1, i + 2);\n    }\n    return this;\n  }\n  return _swap32(this);\n};\n\nBuffer.prototype.swap64 = function swap64() {\n  // For Buffer.length < 192, it's generally faster to\n  // do the swap in javascript. For larger buffers,\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 8 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE('64-bits');\n  if (len < 192) {\n    for (let i = 0; i < len; i += 8) {\n      swap(this, i, i + 7);\n      swap(this, i + 1, i + 6);\n      swap(this, i + 2, i + 5);\n      swap(this, i + 3, i + 4);\n    }\n    return this;\n  }\n  return _swap64(this);\n};\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString;\n\nlet transcode;\nif (internalBinding('config').hasIntl) {\n  const {\n    icuErrName,\n    transcode: _transcode\n  } = internalBinding('icu');\n\n  // Transcodes the Buffer from one encoding to another, returning a new\n  // Buffer instance.\n  transcode = function transcode(source, fromEncoding, toEncoding) {\n    if (!isUint8Array(source)) {\n      throw new ERR_INVALID_ARG_TYPE('source',\n                                     ['Buffer', 'Uint8Array'], source);\n    }\n    if (source.length === 0) return Buffer.alloc(0);\n\n    fromEncoding = normalizeEncoding(fromEncoding) || fromEncoding;\n    toEncoding = normalizeEncoding(toEncoding) || toEncoding;\n    const result = _transcode(source, fromEncoding, toEncoding);\n    if (typeof result !== 'number')\n      return result;\n\n    const code = icuErrName(result);\n    // eslint-disable-next-line no-restricted-syntax\n    const err = new Error(`Unable to transcode Buffer [${code}]`);\n    err.code = code;\n    err.errno = result;\n    throw err;\n  };\n}\n\nmodule.exports = {\n  Buffer,\n  SlowBuffer,\n  transcode,\n  // Legacy\n  kMaxLength,\n  kStringMaxLength\n};\n\nObjectDefineProperties(module.exports, {\n  constants: {\n    configurable: false,\n    enumerable: true,\n    value: constants\n  },\n  INSPECT_MAX_BYTES: {\n    configurable: true,\n    enumerable: true,\n    get() { return INSPECT_MAX_BYTES; },\n    set(val) { INSPECT_MAX_BYTES = val; }\n  }\n});\n"
  },
  {
    "url": "electron/js2c/asar_bundle.js",
    "ranges": [
      {
        "start": 0,
        "end": 262
      },
      {
        "start": 355,
        "end": 378
      },
      {
        "start": 548,
        "end": 571
      },
      {
        "start": 912,
        "end": 935
      },
      {
        "start": 1087,
        "end": 1110
      },
      {
        "start": 1173,
        "end": 1886
      },
      {
        "start": 1921,
        "end": 1951
      },
      {
        "start": 2039,
        "end": 2339
      },
      {
        "start": 2614,
        "end": 2627
      },
      {
        "start": 3115,
        "end": 3186
      },
      {
        "start": 3492,
        "end": 3582
      },
      {
        "start": 4031,
        "end": 4249
      },
      {
        "start": 4568,
        "end": 4621
      },
      {
        "start": 4855,
        "end": 4884
      },
      {
        "start": 5159,
        "end": 5185
      },
      {
        "start": 5587,
        "end": 5657
      },
      {
        "start": 5727,
        "end": 5751
      },
      {
        "start": 5876,
        "end": 5955
      },
      {
        "start": 6256,
        "end": 6399
      },
      {
        "start": 6839,
        "end": 7002
      },
      {
        "start": 7239,
        "end": 7269
      },
      {
        "start": 7505,
        "end": 7541
      },
      {
        "start": 7672,
        "end": 7700
      },
      {
        "start": 8371,
        "end": 8434
      },
      {
        "start": 9324,
        "end": 9337
      },
      {
        "start": 9870,
        "end": 9902
      },
      {
        "start": 10001,
        "end": 10051
      },
      {
        "start": 10180,
        "end": 10220
      },
      {
        "start": 10947,
        "end": 10977
      },
      {
        "start": 11746,
        "end": 11826
      },
      {
        "start": 12446,
        "end": 12518
      },
      {
        "start": 12978,
        "end": 13263
      },
      {
        "start": 13422,
        "end": 13494
      },
      {
        "start": 13603,
        "end": 13604
      },
      {
        "start": 13736,
        "end": 13946
      },
      {
        "start": 14162,
        "end": 15769
      },
      {
        "start": 15818,
        "end": 16259
      },
      {
        "start": 16297,
        "end": 16626
      }
    ],
    "text": "!function(t){var e={};function __webpack_require__(r){if(e[r])return e[r].exports;var n=e[r]={i:r,l:!1,exports:{}};return t[r].call(n.exports,n,n.exports,__webpack_require__),n.l=!0,n.exports}__webpack_require__.m=t,__webpack_require__.c=e,__webpack_require__.d=function(t,e,r){__webpack_require__.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:r})},__webpack_require__.r=function(t){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})},__webpack_require__.t=function(t,e){if(1&e&&(t=__webpack_require__(t)),8&e)return t;if(4&e&&\"object\"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(__webpack_require__.r(r),Object.defineProperty(r,\"default\",{enumerable:!0,value:t}),2&e&&\"string\"!=typeof t)for(var n in t)__webpack_require__.d(r,n,function(e){return t[e]}.bind(null,n));return r},__webpack_require__.n=function(t){var e=t&&t.__esModule?function getDefault(){return t.default}:function getModuleExports(){return t};return __webpack_require__.d(e,\"a\",e),e},__webpack_require__.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},__webpack_require__.p=\"\",__webpack_require__(__webpack_require__.s=\"./lib/asar/init.ts\")}({\"./lib/asar/fs-wrapper.ts\":\n/*!********************************!*\\\n  !*** ./lib/asar/fs-wrapper.ts ***!\n  \\********************************/\n/*! no static exports found */function(t,e,r){\"use strict\";(function(t,n){Object.defineProperty(e,\"__esModule\",{value:!0}),e.wrapFsWithAsar=void 0;const s=r(/*! buffer */\"buffer\"),i=r(/*! path */\"path\"),a=r(/*! util */\"util\"),o=t._linkedBinding(\"electron_common_asar\"),c=t._linkedBinding(\"electron_common_v8_util\"),f=r(/*! module */\"module\"),l=n.Promise,u=t.env.ELECTRON_NO_ASAR&&\"browser\"!==t.type&&\"renderer\"!==t.type,p=t.internalBinding;delete t.internalBinding;const nextTick=(e,r=[])=>{t.nextTick(()=>e(...r))},_=new Map,getOrCreateArchive=t=>{if(_.has(t))return _.get(t);const e=o.createArchive(t);return e?(_.set(t,e),e):null},h=/\\.asar/i,splitPath=e=>{if(t.noAsar||u)return{isAsar:!1};let r=e;return s.Buffer.isBuffer(e)&&(r=e.toString()),\"string\"!=typeof r?{isAsar:!1}:h.test(r)?o.splitPath(i.normalize(r)):{isAsar:!1}};let d=0;const y=null!=t.getuid?t.getuid():0,P=null!=t.getgid?t.getgid():0,N=new Date,asarStatsToFsStats=function(t){const{Stats:e,constants:n}=r(/*! fs */\"fs\");let s=n.S_IROTH^n.S_IRGRP^n.S_IRUSR^n.S_IWUSR;return t.isFile?s^=n.S_IFREG:t.isDirectory?s^=n.S_IFDIR:t.isLink&&(s^=n.S_IFLNK),new e(1,s,1,y,P,0,void 0,++d,t.size,void 0,N.getTime(),N.getTime(),N.getTime(),N.getTime())},createError=(t,{asarPath:e,filePath:r}={})=>{let n;switch(t){case\"NOT_FOUND\":n=new Error(`ENOENT, ${r} not found in ${e}`),n.code=\"ENOENT\",n.errno=-2;break;case\"NOT_DIR\":n=new Error(\"ENOTDIR, not a directory\"),n.code=\"ENOTDIR\",n.errno=-20;break;case\"NO_ACCESS\":n=new Error(`EACCES: permission denied, access '${r}'`),n.code=\"EACCES\",n.errno=-13;break;case\"INVALID_ARCHIVE\":n=new Error(`Invalid package ${e}`);break;default:throw new Error(`Invalid error type \"${t}\" passed to createError.`)}return n},overrideAPISync=function(t,e,r,n=!1){null==r&&(r=0);const s=t[e],func=function(...t){const e=t[r],n=splitPath(e);if(!n.isAsar)return s.apply(this,t);const{asarPath:i,filePath:a}=n,o=getOrCreateArchive(i);if(!o)throw createError(\"INVALID_ARCHIVE\",{asarPath:i});const c=o.copyFileOut(a);if(!c)throw createError(\"NOT_FOUND\",{asarPath:i,filePath:a});return t[r]=c,s.apply(this,t)};if(n)return func;t[e]=func},overrideAPI=function(t,e,r){null==r&&(r=0);const n=t[e];t[e]=function(...s){const i=s[r],a=splitPath(i);if(!a.isAsar)return n.apply(this,s);const{asarPath:o,filePath:c}=a,f=s[s.length-1];if(\"function\"!=typeof f)return overrideAPISync(t,e,r,!0).apply(this,s);const l=getOrCreateArchive(o);if(!l){const t=createError(\"INVALID_ARCHIVE\",{asarPath:o});return void nextTick(f,[t])}const u=l.copyFileOut(c);if(u)return s[r]=u,n.apply(this,s);{const t=createError(\"NOT_FOUND\",{asarPath:o,filePath:c});nextTick(f,[t])}},n[a.promisify.custom]&&(t[e][a.promisify.custom]=makePromiseFunction(n[a.promisify.custom],r)),t.promises&&t.promises[e]&&(t.promises[e]=makePromiseFunction(t.promises[e],r))},makePromiseFunction=function(t,e){return function(...r){const n=r[e],s=splitPath(n);if(!s.isAsar)return t.apply(this,r);const{asarPath:i,filePath:a}=s,o=getOrCreateArchive(i);if(!o)return l.reject(createError(\"INVALID_ARCHIVE\",{asarPath:i}));const c=o.copyFileOut(a);return c?(r[e]=c,t.apply(this,r)):l.reject(createError(\"NOT_FOUND\",{asarPath:i,filePath:a}))}};e.wrapFsWithAsar=e=>{const n=new Map,logASARAccess=(s,i,a)=>{if(t.env.ELECTRON_LOG_ASAR_READS){if(!n.has(s)){const t=r(/*! path */\"path\"),i=`${t.basename(s,\".asar\")}-access-log.txt`,a=t.join(r(/*! os */\"os\").tmpdir(),i);n.set(s,e.openSync(a,\"a\"))}e.writeSync(n.get(s),`${a}: ${i}\\n`)}},{lstatSync:o}=e;e.lstatSync=(t,e)=>{const r=splitPath(t);if(!r.isAsar)return o(t,e);const{asarPath:n,filePath:s}=r,i=getOrCreateArchive(n);if(!i)throw createError(\"INVALID_ARCHIVE\",{asarPath:n});const a=i.stat(s);if(!a)throw createError(\"NOT_FOUND\",{asarPath:n,filePath:s});return asarStatsToFsStats(a)};const{lstat:u}=e;e.lstat=function(t,e,r){const n=splitPath(t);if(\"function\"==typeof e&&(r=e,e={}),!n.isAsar)return u(t,e,r);const{asarPath:s,filePath:i}=n,a=getOrCreateArchive(s);if(!a){const t=createError(\"INVALID_ARCHIVE\",{asarPath:s});return void nextTick(r,[t])}const o=a.stat(i);if(!o){const t=createError(\"NOT_FOUND\",{asarPath:s,filePath:i});return void nextTick(r,[t])}const c=asarStatsToFsStats(o);nextTick(r,[null,c])},e.promises.lstat=a.promisify(e.lstat);const{statSync:_}=e;e.statSync=(t,r)=>{const{isAsar:n}=splitPath(t);return n?e.lstatSync(t,r):_(t,r)};const{stat:h}=e;e.stat=(r,n,s)=>{const{isAsar:i}=splitPath(r);if(\"function\"==typeof n&&(s=n,n={}),!i)return h(r,n,s);t.nextTick(()=>e.lstat(r,n,s))},e.promises.stat=a.promisify(e.stat);const wrapRealpathSync=function(t){return function(e,r){const n=splitPath(e);if(!n.isAsar)return t.apply(this,arguments);const{asarPath:s,filePath:a}=n,o=getOrCreateArchive(s);if(!o)throw createError(\"INVALID_ARCHIVE\",{asarPath:s});const c=o.realpath(a);if(!1===c)throw createError(\"NOT_FOUND\",{asarPath:s,filePath:a});return i.join(t(s,r),c)}},{realpathSync:d}=e;e.realpathSync=wrapRealpathSync(d),e.realpathSync.native=wrapRealpathSync(d.native);const wrapRealpath=function(t){return function(e,r,n){const s=splitPath(e);if(!s.isAsar)return t.apply(this,arguments);const{asarPath:a,filePath:o}=s;arguments.length<3&&(n=r,r={});const c=getOrCreateArchive(a);if(!c){const t=createError(\"INVALID_ARCHIVE\",{asarPath:a});return void nextTick(n,[t])}const f=c.realpath(o);if(!1!==f)t(a,r,(t,e)=>{if(null===t){const t=i.join(e,f);n(null,t)}else n(t)});else{const t=createError(\"NOT_FOUND\",{asarPath:a,filePath:o});nextTick(n,[t])}}},{realpath:y}=e;e.realpath=wrapRealpath(y),e.realpath.native=wrapRealpath(y.native),e.promises.realpath=a.promisify(e.realpath.native);const{exists:P}=e;e.exists=(t,e)=>{const r=splitPath(t);if(!r.isAsar)return P(t,e);const{asarPath:n,filePath:s}=r,i=getOrCreateArchive(n);if(!i){const t=createError(\"INVALID_ARCHIVE\",{asarPath:n});return void nextTick(e,[t])}const a=!1!==i.stat(s);nextTick(e,[a])},e.exists[a.promisify.custom]=t=>{const e=splitPath(t);if(!e.isAsar)return P[a.promisify.custom](t);const{asarPath:r,filePath:n}=e,s=getOrCreateArchive(r);if(!s){const t=createError(\"INVALID_ARCHIVE\",{asarPath:r});return l.reject(t)}return l.resolve(!1!==s.stat(n))};const{existsSync:N}=e;e.existsSync=t=>{const e=splitPath(t);if(!e.isAsar)return N(t);const{asarPath:r,filePath:n}=e,s=getOrCreateArchive(r);return!!s&&!1!==s.stat(n)};const{access:A}=e;e.access=function(t,r,n){const s=splitPath(t);if(!s.isAsar)return A.apply(this,arguments);const{asarPath:i,filePath:a}=s;\"function\"==typeof r&&(n=r,r=e.constants.F_OK);const o=getOrCreateArchive(i);if(!o){const t=createError(\"INVALID_ARCHIVE\",{asarPath:i});return void nextTick(n,[t])}const c=o.getFileInfo(a);if(!c){const t=createError(\"NOT_FOUND\",{asarPath:i,filePath:a});return void nextTick(n,[t])}if(c.unpacked){const t=o.copyFileOut(a);return e.access(t,r,n)}const f=o.stat(a);if(f)if(r&e.constants.W_OK){const t=createError(\"NO_ACCESS\",{asarPath:i,filePath:a});nextTick(n,[t])}else nextTick(n);else{const t=createError(\"NOT_FOUND\",{asarPath:i,filePath:a});nextTick(n,[t])}},e.promises.access=a.promisify(e.access);const{accessSync:O}=e;function fsReadFileAsar(t,r,n){const i=splitPath(t);if(i.isAsar){const{asarPath:t,filePath:a}=i;if(\"function\"==typeof r)n=r,r={encoding:null};else if(\"string\"==typeof r)r={encoding:r};else if(null==r)r={encoding:null};else if(\"object\"!=typeof r)throw new TypeError(\"Bad arguments\");const{encoding:o}=r,c=getOrCreateArchive(t);if(!c){const e=createError(\"INVALID_ARCHIVE\",{asarPath:t});return void nextTick(n,[e])}const f=c.getFileInfo(a);if(!f){const e=createError(\"NOT_FOUND\",{asarPath:t,filePath:a});return void nextTick(n,[e])}if(0===f.size)return void nextTick(n,[null,o?\"\":s.Buffer.alloc(0)]);if(f.unpacked){const t=c.copyFileOut(a);return e.readFile(t,r,n)}const l=s.Buffer.alloc(f.size),u=c.getFd();if(!(u>=0)){const e=createError(\"NOT_FOUND\",{asarPath:t,filePath:a});return void nextTick(n,[e])}logASARAccess(t,a,f.offset),e.read(u,l,0,f.size,f.offset,t=>{n(t,o?l.toString(o):l)})}}e.accessSync=function(t,r){const n=splitPath(t);if(!n.isAsar)return O.apply(this,arguments);const{asarPath:s,filePath:i}=n;null==r&&(r=e.constants.F_OK);const a=getOrCreateArchive(s);if(!a)throw createError(\"INVALID_ARCHIVE\",{asarPath:s});const o=a.getFileInfo(i);if(!o)throw createError(\"NOT_FOUND\",{asarPath:s,filePath:i});if(o.unpacked){const t=a.copyFileOut(i);return e.accessSync(t,r)}const c=a.stat(i);if(!c)throw createError(\"NOT_FOUND\",{asarPath:s,filePath:i});if(r&e.constants.W_OK)throw createError(\"NO_ACCESS\",{asarPath:s,filePath:i})};const{readFile:I}=e;e.readFile=function(t,e,r){const n=splitPath(t);return n.isAsar?fsReadFileAsar(t,e,r):I.apply(this,arguments)};const{readFile:w}=e.promises;e.promises.readFile=function(t,e){const r=splitPath(t);if(!r.isAsar)return w.apply(this,arguments);const n=a.promisify(fsReadFileAsar);return n(t,e)};const{readFileSync:m}=e;e.readFileSync=function(t,r){const n=splitPath(t);if(!n.isAsar)return m.apply(this,arguments);const{asarPath:i,filePath:a}=n,o=getOrCreateArchive(i);if(!o)throw createError(\"INVALID_ARCHIVE\",{asarPath:i});const c=o.getFileInfo(a);if(!c)throw createError(\"NOT_FOUND\",{asarPath:i,filePath:a});if(0===c.size)return r?\"\":s.Buffer.alloc(0);if(c.unpacked){const t=o.copyFileOut(a);return e.readFileSync(t,r)}if(r){if(\"string\"==typeof r)r={encoding:r};else if(\"object\"!=typeof r)throw new TypeError(\"Bad arguments\")}else r={encoding:null};const{encoding:f}=r,l=s.Buffer.alloc(c.size),u=o.getFd();if(!(u>=0))throw createError(\"NOT_FOUND\",{asarPath:i,filePath:a});return logASARAccess(i,a,c.offset),e.readSync(u,l,0,c.size,c.offset),f?l.toString(f):l};const{readdir:F}=e;e.readdir=function(t,r={},n){const s=splitPath(t);if(\"function\"==typeof r&&(n=r,r={}),!s.isAsar)return F.apply(this,arguments);const{asarPath:a,filePath:o}=s,c=getOrCreateArchive(a);if(!c){const t=createError(\"INVALID_ARCHIVE\",{asarPath:a});return void nextTick(n,[t])}const f=c.readdir(o);if(f)if(r.withFileTypes){const t=[];for(const r of f){const s=i.join(o,r),f=c.stat(s);if(!f){const t=createError(\"NOT_FOUND\",{asarPath:a,filePath:s});return void nextTick(n,[t])}f.isFile?t.push(new e.Dirent(r,e.constants.UV_DIRENT_FILE)):f.isDirectory?t.push(new e.Dirent(r,e.constants.UV_DIRENT_DIR)):f.isLink&&t.push(new e.Dirent(r,e.constants.UV_DIRENT_LINK))}nextTick(n,[null,t])}else nextTick(n,[null,f]);else{const t=createError(\"NOT_FOUND\",{asarPath:a,filePath:o});nextTick(n,[t])}},e.promises.readdir=a.promisify(e.readdir);const{readdirSync:S}=e;e.readdirSync=function(t,r){const n=splitPath(t);if(!n.isAsar)return S.apply(this,arguments);const{asarPath:s,filePath:a}=n,o=getOrCreateArchive(s);if(!o)throw createError(\"INVALID_ARCHIVE\",{asarPath:s});const c=o.readdir(a);if(!c)throw createError(\"NOT_FOUND\",{asarPath:s,filePath:a});if(r&&r.withFileTypes){const t=[];for(const r of c){const n=i.join(a,r),c=o.stat(n);if(!c)throw createError(\"NOT_FOUND\",{asarPath:s,filePath:n});c.isFile?t.push(new e.Dirent(r,e.constants.UV_DIRENT_FILE)):c.isDirectory?t.push(new e.Dirent(r,e.constants.UV_DIRENT_DIR)):c.isLink&&t.push(new e.Dirent(r,e.constants.UV_DIRENT_LINK))}return t}return c};const{internalModuleReadJSON:g}=p(\"fs\");p(\"fs\").internalModuleReadJSON=t=>{const r=splitPath(t);if(!r.isAsar)return g(t);const{asarPath:n,filePath:i}=r,a=getOrCreateArchive(n);if(!a)return[];const o=a.getFileInfo(i);if(!o)return[];if(0===o.size)return[\"\",!1];if(o.unpacked){const t=a.copyFileOut(i),r=e.readFileSync(t,{encoding:\"utf8\"});return[r,r.length>0]}const c=s.Buffer.alloc(o.size),f=a.getFd();if(!(f>=0))return[];logASARAccess(n,i,o.offset),e.readSync(f,c,0,o.size,o.offset);const l=c.toString(\"utf8\");return[l,l.length>0]};const{internalModuleStat:D}=p(\"fs\");if(p(\"fs\").internalModuleStat=t=>{const e=splitPath(t);if(!e.isAsar)return D(t);const{asarPath:r,filePath:n}=e,s=getOrCreateArchive(r);if(!s)return-34;const i=s.stat(n);return i?i.isDirectory?1:0:-34},\"win32\"===t.platform){const{mkdir:t}=e;e.mkdir=(e,r,n)=>{\"function\"==typeof r&&(n=r,r={});const s=splitPath(e);if(s.isAsar&&s.filePath.length>0){const t=createError(\"NOT_DIR\");nextTick(n,[t])}else t(e,r,n)},e.promises.mkdir=a.promisify(e.mkdir);const{mkdirSync:r}=e;e.mkdirSync=function(t,e){const n=splitPath(t);if(n.isAsar&&n.filePath.length)throw createError(\"NOT_DIR\");return r(t,e)}}function invokeWithNoAsar(e){return function(){const r=t.noAsar;t.noAsar=!0;try{return e.apply(this,arguments)}finally{t.noAsar=r}}}overrideAPI(e,\"copyFile\"),overrideAPISync(e,\"copyFileSync\"),overrideAPI(e,\"open\"),overrideAPISync(t,\"dlopen\",1),overrideAPISync(f._extensions,\".node\",1),overrideAPISync(e,\"openSync\");const overrideChildProcess=t=>{const{exec:e,execSync:r}=t;t.exec=invokeWithNoAsar(e),t.exec[a.promisify.custom]=invokeWithNoAsar(e[a.promisify.custom]),t.execSync=invokeWithNoAsar(r),overrideAPI(t,\"execFile\"),overrideAPISync(t,\"execFileSync\")};if(t.env.ELECTRON_EAGER_ASAR_HOOK_FOR_TESTING)overrideChildProcess(r(/*! child_process */\"child_process\"));else{const t=f._load;f._load=(e,...r)=>{const n=t(e,...r);if(\"child_process\"===e&&!c.getHiddenValue(n,\"asar-ready\")){c.setHiddenValue(n,\"asar-ready\",!0),overrideChildProcess(n)}return n}}}}).call(this,r(/*! @electron/internal/common/webpack-provider */\"./lib/common/webpack-provider.ts\").process,r(/*! @electron/internal/common/webpack-provider */\"./lib/common/webpack-provider.ts\")._global)},\"./lib/asar/init.ts\":\n/*!**************************!*\\\n  !*** ./lib/asar/init.ts ***!\n  \\**************************/\n/*! no static exports found */function(t,e,r){\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),r(/*! ./fs-wrapper */\"./lib/asar/fs-wrapper.ts\").wrapFsWithAsar(r(/*! fs */\"fs\"))},\"./lib/common/webpack-provider.ts\":\n/*!****************************************!*\\\n  !*** ./lib/common/webpack-provider.ts ***!\n  \\****************************************/\n/*! no static exports found */function(t,e,r){\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.Buffer=e.process=e._global=void 0;const n=\"undefined\"!=typeof globalThis?globalThis.global:(self||window).global;e._global=n;const s=n.process;e.process=s;const i=n.Buffer;e.Buffer=i},buffer:\n/*!*************************!*\\\n  !*** external \"buffer\" ***!\n  \\*************************/\n/*! no static exports found */function(t,e){t.exports=require(\"buffer\")},child_process:\n/*!********************************!*\\\n  !*** external \"child_process\" ***!\n  \\********************************/\n/*! no static exports found */function(t,e){t.exports=require(\"child_process\")},fs:\n/*!*********************!*\\\n  !*** external \"fs\" ***!\n  \\*********************/\n/*! no static exports found */function(t,e){t.exports=require(\"fs\")},module:\n/*!*************************!*\\\n  !*** external \"module\" ***!\n  \\*************************/\n/*! no static exports found */function(t,e){t.exports=require(\"module\")},os:\n/*!*********************!*\\\n  !*** external \"os\" ***!\n  \\*********************/\n/*! no static exports found */function(t,e){t.exports=require(\"os\")},path:\n/*!***********************!*\\\n  !*** external \"path\" ***!\n  \\***********************/\n/*! no static exports found */function(t,e){t.exports=require(\"path\")},util:\n/*!***********************!*\\\n  !*** external \"util\" ***!\n  \\***********************/\n/*! no static exports found */function(t,e){t.exports=require(\"util\")}});"
  },
  {
    "url": "electron/js2c/renderer_init.js",
    "ranges": [
      {
        "start": 0,
        "end": 304
      },
      {
        "start": 397,
        "end": 420
      },
      {
        "start": 590,
        "end": 613
      },
      {
        "start": 954,
        "end": 977
      },
      {
        "start": 1129,
        "end": 1152
      },
      {
        "start": 1215,
        "end": 1518
      },
      {
        "start": 2144,
        "end": 2336
      },
      {
        "start": 3170,
        "end": 3464
      },
      {
        "start": 3669,
        "end": 3707
      },
      {
        "start": 3715,
        "end": 3727
      },
      {
        "start": 3732,
        "end": 3738
      },
      {
        "start": 3814,
        "end": 3819
      },
      {
        "start": 3969,
        "end": 3985
      },
      {
        "start": 4146,
        "end": 4162
      },
      {
        "start": 4279,
        "end": 4280
      },
      {
        "start": 4371,
        "end": 4378
      },
      {
        "start": 4557,
        "end": 4573
      },
      {
        "start": 4989,
        "end": 5005
      },
      {
        "start": 5147,
        "end": 5618
      },
      {
        "start": 5674,
        "end": 5697
      },
      {
        "start": 5745,
        "end": 5772
      },
      {
        "start": 5828,
        "end": 6018
      },
      {
        "start": 6279,
        "end": 7337
      },
      {
        "start": 7394,
        "end": 7882
      },
      {
        "start": 7887,
        "end": 8524
      },
      {
        "start": 8676,
        "end": 8747
      },
      {
        "start": 8863,
        "end": 9004
      },
      {
        "start": 9066,
        "end": 9316
      },
      {
        "start": 9404,
        "end": 9693
      },
      {
        "start": 11742,
        "end": 11942
      },
      {
        "start": 13372,
        "end": 13576
      },
      {
        "start": 14712,
        "end": 14948
      },
      {
        "start": 15184,
        "end": 16174
      },
      {
        "start": 16313,
        "end": 16618
      },
      {
        "start": 16682,
        "end": 16697
      },
      {
        "start": 16727,
        "end": 17119
      },
      {
        "start": 17527,
        "end": 17755
      },
      {
        "start": 18510,
        "end": 19618
      },
      {
        "start": 19657,
        "end": 19669
      },
      {
        "start": 19712,
        "end": 19726
      },
      {
        "start": 19768,
        "end": 19778
      },
      {
        "start": 19823,
        "end": 19833
      },
      {
        "start": 19978,
        "end": 19993
      },
      {
        "start": 20037,
        "end": 20643
      },
      {
        "start": 20711,
        "end": 20742
      },
      {
        "start": 20810,
        "end": 20839
      },
      {
        "start": 20903,
        "end": 20932
      },
      {
        "start": 20996,
        "end": 21140
      },
      {
        "start": 21242,
        "end": 21296
      },
      {
        "start": 21378,
        "end": 21701
      },
      {
        "start": 22298,
        "end": 22486
      },
      {
        "start": 29711,
        "end": 30268
      },
      {
        "start": 30891,
        "end": 31067
      },
      {
        "start": 31352,
        "end": 31466
      },
      {
        "start": 31520,
        "end": 32790
      },
      {
        "start": 32962,
        "end": 34758
      },
      {
        "start": 34876,
        "end": 34902
      },
      {
        "start": 35038,
        "end": 35718
      },
      {
        "start": 37806,
        "end": 38328
      },
      {
        "start": 38446,
        "end": 38462
      },
      {
        "start": 38562,
        "end": 39050
      },
      {
        "start": 39089,
        "end": 39101
      },
      {
        "start": 39144,
        "end": 39154
      },
      {
        "start": 39199,
        "end": 39711
      },
      {
        "start": 40763,
        "end": 42089
      },
      {
        "start": 42208,
        "end": 42221
      },
      {
        "start": 42307,
        "end": 42390
      },
      {
        "start": 42461,
        "end": 42827
      },
      {
        "start": 42867,
        "end": 42876
      },
      {
        "start": 42921,
        "end": 42927
      },
      {
        "start": 42947,
        "end": 44421
      },
      {
        "start": 44427,
        "end": 47948
      },
      {
        "start": 48039,
        "end": 48302
      },
      {
        "start": 50470,
        "end": 50730
      },
      {
        "start": 56080,
        "end": 56328
      },
      {
        "start": 58059,
        "end": 58295
      },
      {
        "start": 63485,
        "end": 64370
      },
      {
        "start": 64609,
        "end": 65767
      },
      {
        "start": 65791,
        "end": 65801
      },
      {
        "start": 65820,
        "end": 65848
      },
      {
        "start": 65936,
        "end": 65957
      },
      {
        "start": 66568,
        "end": 66655
      },
      {
        "start": 66728,
        "end": 66733
      },
      {
        "start": 66845,
        "end": 66848
      },
      {
        "start": 67323,
        "end": 68004
      },
      {
        "start": 69263,
        "end": 69331
      },
      {
        "start": 69393,
        "end": 69499
      },
      {
        "start": 69705,
        "end": 69974
      },
      {
        "start": 70043,
        "end": 70199
      },
      {
        "start": 70357,
        "end": 70398
      },
      {
        "start": 70469,
        "end": 70597
      },
      {
        "start": 70671,
        "end": 70800
      },
      {
        "start": 70880,
        "end": 71004
      },
      {
        "start": 71070,
        "end": 71139
      },
      {
        "start": 71146,
        "end": 71355
      },
      {
        "start": 71436,
        "end": 71463
      },
      {
        "start": 71480,
        "end": 71687
      },
      {
        "start": 71692,
        "end": 72652
      },
      {
        "start": 72694,
        "end": 73272
      }
    ],
    "text": "try{function ___electron_webpack_init__(){!function(e){var t={};function __webpack_require__(n){if(t[n])return t[n].exports;var r=t[n]={i:n,l:!1,exports:{}};return e[n].call(r.exports,r,r.exports,__webpack_require__),r.l=!0,r.exports}__webpack_require__.m=e,__webpack_require__.c=t,__webpack_require__.d=function(e,t,n){__webpack_require__.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},__webpack_require__.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},__webpack_require__.t=function(e,t){if(1&t&&(e=__webpack_require__(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(__webpack_require__.r(n),Object.defineProperty(n,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var r in e)__webpack_require__.d(n,r,function(t){return e[t]}.bind(null,r));return n},__webpack_require__.n=function(e){var t=e&&e.__esModule?function getDefault(){return e.default}:function getModuleExports(){return e};return __webpack_require__.d(t,\"a\",t),t},__webpack_require__.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},__webpack_require__.p=\"\",__webpack_require__(__webpack_require__.s=\"./lib/renderer/init.ts\")}({\"./lib/browser/api/module-names.ts\":\n/*!*****************************************!*\\\n  !*** ./lib/browser/api/module-names.ts ***!\n  \\*****************************************/\n/*! no static exports found */function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.browserModuleNames=void 0,t.browserModuleNames=[\"app\",\"autoUpdater\",\"BaseWindow\",\"BrowserView\",\"BrowserWindow\",\"contentTracing\",\"crashReporter\",\"dialog\",\"globalShortcut\",\"ipcMain\",\"inAppPurchase\",\"Menu\",\"MenuItem\",\"nativeImage\",\"nativeTheme\",\"net\",\"netLog\",\"MessageChannelMain\",\"Notification\",\"powerMonitor\",\"powerSaveBlocker\",\"protocol\",\"screen\",\"session\",\"ShareMenu\",\"systemPreferences\",\"TouchBar\",\"Tray\",\"View\",\"webContents\",\"WebContentsView\",\"webFrameMain\"],t.browserModuleNames.push(\"desktopCapturer\"),t.browserModuleNames.push(\"ImageView\")},\"./lib/common/api/clipboard.ts\":\n/*!*************************************!*\\\n  !*** ./lib/common/api/clipboard.ts ***!\n  \\*************************************/\n/*! no static exports found */function(e,t,n){\"use strict\";(function(e){Object.defineProperty(t,\"__esModule\",{value:!0});const r=e._linkedBinding(\"electron_common_clipboard\");if(\"renderer\"===e.type){const t=n(/*! @electron/internal/renderer/ipc-renderer-internal-utils */\"./lib/renderer/ipc-renderer-internal-utils.ts\"),o=n(/*! @electron/internal/common/type-utils */\"./lib/common/type-utils.ts\"),makeRemoteMethod=function(e){return(...n)=>{n=o.serialize(n);const r=t.invokeSync(\"BROWSER_CLIPBOARD_SYNC\",e,...n);return o.deserialize(r)}};if(\"linux\"===e.platform)for(const e of Object.keys(r))r[e]=makeRemoteMethod(e);else\"darwin\"===e.platform&&(r.readFindText=makeRemoteMethod(\"readFindText\"),r.writeFindText=makeRemoteMethod(\"writeFindText\"))}t.default=r}).call(this,n(/*! @electron/internal/common/webpack-provider */\"./lib/common/webpack-provider.ts\").process)},\"./lib/common/api/deprecate.ts\":\n/*!*************************************!*\\\n  !*** ./lib/common/api/deprecate.ts ***!\n  \\*************************************/\n/*! no static exports found */function(e,t,n){\"use strict\";(function(e){Object.defineProperty(t,\"__esModule\",{value:!0});let n=null;function warnOnce(t,n){let o=!1;const i=n?`'${t}' is deprecated and will be removed. Please use '${n}' instead.`:`'${t}' is deprecated and will be removed.`;return()=>{o||e.noDeprecation||(o=!0,r.log(i))}}const r={warnOnce:warnOnce,setHandler:e=>{n=e},getHandler:()=>n,warn:(t,n)=>{e.noDeprecation||r.log(`'${t}' is deprecated. Use '${n}' instead.`)},log:t=>{if(\"function\"!=typeof n){if(e.throwDeprecation)throw new Error(t);return e.traceDeprecation?console.trace(t):console.warn(`(electron) ${t}`)}n(t)},removeFunction:(e,t)=>{if(!e)throw Error(`'${t} function' is invalid or does not exist.`);const n=warnOnce(`${e.name} function`);return function(){n(),e.apply(this,arguments)}},renameFunction:(e,t)=>{const n=warnOnce(`${e.name} function`,`${t} function`);return function(){return n(),e.apply(this,arguments)}},moveAPI(e,t,n){const r=warnOnce(t,n);return function(){return r(),e.apply(this,arguments)}},event:(e,t,n)=>{const r=n.startsWith(\"-\")?warnOnce(`${t} event`):warnOnce(`${t} event`,`${n} event`);return e.on(n,(function(...e){0!==this.listenerCount(t)&&(r(),this.emit(t,...e))}))},removeProperty:(e,t,n)=>{const o=Object.getOwnPropertyDescriptor(e.__proto__,t);if(!o)return r.log(`Unable to remove property '${t}' from an object that lacks it.`),e;if(!o.get||!o.set)return r.log(`Unable to remove property '${t}' from an object does not have a getter / setter`),e;const i=warnOnce(t);return Object.defineProperty(e,t,{configurable:!0,get:()=>(i(),o.get.call(e)),set:t=>(n&&!n.includes(t)||i(),o.set.call(e,t))})},renameProperty:(e,t,n)=>{const r=warnOnce(t,n);return t in e&&!(n in e)&&(r(),e[n]=e[t]),Object.defineProperty(e,t,{get:()=>(r(),e[n]),set:t=>{r(),e[n]=t}})}};t.default=r}).call(this,n(/*! @electron/internal/common/webpack-provider */\"./lib/common/webpack-provider.ts\").process)},\"./lib/common/api/module-list.ts\":\n/*!***************************************!*\\\n  !*** ./lib/common/api/module-list.ts ***!\n  \\***************************************/\n/*! no static exports found */function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.commonModuleList=void 0,t.commonModuleList=[{name:\"clipboard\",loader:()=>n(/*! ./clipboard */\"./lib/common/api/clipboard.ts\")},{name:\"shell\",loader:()=>n(/*! ./shell */\"./lib/common/api/shell.ts\")},{name:\"deprecate\",loader:()=>n(/*! ./deprecate */\"./lib/common/api/deprecate.ts\"),private:!0}]},\"./lib/common/api/shell.ts\":\n/*!*********************************!*\\\n  !*** ./lib/common/api/shell.ts ***!\n  \\*********************************/\n/*! no static exports found */function(e,t,n){\"use strict\";(function(e){Object.defineProperty(t,\"__esModule\",{value:!0});const n=e._linkedBinding(\"electron_common_shell\");t.default=n}).call(this,n(/*! @electron/internal/common/webpack-provider */\"./lib/common/webpack-provider.ts\").process)},\"./lib/common/define-properties.ts\":\n/*!*****************************************!*\\\n  !*** ./lib/common/define-properties.ts ***!\n  \\*****************************************/\n/*! no static exports found */function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.defineProperties=void 0;const handleESModule=e=>()=>{const t=e();return t.__esModule&&t.default?t.default:t};t.defineProperties=function defineProperties(e,t){const n={};for(const e of t)n[e.name]={enumerable:!e.private,get:handleESModule(e.loader)};return Object.defineProperties(e,n)}},\"./lib/common/init.ts\":\n/*!****************************!*\\\n  !*** ./lib/common/init.ts ***!\n  \\****************************/\n/*! no static exports found */function(e,t,n){\"use strict\";(function(e,r){Object.defineProperty(t,\"__esModule\",{value:!0});const o=n(/*! util */\"util\"),i=n(/*! timers */\"timers\"),wrapWithActivateUvLoop=function(t){return function wrap(e,t){const n=t(e);e[o.promisify.custom]&&(n[o.promisify.custom]=t(e[o.promisify.custom]));return n}(t,(function(t){return function(...n){return e.activateUvLoop(),t.apply(this,n)}}))};if(e.nextTick=wrapWithActivateUvLoop(e.nextTick),r.setImmediate=i.setImmediate=wrapWithActivateUvLoop(i.setImmediate),r.clearImmediate=i.clearImmediate,i.setTimeout=wrapWithActivateUvLoop(i.setTimeout),i.setInterval=wrapWithActivateUvLoop(i.setInterval),\"browser\"===e.type&&(r.setTimeout=i.setTimeout,r.setInterval=i.setInterval),\"win32\"===e.platform){const{Readable:t}=n(/*! stream */\"stream\"),r=new t;r.push(null),Object.defineProperty(e,\"stdin\",{configurable:!1,enumerable:!0,get:()=>r})}}).call(this,n(/*! @electron/internal/common/webpack-provider */\"./lib/common/webpack-provider.ts\").process,n(/*! @electron/internal/common/webpack-provider */\"./lib/common/webpack-provider.ts\")._global)},\"./lib/common/reset-search-paths.ts\":\n/*!******************************************!*\\\n  !*** ./lib/common/reset-search-paths.ts ***!\n  \\******************************************/\n/*! no static exports found */function(e,t,n){\"use strict\";(function(e){Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(/*! path */\"path\"),o=n(/*! module */\"module\");if(o.globalPaths.length=0,\"renderer\"===e.type){const e=o._load;o._load=function(t){return\"vm\"===t&&console.warn(\"The vm module of Node.js is deprecated in the renderer process and will be removed.\"),e.apply(this,arguments)}}const i=e.resourcesPath+r.sep,s=o._nodeModulePaths;o._nodeModulePaths=function(e){const t=s(e);return(r.resolve(e)+r.sep).startsWith(i)?t.filter((function(e){return e.startsWith(i)})):t};const makeElectronModule=e=>{const t=new o(\"electron\",null);t.id=\"electron\",t.loaded=!0,t.filename=e,Object.defineProperty(t,\"exports\",{get:()=>n(/*! electron */\"./lib/renderer/api/exports/electron.ts\")}),o._cache[e]=t};makeElectronModule(\"electron\"),makeElectronModule(\"electron/common\"),\"browser\"===e.type&&makeElectronModule(\"electron/main\"),\"renderer\"===e.type&&makeElectronModule(\"electron/renderer\");const a=o._resolveFilename;o._resolveFilename=function(e,t,n,r){return\"electron\"===e||e.startsWith(\"electron/\")?\"electron\":a(e,t,n,r)}}).call(this,n(/*! @electron/internal/common/webpack-provider */\"./lib/common/webpack-provider.ts\").process)},\"./lib/common/type-utils.ts\":\n/*!**********************************!*\\\n  !*** ./lib/common/type-utils.ts ***!\n  \\**********************************/\n/*! no static exports found */function(e,t,n){\"use strict\";(function(e){Object.defineProperty(t,\"__esModule\",{value:!0}),t.deserialize=t.serialize=t.isSerializableObject=t.isPromise=void 0;const{nativeImage:n}=e._linkedBinding(\"electron_common_native_image\");t.isPromise=function isPromise(e){return e&&e.then&&e.then instanceof Function&&e.constructor&&e.constructor.reject&&e.constructor.reject instanceof Function&&e.constructor.resolve&&e.constructor.resolve instanceof Function};const r=[Boolean,Number,String,Date,Error,RegExp,ArrayBuffer];function isSerializableObject(e){return null===e||ArrayBuffer.isView(e)||r.some(t=>e instanceof t)}t.isSerializableObject=isSerializableObject;const objectMap=function(e,t){const n=Object.entries(e).map(([e,n])=>[e,t(n)]);return Object.fromEntries(n)};t.serialize=function serialize(e){return e&&e.constructor&&\"NativeImage\"===e.constructor.name?function serializeNativeImage(e){const t=[],n=e.getScaleFactors();if(1===n.length){const r=n[0],o=e.getSize(r),i=e.toBitmap({scaleFactor:r});t.push({scaleFactor:r,size:o,buffer:i})}else for(const r of n){const n=e.getSize(r),o=e.toDataURL({scaleFactor:r});t.push({scaleFactor:r,size:n,dataURL:o})}return{__ELECTRON_SERIALIZED_NativeImage__:!0,representations:t}}(e):Array.isArray(e)?e.map(serialize):isSerializableObject(e)?e:e instanceof Object?objectMap(e,serialize):e},t.deserialize=function deserialize(e){return e&&e.__ELECTRON_SERIALIZED_NativeImage__?function deserializeNativeImage(e){const t=n.createEmpty();if(1===e.representations.length){const{buffer:n,size:r,scaleFactor:o}=e.representations[0],{width:i,height:s}=r;t.addRepresentation({buffer:n,scaleFactor:o,width:i,height:s})}else for(const n of e.representations){const{dataURL:e,size:r,scaleFactor:o}=n,{width:i,height:s}=r;t.addRepresentation({dataURL:e,scaleFactor:o,width:i,height:s})}return t}(e):Array.isArray(e)?e.map(deserialize):isSerializableObject(e)?e:e instanceof Object?objectMap(e,deserialize):e}}).call(this,n(/*! @electron/internal/common/webpack-provider */\"./lib/common/webpack-provider.ts\").process)},\"./lib/common/web-view-events.ts\":\n/*!***************************************!*\\\n  !*** ./lib/common/web-view-events.ts ***!\n  \\***************************************/\n/*! no static exports found */function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.webViewEvents=void 0,t.webViewEvents={\"load-commit\":[\"url\",\"isMainFrame\"],\"did-attach\":[],\"did-finish-load\":[],\"did-fail-load\":[\"errorCode\",\"errorDescription\",\"validatedURL\",\"isMainFrame\",\"frameProcessId\",\"frameRoutingId\"],\"did-frame-finish-load\":[\"isMainFrame\",\"frameProcessId\",\"frameRoutingId\"],\"did-start-loading\":[],\"did-stop-loading\":[],\"dom-ready\":[],\"console-message\":[\"level\",\"message\",\"line\",\"sourceId\"],\"context-menu\":[\"params\"],\"devtools-opened\":[],\"devtools-closed\":[],\"devtools-focused\":[],\"new-window\":[\"url\",\"frameName\",\"disposition\",\"options\"],\"will-navigate\":[\"url\"],\"did-start-navigation\":[\"url\",\"isInPlace\",\"isMainFrame\",\"frameProcessId\",\"frameRoutingId\"],\"did-navigate\":[\"url\",\"httpResponseCode\",\"httpStatusText\"],\"did-frame-navigate\":[\"url\",\"httpResponseCode\",\"httpStatusText\",\"isMainFrame\",\"frameProcessId\",\"frameRoutingId\"],\"did-navigate-in-page\":[\"url\",\"isMainFrame\",\"frameProcessId\",\"frameRoutingId\"],\"focus-change\":[\"focus\",\"guestInstanceId\"],close:[],crashed:[],\"render-process-gone\":[\"details\"],\"plugin-crashed\":[\"name\",\"version\"],destroyed:[],\"page-title-updated\":[\"title\",\"explicitSet\"],\"page-favicon-updated\":[\"favicons\"],\"enter-html-full-screen\":[],\"leave-html-full-screen\":[],\"media-started-playing\":[],\"media-paused\":[],\"found-in-page\":[\"result\"],\"did-change-theme-color\":[\"themeColor\"],\"update-target-url\":[\"url\"]}},\"./lib/common/web-view-methods.ts\":\n/*!****************************************!*\\\n  !*** ./lib/common/web-view-methods.ts ***!\n  \\****************************************/\n/*! no static exports found */function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.asyncMethods=t.properties=t.syncMethods=void 0,t.syncMethods=new Set([\"getURL\",\"getTitle\",\"isLoading\",\"isLoadingMainFrame\",\"isWaitingForResponse\",\"stop\",\"reload\",\"reloadIgnoringCache\",\"canGoBack\",\"canGoForward\",\"canGoToOffset\",\"clearHistory\",\"goBack\",\"goForward\",\"goToIndex\",\"goToOffset\",\"isCrashed\",\"setUserAgent\",\"getUserAgent\",\"openDevTools\",\"closeDevTools\",\"isDevToolsOpened\",\"isDevToolsFocused\",\"inspectElement\",\"setAudioMuted\",\"isAudioMuted\",\"isCurrentlyAudible\",\"undo\",\"redo\",\"cut\",\"copy\",\"paste\",\"pasteAndMatchStyle\",\"delete\",\"selectAll\",\"unselect\",\"replace\",\"replaceMisspelling\",\"findInPage\",\"stopFindInPage\",\"downloadURL\",\"inspectSharedWorker\",\"inspectServiceWorker\",\"showDefinitionForSelection\",\"getZoomFactor\",\"getZoomLevel\",\"setZoomFactor\",\"setZoomLevel\"]),t.properties=new Set([\"audioMuted\",\"userAgent\",\"zoomLevel\",\"zoomFactor\",\"frameRate\"]),t.asyncMethods=new Set([\"loadURL\",\"executeJavaScript\",\"insertCSS\",\"insertText\",\"removeInsertedCSS\",\"send\",\"sendInputEvent\",\"setLayoutZoomLevelLimits\",\"setVisualZoomLevelLimits\",\"print\",\"printToPDF\"])},\"./lib/common/webpack-globals-provider.ts\":\n/*!************************************************!*\\\n  !*** ./lib/common/webpack-globals-provider.ts ***!\n  \\************************************************/\n/*! no static exports found */function(e,t,n){\"use strict\";(function(e){Object.defineProperty(t,\"__esModule\",{value:!0}),t.Promise=void 0,t.Promise=e.Promise}).call(this,n(/*! @electron/internal/common/webpack-provider */\"./lib/common/webpack-provider.ts\")._global)},\"./lib/common/webpack-provider.ts\":\n/*!****************************************!*\\\n  !*** ./lib/common/webpack-provider.ts ***!\n  \\****************************************/\n/*! no static exports found */function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.Buffer=t.process=t._global=void 0;const r=\"undefined\"!=typeof globalThis?globalThis.global:(self||window).global;t._global=r;const o=r.process;t.process=o;const i=r.Buffer;t.Buffer=i},\"./lib/renderer/api/context-bridge.ts\":\n/*!********************************************!*\\\n  !*** ./lib/renderer/api/context-bridge.ts ***!\n  \\********************************************/\n/*! no static exports found */function(e,t,n){\"use strict\";(function(e){Object.defineProperty(t,\"__esModule\",{value:!0}),t.internalContextBridge=void 0;const{getWebPreference:n}=e._linkedBinding(\"electron_renderer_web_frame\"),r=e._linkedBinding(\"electron_renderer_context_bridge\"),o=n(window,\"contextIsolation\"),i={exposeInMainWorld:(e,t)=>((()=>{if(!o)throw new Error(\"contextBridge API can only be used when contextIsolation is enabled\")})(),r.exposeAPIInMainWorld(e,t))};t.default=i,t.internalContextBridge={contextIsolationEnabled:o,overrideGlobalValueFromIsolatedWorld:(e,t)=>r._overrideGlobalValueFromIsolatedWorld(e,t,!1),overrideGlobalValueWithDynamicPropsFromIsolatedWorld:(e,t)=>r._overrideGlobalValueFromIsolatedWorld(e,t,!0),overrideGlobalPropertyFromIsolatedWorld:(e,t,n)=>r._overrideGlobalPropertyFromIsolatedWorld(e,t,n||null),isInMainWorld:()=>r._isCalledFromMainWorld()},r._isDebug&&(i.internalContextBridge=t.internalContextBridge)}).call(this,n(/*! @electron/internal/common/webpack-provider */\"./lib/common/webpack-provider.ts\").process)},\"./lib/renderer/api/crash-reporter.ts\":\n/*!********************************************!*\\\n  !*** ./lib/renderer/api/crash-reporter.ts ***!\n  \\********************************************/\n/*! no static exports found */function(e,t,n){\"use strict\";(function(e){Object.defineProperty(t,\"__esModule\",{value:!0});const n=e._linkedBinding(\"electron_renderer_crash_reporter\");t.default={addExtraParameter(e,t){n.addExtraParameter(e,t)},removeExtraParameter(e){n.removeExtraParameter(e)},getParameters:()=>n.getParameters()}}).call(this,n(/*! @electron/internal/common/webpack-provider */\"./lib/common/webpack-provider.ts\").process)},\"./lib/renderer/api/desktop-capturer.ts\":\n/*!**********************************************!*\\\n  !*** ./lib/renderer/api/desktop-capturer.ts ***!\n  \\**********************************************/\n/*! no static exports found */function(e,t,n){\"use strict\";(function(e){Object.defineProperty(t,\"__esModule\",{value:!0}),t.getSources=void 0;const r=n(/*! @electron/internal/renderer/ipc-renderer-internal */\"./lib/renderer/ipc-renderer-internal.ts\"),o=n(/*! @electron/internal/common/type-utils */\"./lib/common/type-utils.ts\"),{hasSwitch:i}=e._linkedBinding(\"electron_common_command_line\"),s=i(\"enable-api-filtering-logging\");function getCurrentStack(){const e={};return s&&Error.captureStackTrace(e,getCurrentStack),e.stack}t.getSources=async function getSources(e){return o.deserialize(await r.ipcRendererInternal.invoke(\"DESKTOP_CAPTURER_GET_SOURCES\",e,getCurrentStack()))}}).call(this,n(/*! @electron/internal/common/webpack-provider */\"./lib/common/webpack-provider.ts\").process)},\"./lib/renderer/api/exports/electron.ts\":\n/*!**********************************************!*\\\n  !*** ./lib/renderer/api/exports/electron.ts ***!\n  \\**********************************************/\n/*! no static exports found */function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(/*! @electron/internal/common/define-properties */\"./lib/common/define-properties.ts\"),o=n(/*! @electron/internal/common/api/module-list */\"./lib/common/api/module-list.ts\"),i=n(/*! @electron/internal/renderer/api/module-list */\"./lib/renderer/api/module-list.ts\");e.exports={},r.defineProperties(e.exports,o.commonModuleList),r.defineProperties(e.exports,i.rendererModuleList)},\"./lib/renderer/api/ipc-renderer.ts\":\n/*!******************************************!*\\\n  !*** ./lib/renderer/api/ipc-renderer.ts ***!\n  \\******************************************/\n/*! no static exports found */function(e,t,n){\"use strict\";(function(e){Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(/*! events */\"events\"),{ipc:o}=e._linkedBinding(\"electron_renderer_ipc\"),i=new r.EventEmitter;i.send=function(e,...t){return o.send(!1,e,t)},i.sendSync=function(e,...t){return o.sendSync(!1,e,t)},i.sendToHost=function(e,...t){return o.sendToHost(e,t)},i.sendTo=function(e,t,...n){return o.sendTo(!1,e,t,n)},i.invoke=async function(e,...t){const{error:n,result:r}=await o.invoke(!1,e,t);if(n)throw new Error(`Error invoking remote method '${e}': ${n}`);return r},i.postMessage=function(e,t,n){return o.postMessage(e,t,n)},t.default=i}).call(this,n(/*! @electron/internal/common/webpack-provider */\"./lib/common/webpack-provider.ts\").process)},\"./lib/renderer/api/module-list.ts\":\n/*!*****************************************!*\\\n  !*** ./lib/renderer/api/module-list.ts ***!\n  \\*****************************************/\n/*! no static exports found */function(e,t,n){\"use strict\";(function(e){Object.defineProperty(t,\"__esModule\",{value:!0}),t.rendererModuleList=void 0;const{getWebPreference:r}=e._linkedBinding(\"electron_renderer_web_frame\"),o=r(window,\"enableRemoteModule\");t.rendererModuleList=[{name:\"contextBridge\",loader:()=>n(/*! ./context-bridge */\"./lib/renderer/api/context-bridge.ts\")},{name:\"crashReporter\",loader:()=>n(/*! ./crash-reporter */\"./lib/renderer/api/crash-reporter.ts\")},{name:\"ipcRenderer\",loader:()=>n(/*! ./ipc-renderer */\"./lib/renderer/api/ipc-renderer.ts\")},{name:\"nativeImage\",loader:()=>n(/*! ./native-image */\"./lib/renderer/api/native-image.ts\")},{name:\"webFrame\",loader:()=>n(/*! ./web-frame */\"./lib/renderer/api/web-frame.ts\")}],t.rendererModuleList.push({name:\"desktopCapturer\",loader:()=>n(/*! @electron/internal/renderer/api/desktop-capturer */\"./lib/renderer/api/desktop-capturer.ts\")}),o&&t.rendererModuleList.push({name:\"remote\",loader:()=>n(/*! @electron/internal/renderer/api/remote */\"./lib/renderer/api/remote.ts\")})}).call(this,n(/*! @electron/internal/common/webpack-provider */\"./lib/common/webpack-provider.ts\").process)},\"./lib/renderer/api/native-image.ts\":\n/*!******************************************!*\\\n  !*** ./lib/renderer/api/native-image.ts ***!\n  \\******************************************/\n/*! no static exports found */function(e,t,n){\"use strict\";(function(e){Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(/*! @electron/internal/renderer/ipc-renderer-internal */\"./lib/renderer/ipc-renderer-internal.ts\"),o=n(/*! @electron/internal/common/type-utils */\"./lib/common/type-utils.ts\"),{nativeImage:i}=e._linkedBinding(\"electron_common_native_image\");i.createThumbnailFromPath=async(e,t)=>o.deserialize(await r.ipcRendererInternal.invoke(\"NATIVE_IMAGE_CREATE_THUMBNAIL_FROM_PATH\",e,t)),t.default=i}).call(this,n(/*! @electron/internal/common/webpack-provider */\"./lib/common/webpack-provider.ts\").process)},\"./lib/renderer/api/remote.ts\":\n/*!************************************!*\\\n  !*** ./lib/renderer/api/remote.ts ***!\n  \\************************************/\n/*! no static exports found */function(e,t,n){\"use strict\";(function(e,r,o,i){Object.defineProperty(t,\"__esModule\",{value:!0}),t.createFunctionWithReturnValue=t.getGlobal=t.getCurrentWebContents=t.getCurrentWindow=t.getBuiltin=void 0;const s=n(/*! ../remote/callbacks-registry */\"./lib/renderer/remote/callbacks-registry.ts\"),a=n(/*! ../../common/type-utils */\"./lib/common/type-utils.ts\"),c=n(/*! ../ipc-renderer-internal */\"./lib/renderer/ipc-renderer-internal.ts\"),l=n(/*! @electron/internal/common/api/deprecate */\"./lib/common/api/deprecate.ts\"),u=n(/*! @electron/internal/browser/api/module-names */\"./lib/browser/api/module-names.ts\"),d=n(/*! @electron/internal/common/api/module-list */\"./lib/common/api/module-list.ts\");l.default.log(\"The remote module is deprecated. Use https://github.com/electron/remote instead.\");const p=e._linkedBinding(\"electron_common_v8_util\"),{hasSwitch:b}=e._linkedBinding(\"electron_common_command_line\"),m=new s.CallbacksRegistry,h=new Map,w=new FinalizationRegistry(e=>{const t=h.get(e);void 0!==t&&void 0===t.deref()&&(h.delete(e),c.ipcRendererInternal.send(\"REMOTE_BROWSER_DEREFERENCE\",g,e,0))}),f=new WeakMap,_=new WeakSet;const g=p.getHiddenValue(r,\"contextId\");e.on(\"exit\",()=>{c.ipcRendererInternal.send(\"REMOTE_BROWSER_CONTEXT_RELEASE\",g)});const v=Symbol(\"is-remote-proxy\");function wrapArgs(e,t=new Set){const valueToMeta=e=>{if(t.has(e))return{type:\"value\",value:null};if(e&&e.constructor&&\"NativeImage\"===e.constructor.name)return{type:\"nativeimage\",value:a.serialize(e)};if(Array.isArray(e)){t.add(e);const n={type:\"array\",value:wrapArgs(e,t)};return t.delete(e),n}if(e instanceof o)return{type:\"buffer\",value:e};if(a.isSerializableObject(e))return{type:\"value\",value:e};if(\"object\"==typeof e){if(a.isPromise(e))return{type:\"promise\",then:valueToMeta((function(t,n){e.then(t,n)}))};if(f.has(e))return{type:\"remote-object\",id:f.get(e)};const n={type:\"object\",name:e.constructor?e.constructor.name:\"\",members:[]};t.add(e);for(const t in e)n.members.push({name:t,value:valueToMeta(e[t])});return t.delete(e),n}return\"function\"==typeof e&&_.has(e)?{type:\"function-with-return-value\",value:valueToMeta(e())}:\"function\"==typeof e?{type:\"function\",id:m.add(e),location:m.getLocation(e),length:e.length}:{type:\"value\",value:e}};return e.map(valueToMeta)}function setObjectMembers(e,t,n,r){if(Array.isArray(r))for(const o of r){if(Object.prototype.hasOwnProperty.call(t,o.name))continue;const r={enumerable:o.enumerable};if(\"method\"===o.type){const remoteMemberFunction=function(...e){let t;return t=this&&this.constructor===remoteMemberFunction?\"REMOTE_BROWSER_MEMBER_CONSTRUCTOR\":\"REMOTE_BROWSER_MEMBER_CALL\",metaToValue(c.ipcRendererInternal.sendSync(t,g,n,o.name,wrapArgs(e)))};let t=proxyFunctionProperties(remoteMemberFunction,n,o.name);r.get=()=>(t.ref=e,t),r.set=e=>(t=e,e),r.configurable=!0}else\"get\"===o.type&&(r.get=()=>metaToValue(c.ipcRendererInternal.sendSync(\"REMOTE_BROWSER_MEMBER_GET\",g,n,o.name)),o.writable&&(r.set=e=>{const t=wrapArgs([e]),r=c.ipcRendererInternal.sendSync(\"REMOTE_BROWSER_MEMBER_SET\",g,n,o.name,t);return null!=r&&metaToValue(r),e}));Object.defineProperty(t,o.name,r)}}function proxyFunctionProperties(e,t,n){let r=!1;const loadRemoteProperties=()=>{if(r)return;r=!0;const o=c.ipcRendererInternal.sendSync(\"REMOTE_BROWSER_MEMBER_GET\",g,t,n);setObjectMembers(e,e,o.id,o.members)};return new Proxy(e,{set:(e,t,n)=>(\"ref\"!==t&&loadRemoteProperties(),e[t]=n,!0),get:(e,t)=>{if(t===v)return!0;Object.prototype.hasOwnProperty.call(e,t)||loadRemoteProperties();const n=e[t];return\"toString\"===t&&\"function\"==typeof n?n.bind(e):n},ownKeys:e=>(loadRemoteProperties(),Object.getOwnPropertyNames(e)),getOwnPropertyDescriptor:(e,t)=>{const n=Object.getOwnPropertyDescriptor(e,t);return n||(loadRemoteProperties(),Object.getOwnPropertyDescriptor(e,t))}})}function metaToValue(e){if(\"value\"===e.type)return e.value;if(\"array\"===e.type)return e.members.map(e=>metaToValue(e));if(\"nativeimage\"===e.type)return a.deserialize(e.value);if(\"buffer\"===e.type)return o.from(e.value.buffer,e.value.byteOffset,e.value.byteLength);if(\"promise\"===e.type)return i.resolve({then:metaToValue(e.then)});if(\"error\"===e.type)return metaToError(e);if(\"exception\"===e.type)throw\"error\"===e.value.type?metaToError(e.value):new Error(`Unexpected value type in exception: ${e.value.type}`);{let t;if(\"id\"in e){const t=function getCachedRemoteObject(e){const t=h.get(e);if(void 0!==t){const e=t.deref();if(void 0!==e)return e}}(e.id);if(void 0!==t)return t}if(\"function\"===e.type){const remoteFunction=function(...t){let n;return n=this&&this.constructor===remoteFunction?\"REMOTE_BROWSER_CONSTRUCTOR\":\"REMOTE_BROWSER_FUNCTION_CALL\",metaToValue(c.ipcRendererInternal.sendSync(n,g,e.id,wrapArgs(t)))};t=remoteFunction}else t={};return setObjectMembers(t,t,e.id,e.members),function setObjectPrototype(e,t,n,r){if(null===r)return;const o={};setObjectMembers(e,o,n,r.members),setObjectPrototype(e,o,n,r.proto),Object.setPrototypeOf(t,o)}(t,t,e.id,e.proto),t.constructor&&t.constructor[v]&&Object.defineProperty(t.constructor,\"name\",{value:e.name}),f.set(t,e.id),function setCachedRemoteObject(e,t){const n=new WeakRef(t);return h.set(e,n),w.register(t,e),t}(e.id,t),t}}function metaToError(e){const t=e.value;for(const{name:n,value:r}of e.members)t[n]=metaToValue(r);return t}function handleMessage(e,t){c.ipcRendererInternal.on(e,(e,n,r,...o)=>{n===g?t(r,...o):c.ipcRendererInternal.send(\"REMOTE_BROWSER_WRONG_CONTEXT_ERROR\",g,n,r)})}const E=b(\"enable-api-filtering-logging\");function getCurrentStack(){const e={stack:void 0};return E&&Error.captureStackTrace(e,getCurrentStack),e.stack}handleMessage(\"REMOTE_RENDERER_CALLBACK\",(e,t)=>{m.apply(e,metaToValue(t))}),handleMessage(\"REMOTE_RENDERER_RELEASE_CALLBACK\",e=>{m.remove(e)}),t.require=e=>metaToValue(c.ipcRendererInternal.sendSync(\"REMOTE_BROWSER_REQUIRE\",g,e,getCurrentStack())),t.getBuiltin=function getBuiltin(e){return metaToValue(c.ipcRendererInternal.sendSync(\"REMOTE_BROWSER_GET_BUILTIN\",g,e,getCurrentStack()))},t.getCurrentWindow=function getCurrentWindow(){return metaToValue(c.ipcRendererInternal.sendSync(\"REMOTE_BROWSER_GET_CURRENT_WINDOW\",g,getCurrentStack()))},t.getCurrentWebContents=function getCurrentWebContents(){return metaToValue(c.ipcRendererInternal.sendSync(\"REMOTE_BROWSER_GET_CURRENT_WEB_CONTENTS\",g,getCurrentStack()))},t.getGlobal=function getGlobal(e){return metaToValue(c.ipcRendererInternal.sendSync(\"REMOTE_BROWSER_GET_GLOBAL\",g,e,getCurrentStack()))},Object.defineProperty(t,\"process\",{get:()=>t.getGlobal(\"process\")}),t.createFunctionWithReturnValue=function createFunctionWithReturnValue(e){const func=()=>e;return _.add(func),func};d.commonModuleList.concat(u.browserModuleNames.map(e=>({name:e,loader:()=>{}}))).filter(e=>!e.private).map(e=>e.name).forEach(e=>{Object.defineProperty(t,e,{get:()=>t.getBuiltin(e)})})}).call(this,n(/*! @electron/internal/common/webpack-provider */\"./lib/common/webpack-provider.ts\").process,n(/*! @electron/internal/common/webpack-provider */\"./lib/common/webpack-provider.ts\")._global,n(/*! @electron/internal/common/webpack-provider */\"./lib/common/webpack-provider.ts\").Buffer,n(/*! @electron/internal/common/webpack-globals-provider */\"./lib/common/webpack-globals-provider.ts\").Promise)},\"./lib/renderer/api/web-frame.ts\":\n/*!***************************************!*\\\n  !*** ./lib/renderer/api/web-frame.ts ***!\n  \\***************************************/\n/*! no static exports found */function(e,t,n){\"use strict\";(function(e){Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(/*! events */\"events\"),o=n(/*! @electron/internal/common/api/deprecate */\"./lib/common/api/deprecate.ts\"),i=e._linkedBinding(\"electron_renderer_web_frame\");class WebFrame extends r.EventEmitter{constructor(e){super(),this.context=e,this.setMaxListeners(0)}findFrameByRoutingId(...e){return getWebFrame(i._findFrameByRoutingId(this.context,...e))}getFrameForSelector(...e){return getWebFrame(i._getFrameForSelector(this.context,...e))}findFrameByName(...e){return getWebFrame(i._findFrameByName(this.context,...e))}get opener(){return getWebFrame(i._getOpener(this.context))}get parent(){return getWebFrame(i._getParent(this.context))}get top(){return getWebFrame(i._getTop(this.context))}get firstChild(){return getWebFrame(i._getFirstChild(this.context))}get nextSibling(){return getWebFrame(i._getNextSibling(this.context))}get routingId(){return i._getRoutingId(this.context)}}const s=i.getWebPreference(window,\"contextIsolation\"),a=i.getWebPreference(window,\"worldSafeExecuteJavaScript\")||!s;for(const e in i)e.startsWith(\"_\")||(WebFrame.prototype[e]=function(...t){return!a&&e.startsWith(\"executeJavaScript\")&&o.default.log(`Security Warning: webFrame.${e} was called without worldSafeExecuteJavaScript enabled. This is considered unsafe. worldSafeExecuteJavaScript will be enabled by default in Electron 12.`),i[e](this.context,...t)},e.startsWith(\"executeJavaScript\")&&(WebFrame.prototype[`_${e}`]=function(...t){return i[e](this.context,...t)}));function getWebFrame(e){return e?new WebFrame(e):null}const c=new WebFrame(window);t.default=c}).call(this,n(/*! @electron/internal/common/webpack-provider */\"./lib/common/webpack-provider.ts\").process)},\"./lib/renderer/init.ts\":\n/*!******************************!*\\\n  !*** ./lib/renderer/init.ts ***!\n  \\******************************/\n/*! no static exports found */function(e,t,n){\"use strict\";(function(e,r){Object.defineProperty(t,\"__esModule\",{value:!0});const o=n(/*! path */\"path\"),i=n(/*! module */\"module\");i.wrapper=[\"(function (exports, require, module, __filename, __dirname, process, global, Buffer) { return function (exports, require, module, __filename, __dirname) { \",\"\\n}.call(this, exports, require, module, __filename, __dirname); });\"],e.argv.splice(1,1),n(/*! ../common/reset-search-paths */\"./lib/common/reset-search-paths.ts\"),n(/*! @electron/internal/common/init */\"./lib/common/init.ts\");const s=e._linkedBinding(\"electron_common_v8_util\"),a=s.getHiddenValue(r,\"contextId\");Object.defineProperty(e,\"contextId\",{enumerable:!0,value:a});const{ipcRendererInternal:c}=n(/*! @electron/internal/renderer/ipc-renderer-internal */\"./lib/renderer/ipc-renderer-internal.ts\"),l=n(/*! @electron/internal/renderer/api/ipc-renderer */\"./lib/renderer/api/ipc-renderer.ts\").default;s.setHiddenValue(r,\"ipcNative\",{onMessage(e,t,n,r,o){if(e&&0!==o)return void console.error(`Message ${t} sent by unexpected WebContents (${o})`);const i=e?c:l;i.emit(t,{sender:i,senderId:o,ports:n},...r)}});const{webFrameInit:u}=n(/*! @electron/internal/renderer/web-frame-init */\"./lib/renderer/web-frame-init.ts\");u();const{hasSwitch:d,getSwitchValue:p}=e._linkedBinding(\"electron_common_command_line\"),{getWebPreference:b}=e._linkedBinding(\"electron_renderer_web_frame\"),m=b(window,\"contextIsolation\"),h=b(window,\"nodeIntegration\"),w=b(window,\"webviewTag\"),f=b(window,\"hiddenPage\"),_=b(window,\"nativeWindowOpen\"),g=b(window,\"disableElectronSiteInstanceOverrides\"),v=b(window,\"preload\"),E=b(window,\"preloadScripts\"),y=b(window,\"guestInstanceId\")||null,I=b(window,\"openerId\")||null,R=d(\"app-path\")?p(\"app-path\"):null;switch(v&&E.push(v),window.location.protocol){case\"devtools:\":n(/*! @electron/internal/renderer/inspector */\"./lib/renderer/inspector.ts\");break;case\"chrome-extension:\":case\"chrome:\":break;default:{const{windowSetup:e}=n(/*! @electron/internal/renderer/window-setup */\"./lib/renderer/window-setup.ts\");e(y,I,f,_,g)}}if(e.isMainFrame){const{webViewInit:e}=n(/*! @electron/internal/renderer/web-view/web-view-init */\"./lib/renderer/web-view/web-view-init.ts\");e(m,w,y)}if(h){const{makeRequireFunction:t}=require(\"internal/modules/cjs/helpers\");if(r.module=new i(\"electron/js2c/renderer_init\"),r.require=t(r.module),\"file:\"===window.location.protocol){const t=window.location;let n=t.pathname;if(\"win32\"===e.platform){\"/\"===n[0]&&(n=n.substr(1)),t.hostname.length>0&&e.resourcesPath.startsWith(\"\\\\\")&&(n=`//${t.host}/${n}`)}r.__filename=o.normalize(decodeURIComponent(n)),r.__dirname=o.dirname(r.__filename),r.module.filename=r.__filename,r.module.paths=i._nodeModulePaths(r.__dirname)}else r.__filename=o.join(e.resourcesPath,\"electron.asar\",\"renderer\",\"init.js\"),r.__dirname=o.join(e.resourcesPath,\"electron.asar\",\"renderer\"),R&&(r.module.paths=i._nodeModulePaths(R));window.onerror=function(e,t,n,o,i){return r.process.listenerCount(\"uncaughtException\")>0&&(r.process.emit(\"uncaughtException\",i),!0)}}else m||e.once(\"loaded\",(function(){delete r.process,delete r.Buffer,delete r.setImmediate,delete r.clearImmediate,delete r.global,delete r.root,delete r.GLOBAL}));for(const e of E)try{i._load(e)}catch(t){console.error(`Unable to load preload script: ${e}`),console.error(t),c.send(\"BROWSER_PRELOAD_ERROR\",e,t)}if(e.isMainFrame){const{securityWarnings:e}=n(/*! @electron/internal/renderer/security-warnings */\"./lib/renderer/security-warnings.ts\");e(h)}}).call(this,n(/*! @electron/internal/common/webpack-provider */\"./lib/common/webpack-provider.ts\").process,n(/*! @electron/internal/common/webpack-provider */\"./lib/common/webpack-provider.ts\")._global)},\"./lib/renderer/inspector.ts\":\n/*!***********************************!*\\\n  !*** ./lib/renderer/inspector.ts ***!\n  \\***********************************/\n/*! no static exports found */function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(/*! @electron/internal/renderer/api/context-bridge */\"./lib/renderer/api/context-bridge.ts\"),o=n(/*! @electron/internal/renderer/ipc-renderer-internal */\"./lib/renderer/ipc-renderer-internal.ts\"),i=n(/*! @electron/internal/renderer/ipc-renderer-internal-utils */\"./lib/renderer/ipc-renderer-internal-utils.ts\"),s=n(/*! electron/renderer */\"./lib/renderer/api/exports/electron.ts\"),{contextIsolationEnabled:a}=r.internalContextBridge;function completeURL(e,t){return\"file:///\",`file:///${t}`}window.onload=function(){a?(r.internalContextBridge.overrideGlobalValueFromIsolatedWorld([\"InspectorFrontendHost\",\"showContextMenuAtPoint\"],createMenu),r.internalContextBridge.overrideGlobalValueFromIsolatedWorld([\"Persistence\",\"FileSystemWorkspaceBinding\",\"completeURL\"],completeURL),r.internalContextBridge.overrideGlobalValueFromIsolatedWorld([\"UI\",\"createFileSelectorElement\"],createFileSelectorElement)):(window.InspectorFrontendHost.showContextMenuAtPoint=createMenu,window.Persistence.FileSystemWorkspaceBinding.completeURL=completeURL,window.UI.createFileSelectorElement=createFileSelectorElement)},window.confirm=function(e,t){return i.invokeSync(\"INSPECTOR_CONFIRM\",e,t)};const createMenu=function(e,t,n){const r=function(e,t,n){return 0===n.length&&document.elementsFromPoint(e,t).some((function(e){return\"INPUT\"===e.nodeName||\"TEXTAREA\"===e.nodeName||e.isContentEditable}))}(e,t,n);o.ipcRendererInternal.invoke(\"INSPECTOR_CONTEXT_MENU\",n,r).then(e=>{\"number\"==typeof e&&s.webFrame.executeJavaScript(`window.DevToolsAPI.contextMenuItemSelected(${JSON.stringify(e)})`),s.webFrame.executeJavaScript(\"window.DevToolsAPI.contextMenuCleared()\")})},showFileChooserDialog=function(e){o.ipcRendererInternal.invoke(\"INSPECTOR_SELECT_FILE\").then(([t,n])=>{t&&n&&e(dataToHtml5FileObject(t,n))})},dataToHtml5FileObject=function(e,t){return new File([t],e)},createFileSelectorElement=function(e){const t=document.createElement(\"span\");return t.style.display=\"none\",t.click=showFileChooserDialog.bind(this,e),t}},\"./lib/renderer/ipc-renderer-internal-utils.ts\":\n/*!*****************************************************!*\\\n  !*** ./lib/renderer/ipc-renderer-internal-utils.ts ***!\n  \\*****************************************************/\n/*! no static exports found */function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.invokeSync=t.handle=void 0;const r=n(/*! @electron/internal/renderer/ipc-renderer-internal */\"./lib/renderer/ipc-renderer-internal.ts\");t.handle=function(e,t){r.ipcRendererInternal.on(e,async(n,r,...o)=>{const i=`${e}_RESPONSE_${r}`;try{n.sender.send(i,null,await t(n,...o))}catch(e){n.sender.send(i,e)}})},t.invokeSync=function invokeSync(e,...t){const[n,o]=r.ipcRendererInternal.sendSync(e,...t);if(n)throw n;return o}},\"./lib/renderer/ipc-renderer-internal.ts\":\n/*!***********************************************!*\\\n  !*** ./lib/renderer/ipc-renderer-internal.ts ***!\n  \\***********************************************/\n/*! no static exports found */function(e,t,n){\"use strict\";(function(e){Object.defineProperty(t,\"__esModule\",{value:!0}),t.ipcRendererInternal=void 0;const r=n(/*! events */\"events\"),{ipc:o}=e._linkedBinding(\"electron_renderer_ipc\"),i=new r.EventEmitter;t.ipcRendererInternal=i,i.send=function(e,...t){return o.send(!0,e,t)},i.sendSync=function(e,...t){return o.sendSync(!0,e,t)},i.sendTo=function(e,t,...n){return o.sendTo(!0,e,t,n)},i.invoke=async function(e,...t){const{error:n,result:r}=await o.invoke(!0,e,t);if(n)throw new Error(`Error invoking remote method '${e}': ${n}`);return r}}).call(this,n(/*! @electron/internal/common/webpack-provider */\"./lib/common/webpack-provider.ts\").process)},\"./lib/renderer/remote/callbacks-registry.ts\":\n/*!***************************************************!*\\\n  !*** ./lib/renderer/remote/callbacks-registry.ts ***!\n  \\***************************************************/\n/*! no static exports found */function(e,t,n){\"use strict\";(function(e){Object.defineProperty(t,\"__esModule\",{value:!0}),t.CallbacksRegistry=void 0;t.CallbacksRegistry=class CallbacksRegistry{constructor(){this.nextId=0,this.callbacks=new Map,this.callbackIds=new WeakMap,this.locationInfo=new WeakMap}add(e){let t=this.callbackIds.get(e);if(null!=t)return t;t=this.nextId+=1;const n=/at (.*)/gi,r=(new Error).stack;if(!r)return;let o,i;for(;null!==(i=n.exec(r));){const e=i[1];if(e.includes(\"(native)\"))continue;if(e.includes(\"(<anonymous>)\"))continue;if(e.includes(\"electron/js2c\"))continue;const t=/([^/^)]*)\\)?$/gi.exec(e);t&&(o=t[1]);break}return this.callbacks.set(t,e),this.callbackIds.set(e,t),this.locationInfo.set(e,o),t}get(e){return this.callbacks.get(e)||function(){}}getLocation(e){return this.locationInfo.get(e)}apply(t,...n){return this.get(t).apply(e,...n)}remove(e){const t=this.callbacks.get(e);t&&(this.callbackIds.delete(t),this.callbacks.delete(e))}}}).call(this,n(/*! @electron/internal/common/webpack-provider */\"./lib/common/webpack-provider.ts\")._global)},\"./lib/renderer/security-warnings.ts\":\n/*!*******************************************!*\\\n  !*** ./lib/renderer/security-warnings.ts ***!\n  \\*******************************************/\n/*! no static exports found */function(module,exports,__webpack_require__){\"use strict\";(function(process){Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.securityWarnings=void 0;const electron_1=__webpack_require__(/*! electron */\"./lib/renderer/api/exports/electron.ts\"),ipc_renderer_internal_1=__webpack_require__(/*! @electron/internal/renderer/ipc-renderer-internal */\"./lib/renderer/ipc-renderer-internal.ts\");let shouldLog=null;const{platform:platform,execPath:execPath,env:env}=process,shouldLogSecurityWarnings=function(){if(null!==shouldLog)return shouldLog;switch(platform){case\"darwin\":shouldLog=execPath.endsWith(\"MacOS/Electron\")||execPath.includes(\"Electron.app/Contents/Frameworks/\");break;case\"freebsd\":case\"linux\":shouldLog=execPath.endsWith(\"/electron\");break;case\"win32\":shouldLog=execPath.endsWith(\"\\\\electron.exe\");break;default:shouldLog=!1}return(env&&env.ELECTRON_DISABLE_SECURITY_WARNINGS||window&&window.ELECTRON_DISABLE_SECURITY_WARNINGS)&&(shouldLog=!1),(env&&env.ELECTRON_ENABLE_SECURITY_WARNINGS||window&&window.ELECTRON_ENABLE_SECURITY_WARNINGS)&&(shouldLog=!0),shouldLog},getIsRemoteProtocol=function(){if(window&&window.location&&window.location.protocol)return/^(http|ftp)s?/gi.test(window.location.protocol)},isLocalhost=function(){return!(!window||!window.location)&&\"localhost\"===window.location.hostname},isUnsafeEvalEnabled=function(){return electron_1.webFrame._executeJavaScript(`(${(()=>{try{eval(window.trustedTypes.emptyScript)}catch{return!1}return!0}).toString()})()`,!1)},moreInformation=\"\\nFor more information and help, consult\\nhttps://electronjs.org/docs/tutorial/security.\\nThis warning will not show up\\nonce the app is packaged.\",warnAboutInsecureResources=function(){if(!window||!window.performance||!window.performance.getEntriesByType)return;const e=window.performance.getEntriesByType(\"resource\").filter(({name:e})=>/^(http|ftp):/gi.test(e||\"\")).filter(({name:e})=>\"localhost\"!==new URL(e).hostname).map(({name:e})=>`- ${e}`).join(\"\\n\");if(!e||0===e.length)return;const t=`This renderer process loads resources using insecure\\n  protocols. This exposes users of this app to unnecessary security risks.\\n  Consider loading the following resources over HTTPS or FTPS. \\n${e}\\n  \\n${moreInformation}`;console.warn(\"%cElectron Security Warning (Insecure Resources)\",\"font-weight: bold;\",t)},warnAboutNodeWithRemoteContent=function(e){if(e&&!isLocalhost()&&getIsRemoteProtocol()){const e=`This renderer process has Node.js integration enabled\\n    and attempted to load remote content from '${window.location}'. This\\n    exposes users of this app to severe security risks.\\n${moreInformation}`;console.warn(\"%cElectron Security Warning (Node.js Integration with Remote Content)\",\"font-weight: bold;\",e)}},warnAboutDisabledWebSecurity=function(e){if(!e||!1!==e.webSecurity)return;const t=`This renderer process has \"webSecurity\" disabled. This\\n  exposes users of this app to severe security risks.\\n${moreInformation}`;console.warn(\"%cElectron Security Warning (Disabled webSecurity)\",\"font-weight: bold;\",t)},warnAboutInsecureCSP=function(){isUnsafeEvalEnabled().then(e=>{if(!e)return;const t=`This renderer process has either no Content Security\\n    Policy set or a policy with \"unsafe-eval\" enabled. This exposes users of\\n    this app to unnecessary security risks.\\n${moreInformation}`;console.warn(\"%cElectron Security Warning (Insecure Content-Security-Policy)\",\"font-weight: bold;\",t)}).catch(()=>{})},warnAboutInsecureContentAllowed=function(e){if(!e||!e.allowRunningInsecureContent)return;const t=`This renderer process has \"allowRunningInsecureContent\"\\n  enabled. This exposes users of this app to severe security risks.\\n\\n  ${moreInformation}`;console.warn(\"%cElectron Security Warning (allowRunningInsecureContent)\",\"font-weight: bold;\",t)},warnAboutExperimentalFeatures=function(e){if(!e||!e.experimentalFeatures)return;const t=`This renderer process has \"experimentalFeatures\" enabled.\\n  This exposes users of this app to some security risk. If you do not need\\n  this feature, you should disable it.\\n${moreInformation}`;console.warn(\"%cElectron Security Warning (experimentalFeatures)\",\"font-weight: bold;\",t)},warnAboutEnableBlinkFeatures=function(e){if(!e||!Object.prototype.hasOwnProperty.call(e,\"enableBlinkFeatures\")||null!=e.enableBlinkFeatures&&0===e.enableBlinkFeatures.length)return;const t=`This renderer process has additional \"enableBlinkFeatures\"\\n  enabled. This exposes users of this app to some security risk. If you do not\\n  need this feature, you should disable it.\\n${moreInformation}`;console.warn(\"%cElectron Security Warning (enableBlinkFeatures)\",\"font-weight: bold;\",t)},warnAboutAllowedPopups=function(){if(document&&document.querySelectorAll){const e=document.querySelectorAll(\"[allowpopups]\");if(!e||0===e.length)return;const t=`A <webview> has \"allowpopups\" set to true. This exposes\\n    users of this app to some security risk, since popups are just\\n    BrowserWindows. If you do not need this feature, you should disable it.\\n\\n    ${moreInformation}`;console.warn(\"%cElectron Security Warning (allowpopups)\",\"font-weight: bold;\",t)}},warnAboutRemoteModuleWithRemoteContent=function(e){if(e&&e.enableRemoteModule&&!isLocalhost()&&getIsRemoteProtocol()){const e=`This renderer process has \"enableRemoteModule\" enabled\\n    and attempted to load remote content from '${window.location}'. This\\n    exposes users of this app to unnecessary security risks.\\n${moreInformation}`;console.warn(\"%cElectron Security Warning (enableRemoteModule)\",\"font-weight: bold;\",e)}},logSecurityWarnings=function(e,t){warnAboutNodeWithRemoteContent(t),warnAboutDisabledWebSecurity(e),warnAboutInsecureResources(),warnAboutInsecureContentAllowed(e),warnAboutExperimentalFeatures(e),warnAboutEnableBlinkFeatures(e),warnAboutInsecureCSP(),warnAboutAllowedPopups(),warnAboutRemoteModuleWithRemoteContent(e)},getWebPreferences=async function(){try{return ipc_renderer_internal_1.ipcRendererInternal.invoke(\"BROWSER_GET_LAST_WEB_PREFERENCES\")}catch(e){console.warn(`getLastWebPreferences() failed: ${e}`)}};function securityWarnings(e){window.addEventListener(\"load\",(async function(){if(shouldLogSecurityWarnings()){const t=await getWebPreferences();logSecurityWarnings(t,e)}}),{once:!0})}exports.securityWarnings=securityWarnings}).call(this,__webpack_require__(/*! @electron/internal/common/webpack-provider */\"./lib/common/webpack-provider.ts\").process)},\"./lib/renderer/web-frame-init.ts\":\n/*!****************************************!*\\\n  !*** ./lib/renderer/web-frame-init.ts ***!\n  \\****************************************/\n/*! no static exports found */function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.webFrameInit=void 0;const r=n(/*! electron */\"./lib/renderer/api/exports/electron.ts\"),o=n(/*! @electron/internal/renderer/ipc-renderer-internal-utils */\"./lib/renderer/ipc-renderer-internal-utils.ts\");t.webFrameInit=()=>{o.handle(\"RENDERER_WEB_FRAME_METHOD\",(e,t,...n)=>t.startsWith(\"executeJavaScript\")?r.webFrame[`_${t}`](...n):r.webFrame[t](...n))}},\"./lib/renderer/web-view/guest-view-internal.ts\":\n/*!******************************************************!*\\\n  !*** ./lib/renderer/web-view/guest-view-internal.ts ***!\n  \\******************************************************/\n/*! no static exports found */function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.guestViewInternalModule=t.detachGuest=t.attachGuest=t.createGuest=t.deregisterEvents=t.registerEvents=void 0;const r=n(/*! electron */\"./lib/renderer/api/exports/electron.ts\"),o=n(/*! @electron/internal/renderer/ipc-renderer-internal */\"./lib/renderer/ipc-renderer-internal.ts\"),i=n(/*! @electron/internal/renderer/ipc-renderer-internal-utils */\"./lib/renderer/ipc-renderer-internal-utils.ts\"),s=n(/*! @electron/internal/common/web-view-events */\"./lib/common/web-view-events.ts\"),a={\"page-title-updated\":\"page-title-set\"},dispatchEvent=function(e,t,n,...r){null!=a[t]&&dispatchEvent(e,a[t],n,...r);const o={};s.webViewEvents[n].forEach((e,t)=>{o[e]=r[t]}),e.dispatchEvent(t,o),\"load-commit\"===t?e.onLoadCommit(o):\"focus-change\"===t&&e.onFocusChange()};function deregisterEvents(e){o.ipcRendererInternal.removeAllListeners(`GUEST_VIEW_INTERNAL_DESTROY_GUEST-${e}`),o.ipcRendererInternal.removeAllListeners(`GUEST_VIEW_INTERNAL_DISPATCH_EVENT-${e}`),o.ipcRendererInternal.removeAllListeners(`GUEST_VIEW_INTERNAL_IPC_MESSAGE-${e}`)}function createGuest(e){return o.ipcRendererInternal.invoke(\"GUEST_VIEW_MANAGER_CREATE_GUEST\",e)}function attachGuest(e,t,n,i){const s=r.webFrame.getWebFrameId(i);if(s<0)throw new Error(\"Invalid embedder frame\");o.ipcRendererInternal.invoke(\"GUEST_VIEW_MANAGER_ATTACH_GUEST\",s,e,t,n)}function detachGuest(e){return i.invokeSync(\"GUEST_VIEW_MANAGER_DETACH_GUEST\",e)}t.registerEvents=function registerEvents(e,t){o.ipcRendererInternal.on(`GUEST_VIEW_INTERNAL_DESTROY_GUEST-${t}`,(function(){e.guestInstanceId=void 0,e.reset(),e.dispatchEvent(\"destroyed\")})),o.ipcRendererInternal.on(`GUEST_VIEW_INTERNAL_DISPATCH_EVENT-${t}`,(function(t,n,...r){dispatchEvent(e,n,n,...r)})),o.ipcRendererInternal.on(`GUEST_VIEW_INTERNAL_IPC_MESSAGE-${t}`,(function(t,n,...r){e.dispatchEvent(\"ipc-message\",{channel:n,args:r})}))},t.deregisterEvents=deregisterEvents,t.createGuest=createGuest,t.attachGuest=attachGuest,t.detachGuest=detachGuest,t.guestViewInternalModule={deregisterEvents:deregisterEvents,createGuest:createGuest,attachGuest:attachGuest,detachGuest:detachGuest}},\"./lib/renderer/web-view/web-view-attributes.ts\":\n/*!******************************************************!*\\\n  !*** ./lib/renderer/web-view/web-view-attributes.ts ***!\n  \\******************************************************/\n/*! no static exports found */function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.SrcAttribute=t.PartitionAttribute=t.WebViewAttribute=void 0;const r=n(/*! @electron/internal/renderer/ipc-renderer-internal */\"./lib/renderer/ipc-renderer-internal.ts\"),o=n(/*! @electron/internal/renderer/web-view/web-view-impl */\"./lib/renderer/web-view/web-view-impl.ts\"),i=document.createElement(\"a\"),resolveURL=function(e){return e?(i.href=e,i.href):\"\"};class WebViewAttribute{constructor(e,t){this.name=e,this.webViewImpl=t,this.ignoreMutation=!1,this.handleMutation=()=>{},this.name=e,this.value=t.webviewNode[e]||\"\",this.webViewImpl=t,this.defineProperty()}getValue(){return this.webViewImpl.webviewNode.getAttribute(this.name)||this.value}setValue(e){this.webViewImpl.webviewNode.setAttribute(this.name,e||\"\")}setValueIgnoreMutation(e){this.ignoreMutation=!0,this.setValue(e),this.ignoreMutation=!1}defineProperty(){return Object.defineProperty(this.webViewImpl.webviewNode,this.name,{get:()=>this.getValue(),set:e=>this.setValue(e),enumerable:!0})}}t.WebViewAttribute=WebViewAttribute;class BooleanAttribute extends WebViewAttribute{getValue(){return this.webViewImpl.webviewNode.hasAttribute(this.name)}setValue(e){e?this.webViewImpl.webviewNode.setAttribute(this.name,\"\"):this.webViewImpl.webviewNode.removeAttribute(this.name)}}class PartitionAttribute extends WebViewAttribute{constructor(e){super(\"partition\",e),this.webViewImpl=e,this.validPartitionId=!0,this.handleMutation=(e,t)=>{if(t=t||\"\",!this.webViewImpl.beforeFirstNavigation)return console.error(\"The object has already navigated, so its partition cannot be changed.\"),void this.setValueIgnoreMutation(e);\"persist:\"===t&&(this.validPartitionId=!1,console.error(\"Invalid partition attribute.\"))}}}t.PartitionAttribute=PartitionAttribute;class SrcAttribute extends WebViewAttribute{constructor(e){super(\"src\",e),this.webViewImpl=e,this.handleMutation=(e,t)=>{t||!e?this.parse():this.setValueIgnoreMutation(e)},this.setupMutationObserver()}getValue(){return this.webViewImpl.webviewNode.hasAttribute(this.name)?resolveURL(this.webViewImpl.webviewNode.getAttribute(this.name)):this.value}setValueIgnoreMutation(e){super.setValueIgnoreMutation(e),this.observer.takeRecords()}setupMutationObserver(){this.observer=new MutationObserver(e=>{for(const t of e){const{oldValue:e}=t,n=this.getValue();if(e!==n)return;this.handleMutation(e,n)}});const e={attributes:!0,attributeOldValue:!0,attributeFilter:[this.name]};this.observer.observe(this.webViewImpl.webviewNode,e)}parse(){if(!this.webViewImpl.elementAttached||!this.webViewImpl.attributes.get(\"partition\").validPartitionId||!this.getValue())return;if(null==this.webViewImpl.guestInstanceId)return void(this.webViewImpl.beforeFirstNavigation&&(this.webViewImpl.beforeFirstNavigation=!1,this.webViewImpl.createGuest()));const e={},t=this.webViewImpl.attributes.get(\"httpreferrer\").getValue();t&&(e.httpReferrer=t);const n=this.webViewImpl.attributes.get(\"useragent\").getValue();n&&(e.userAgent=n);const o=this.webViewImpl.guestInstanceId,i=[this.getValue(),e];r.ipcRendererInternal.invoke(\"GUEST_VIEW_MANAGER_CALL\",o,\"loadURL\",i)}}t.SrcAttribute=SrcAttribute;class HttpReferrerAttribute extends WebViewAttribute{constructor(e){super(\"httpreferrer\",e)}}class UserAgentAttribute extends WebViewAttribute{constructor(e){super(\"useragent\",e)}}class PreloadAttribute extends WebViewAttribute{constructor(e){super(\"preload\",e)}getValue(){if(!this.webViewImpl.webviewNode.hasAttribute(this.name))return this.value;let e=resolveURL(this.webViewImpl.webviewNode.getAttribute(this.name));return\"file:\"!==e.substr(0,5)&&(console.error('Only \"file:\" protocol is supported in \"preload\" attribute.'),e=\"\"),e}}class BlinkFeaturesAttribute extends WebViewAttribute{constructor(e){super(\"blinkfeatures\",e)}}class DisableBlinkFeaturesAttribute extends WebViewAttribute{constructor(e){super(\"disableblinkfeatures\",e)}}class WebPreferencesAttribute extends WebViewAttribute{constructor(e){super(\"webpreferences\",e)}}class EnableRemoteModuleAttribute extends WebViewAttribute{constructor(e){super(\"enableremotemodule\",e)}getValue(){return\"false\"!==this.webViewImpl.webviewNode.getAttribute(this.name)}setValue(e){this.webViewImpl.webviewNode.setAttribute(this.name,e?\"true\":\"false\")}}o.WebViewImpl.prototype.setupWebViewAttributes=function(){this.attributes.set(\"partition\",new PartitionAttribute(this)),this.attributes.set(\"src\",new SrcAttribute(this)),this.attributes.set(\"httpreferrer\",new HttpReferrerAttribute(this)),this.attributes.set(\"useragent\",new UserAgentAttribute(this)),this.attributes.set(\"nodeintegration\",new BooleanAttribute(\"nodeintegration\",this)),this.attributes.set(\"nodeintegrationinsubframes\",new BooleanAttribute(\"nodeintegrationinsubframes\",this)),this.attributes.set(\"plugins\",new BooleanAttribute(\"plugins\",this)),this.attributes.set(\"disablewebsecurity\",new BooleanAttribute(\"disablewebsecurity\",this)),this.attributes.set(\"allowpopups\",new BooleanAttribute(\"allowpopups\",this)),this.attributes.set(\"enableremotemodule\",new EnableRemoteModuleAttribute(this)),this.attributes.set(\"preload\",new PreloadAttribute(this)),this.attributes.set(\"blinkfeatures\",new BlinkFeaturesAttribute(this)),this.attributes.set(\"disableblinkfeatures\",new DisableBlinkFeaturesAttribute(this)),this.attributes.set(\"webpreferences\",new WebPreferencesAttribute(this))}},\"./lib/renderer/web-view/web-view-element.ts\":\n/*!***************************************************!*\\\n  !*** ./lib/renderer/web-view/web-view-element.ts ***!\n  \\***************************************************/\n/*! no static exports found */function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.setupWebView=void 0;const defineWebViewElement=(e,t)=>{const{guestViewInternal:n,WebViewImpl:r}=t;return class WebViewElement extends HTMLElement{constructor(){super();const t=new r(this);t.dispatchEventInMainWorld=(e,n)=>{const r=new Event(e);return Object.assign(r,n),t.webviewNode.dispatchEvent(r)},e.setHiddenValue(this,\"internal\",t)}static get observedAttributes(){return[\"partition\",\"src\",\"httpreferrer\",\"useragent\",\"nodeintegration\",\"nodeintegrationinsubframes\",\"plugins\",\"disablewebsecurity\",\"allowpopups\",\"enableremotemodule\",\"preload\",\"blinkfeatures\",\"disableblinkfeatures\",\"webpreferences\"]}connectedCallback(){const t=e.getHiddenValue(this,\"internal\");t&&(t.elementAttached||(n.registerEvents(t,t.viewInstanceId),t.elementAttached=!0,t.attributes.get(\"src\").parse()))}attributeChangedCallback(t,n,r){const o=e.getHiddenValue(this,\"internal\");o&&o.handleWebviewAttributeMutation(t,n,r)}disconnectedCallback(){const t=e.getHiddenValue(this,\"internal\");t&&(n.deregisterEvents(t.viewInstanceId),t.guestInstanceId&&n.detachGuest(t.guestInstanceId),t.elementAttached=!1,this.internalInstanceId=0,t.reset())}}};t.setupWebView=(e,t)=>{const listener=n=>{\"loading\"!==document.readyState&&(t.setupAttributes(),((e,t)=>{const n=defineWebViewElement(e,t);t.setupMethods(n),t.webFrame.allowGuestViewElementDefinition(window,()=>{window.customElements.define(\"webview\",n),window.WebView=n,delete n.prototype.connectedCallback,delete n.prototype.disconnectedCallback,delete n.prototype.attributeChangedCallback,delete n.observedAttributes})})(e,t),window.removeEventListener(n.type,listener,!0))};window.addEventListener(\"readystatechange\",listener,!0)}},\"./lib/renderer/web-view/web-view-impl.ts\":\n/*!************************************************!*\\\n  !*** ./lib/renderer/web-view/web-view-impl.ts ***!\n  \\************************************************/\n/*! no static exports found */function(e,t,n){\"use strict\";(function(e){Object.defineProperty(t,\"__esModule\",{value:!0}),t.webViewImplModule=t.setupMethods=t.setupAttributes=t.WebViewImpl=void 0;const r=n(/*! electron */\"./lib/renderer/api/exports/electron.ts\"),o=n(/*! @electron/internal/renderer/ipc-renderer-internal */\"./lib/renderer/ipc-renderer-internal.ts\"),i=n(/*! @electron/internal/renderer/ipc-renderer-internal-utils */\"./lib/renderer/ipc-renderer-internal-utils.ts\"),s=n(/*! @electron/internal/renderer/web-view/guest-view-internal */\"./lib/renderer/web-view/guest-view-internal.ts\"),a=n(/*! @electron/internal/common/web-view-methods */\"./lib/common/web-view-methods.ts\"),c=n(/*! @electron/internal/common/type-utils */\"./lib/common/type-utils.ts\"),{webFrame:l}=r,u=e._linkedBinding(\"electron_common_v8_util\");let d=0;const getNextId=function(){return++d};class WebViewImpl{constructor(e){this.webviewNode=e,this.beforeFirstNavigation=!0,this.elementAttached=!1,this.hasFocus=!1,this.on={},this.attributes=new Map,this.internalElement=this.createInternalElement();const t=this.webviewNode.attachShadow({mode:\"open\"}),n=t.ownerDocument.createElement(\"style\");n.textContent=\":host { display: flex; }\",t.appendChild(n),this.setupWebViewAttributes(),this.viewInstanceId=getNextId(),t.appendChild(this.internalElement),Object.defineProperty(this.webviewNode,\"contentWindow\",{get:()=>this.internalElement.contentWindow,enumerable:!0})}setupWebViewAttributes(){}createInternalElement(){const e=document.createElement(\"iframe\");return e.style.flex=\"1 1 auto\",e.style.width=\"100%\",e.style.border=\"0\",u.setHiddenValue(e,\"internal\",this),e}reset(){this.guestInstanceId&&(this.guestInstanceId=void 0),this.beforeFirstNavigation=!0,this.attributes.get(\"partition\").validPartitionId=!0;const e=this.createInternalElement(),t=this.internalElement;this.internalElement=e,t&&t.parentNode&&t.parentNode.replaceChild(e,t)}handleWebviewAttributeMutation(e,t,n){this.attributes.has(e)&&!this.attributes.get(e).ignoreMutation&&this.attributes.get(e).handleMutation(t,n)}onElementResize(){const e={newWidth:this.webviewNode.clientWidth,newHeight:this.webviewNode.clientHeight};this.dispatchEvent(\"resize\",e)}createGuest(){s.createGuest(this.buildParams()).then(e=>{this.attachGuestInstance(e)})}dispatchEvent(e,t={}){this.dispatchEventInMainWorld(e,t)}setupEventProperty(e){const t=`on${e.toLowerCase()}`;return Object.defineProperty(this.webviewNode,t,{get:()=>this.on[t],set:n=>{if(this.on[t]&&this.webviewNode.removeEventListener(e,this.on[t]),this.on[t]=n,n)return this.webviewNode.addEventListener(e,n)},enumerable:!0})}onLoadCommit(e){const t=this.webviewNode.getAttribute(\"src\"),n=e.url;e.isMainFrame&&t!==n&&this.attributes.get(\"src\").setValueIgnoreMutation(n)}onFocusChange(){const e=this.webviewNode.ownerDocument.activeElement===this.webviewNode;e!==this.hasFocus&&(this.hasFocus=e,this.dispatchEvent(e?\"focus\":\"blur\"))}onAttach(e){return this.attributes.get(\"partition\").setValue(e)}buildParams(){const e={instanceId:this.viewInstanceId,userAgentOverride:this.userAgentOverride};for(const[t,n]of this.attributes)e[t]=n.getValue();return e}attachGuestInstance(e){this.elementAttached&&(this.internalInstanceId=getNextId(),this.guestInstanceId=e,s.attachGuest(this.internalInstanceId,this.guestInstanceId,this.buildParams(),this.internalElement.contentWindow),this.resizeObserver=new ResizeObserver(this.onElementResize.bind(this)),this.resizeObserver.observe(this.internalElement))}}t.WebViewImpl=WebViewImpl;t.setupAttributes=()=>{n(/*! @electron/internal/renderer/web-view/web-view-attributes */\"./lib/renderer/web-view/web-view-attributes.ts\")};t.setupMethods=e=>{e.prototype.getWebContentsId=function(){const e=u.getHiddenValue(this,\"internal\");if(!e.guestInstanceId)throw new Error(\"The WebView must be attached to the DOM and the dom-ready event emitted before this method can be called.\");return e.guestInstanceId},e.prototype.focus=function(){this.contentWindow.focus()};const createBlockHandler=function(e){return function(...t){return i.invokeSync(\"GUEST_VIEW_MANAGER_CALL\",this.getWebContentsId(),e,t)}};for(const t of a.syncMethods)e.prototype[t]=createBlockHandler(t);const createNonBlockHandler=function(e){return function(...t){return o.ipcRendererInternal.invoke(\"GUEST_VIEW_MANAGER_CALL\",this.getWebContentsId(),e,t)}};for(const t of a.asyncMethods)e.prototype[t]=createNonBlockHandler(t);e.prototype.capturePage=async function(...e){return c.deserialize(await o.ipcRendererInternal.invoke(\"GUEST_VIEW_MANAGER_CAPTURE_PAGE\",this.getWebContentsId(),e))};const createPropertyGetter=function(e){return function(){return i.invokeSync(\"GUEST_VIEW_MANAGER_PROPERTY_GET\",this.getWebContentsId(),e)}},createPropertySetter=function(e){return function(t){return i.invokeSync(\"GUEST_VIEW_MANAGER_PROPERTY_SET\",this.getWebContentsId(),e,t)}};for(const t of a.properties)Object.defineProperty(e.prototype,t,{get:createPropertyGetter(t),set:createPropertySetter(t)})},t.webViewImplModule={setupAttributes:t.setupAttributes,setupMethods:t.setupMethods,guestViewInternal:s,webFrame:l,WebViewImpl:WebViewImpl}}).call(this,n(/*! @electron/internal/common/webpack-provider */\"./lib/common/webpack-provider.ts\").process)},\"./lib/renderer/web-view/web-view-init.ts\":\n/*!************************************************!*\\\n  !*** ./lib/renderer/web-view/web-view-init.ts ***!\n  \\************************************************/\n/*! no static exports found */function(e,t,n){\"use strict\";(function(e){Object.defineProperty(t,\"__esModule\",{value:!0}),t.webViewInit=void 0;const r=n(/*! @electron/internal/renderer/ipc-renderer-internal */\"./lib/renderer/ipc-renderer-internal.ts\"),o=e._linkedBinding(\"electron_common_v8_util\");t.webViewInit=function webViewInit(e,t,i){if(t&&null==i){const{webViewImplModule:t}=n(/*! @electron/internal/renderer/web-view/web-view-impl */\"./lib/renderer/web-view/web-view-impl.ts\");if(e)o.setHiddenValue(window,\"web-view-impl\",t);else{const{setupWebView:e}=n(/*! @electron/internal/renderer/web-view/web-view-element */\"./lib/renderer/web-view/web-view-element.ts\");e(o,t)}}i&&function handleFocusBlur(e){window.addEventListener(\"focus\",()=>{r.ipcRendererInternal.send(\"GUEST_VIEW_MANAGER_FOCUS_CHANGE\",!0,e)}),window.addEventListener(\"blur\",()=>{r.ipcRendererInternal.send(\"GUEST_VIEW_MANAGER_FOCUS_CHANGE\",!1,e)})}(i)}}).call(this,n(/*! @electron/internal/common/webpack-provider */\"./lib/common/webpack-provider.ts\").process)},\"./lib/renderer/window-setup.ts\":\n/*!**************************************!*\\\n  !*** ./lib/renderer/window-setup.ts ***!\n  \\**************************************/\n/*! no static exports found */function(e,t,n){\"use strict\";(function(e){var r=this&&this.__decorate||function(e,t,n,r){var o,i=arguments.length,s=i<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if(\"object\"==typeof Reflect&&\"function\"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,r);else for(var a=e.length-1;a>=0;a--)(o=e[a])&&(s=(i<3?o(s):i>3?o(t,n,s):o(t,n))||s);return i>3&&s&&Object.defineProperty(t,n,s),s};Object.defineProperty(t,\"__esModule\",{value:!0}),t.windowSetup=void 0;const o=n(/*! @electron/internal/renderer/ipc-renderer-internal */\"./lib/renderer/ipc-renderer-internal.ts\"),i=n(/*! @electron/internal/renderer/ipc-renderer-internal-utils */\"./lib/renderer/ipc-renderer-internal-utils.ts\"),s=n(/*! @electron/internal/renderer/api/context-bridge */\"./lib/renderer/api/context-bridge.ts\"),{contextIsolationEnabled:a}=s.internalContextBridge,resolveURL=(e,t)=>new URL(e,t).href,toString=e=>null!=e?`${e}`:e,c=new Map,getOrCreateProxy=e=>{let t=c.get(e);return null==t&&(t=new BrowserWindowProxy(e),c.set(e,t)),t.getSafe()};class LocationProxy{constructor(e){this.getSafe=()=>{const e=this;return{get href(){return e.href},set href(t){e.href=t},get hash(){return e.hash},set hash(t){e.hash=t},get host(){return e.host},set host(t){e.host=t},get hostname(){return e.hostname},set hostname(t){e.hostname=t},get origin(){return e.origin},set origin(t){e.origin=t},get pathname(){return e.pathname},set pathname(t){e.pathname=t},get port(){return e.port},set port(t){e.port=t},get protocol(){return e.protocol},set protocol(t){e.protocol=t},get search(){return e.search},set search(t){e.search=t}}},this.guestId=e,this.getGuestURL=this.getGuestURL.bind(this)}static ProxyProperty(e,t){Object.defineProperty(e,t,{enumerable:!0,configurable:!0,get:function(){const e=this.getGuestURL(),n=e?e[t]:\"\";return void 0===n?\"\":n},set:function(e){const n=this.getGuestURL();if(n)return n[t]=e,this._invokeWebContentsMethod(\"loadURL\",n.toString())}})}toString(){return this.href}getGuestURL(){const e=this._invokeWebContentsMethodSync(\"getURL\"),t=\"\"!==e?e:\"about:blank\";try{return new URL(t)}catch(e){console.error(\"LocationProxy: failed to parse string\",t,e)}return null}_invokeWebContentsMethod(e,...t){return o.ipcRendererInternal.invoke(\"GUEST_WINDOW_MANAGER_WEB_CONTENTS_METHOD\",this.guestId,e,...t)}_invokeWebContentsMethodSync(e,...t){return i.invokeSync(\"GUEST_WINDOW_MANAGER_WEB_CONTENTS_METHOD\",this.guestId,e,...t)}}r([LocationProxy.ProxyProperty],LocationProxy.prototype,\"hash\",void 0),r([LocationProxy.ProxyProperty],LocationProxy.prototype,\"href\",void 0),r([LocationProxy.ProxyProperty],LocationProxy.prototype,\"host\",void 0),r([LocationProxy.ProxyProperty],LocationProxy.prototype,\"hostname\",void 0),r([LocationProxy.ProxyProperty],LocationProxy.prototype,\"origin\",void 0),r([LocationProxy.ProxyProperty],LocationProxy.prototype,\"pathname\",void 0),r([LocationProxy.ProxyProperty],LocationProxy.prototype,\"port\",void 0),r([LocationProxy.ProxyProperty],LocationProxy.prototype,\"protocol\",void 0),r([LocationProxy.ProxyProperty],LocationProxy.prototype,\"search\",void 0);class BrowserWindowProxy{constructor(e){this.closed=!1,this.getSafe=()=>{const e=this;return{postMessage:this.postMessage,blur:this.blur,close:this.close,focus:this.focus,print:this.print,eval:this.eval,get location(){return e.location},set location(t){e.location=t},get closed(){return e.closed}}},this.close=()=>{this._invokeWindowMethod(\"destroy\")},this.focus=()=>{this._invokeWindowMethod(\"focus\")},this.blur=()=>{this._invokeWindowMethod(\"blur\")},this.print=()=>{this._invokeWebContentsMethod(\"print\")},this.postMessage=(e,t)=>{o.ipcRendererInternal.invoke(\"GUEST_WINDOW_MANAGER_WINDOW_POSTMESSAGE\",this.guestId,e,toString(t),window.location.origin)},this.eval=e=>{this._invokeWebContentsMethod(\"executeJavaScript\",e)},this.guestId=e,this._location=new LocationProxy(e),o.ipcRendererInternal.once(`GUEST_WINDOW_MANAGER_WINDOW_CLOSED_${e}`,()=>{(e=>{c.delete(e)})(e),this.closed=!0})}get location(){return this._location.getSafe()}set location(e){e=resolveURL(e,this.location.href),this._invokeWebContentsMethod(\"loadURL\",e)}_invokeWindowMethod(e,...t){return o.ipcRendererInternal.invoke(\"GUEST_WINDOW_MANAGER_WINDOW_METHOD\",this.guestId,e,...t)}_invokeWebContentsMethod(e,...t){return o.ipcRendererInternal.invoke(\"GUEST_WINDOW_MANAGER_WEB_CONTENTS_METHOD\",this.guestId,e,...t)}}t.windowSetup=(t,n,r,i,c)=>{if(e.sandboxed||null!=t||(window.close=function(){o.ipcRendererInternal.send(\"BROWSER_WINDOW_CLOSE\")},a&&s.internalContextBridge.overrideGlobalValueFromIsolatedWorld([\"close\"],window.close)),i||(window.open=function(e,t,n){null!=e&&\"\"!==e&&(e=resolveURL(e,location.href));const r=o.ipcRendererInternal.sendSync(\"GUEST_WINDOW_MANAGER_WINDOW_OPEN\",e,toString(t),toString(n));return null!=r?getOrCreateProxy(r):null},a&&s.internalContextBridge.overrideGlobalValueWithDynamicPropsFromIsolatedWorld([\"open\"],window.open)),null!=n&&(window.opener=getOrCreateProxy(n),a&&s.internalContextBridge.overrideGlobalValueWithDynamicPropsFromIsolatedWorld([\"opener\"],window.opener)),window.prompt=function(){throw new Error(\"prompt() is and will not be supported.\")},a&&s.internalContextBridge.overrideGlobalValueFromIsolatedWorld([\"prompt\"],window.prompt),i&&null==n||o.ipcRendererInternal.on(\"GUEST_WINDOW_POSTMESSAGE\",(function(e,t,n,r){const o=document.createEvent(\"Event\");o.initEvent(\"message\",!1,!1),o.data=n,o.origin=r,o.source=getOrCreateProxy(t),window.dispatchEvent(o)})),!e.sandboxed&&!c){window.history.back=function(){o.ipcRendererInternal.send(\"NAVIGATION_CONTROLLER_GO_BACK\")},a&&s.internalContextBridge.overrideGlobalValueFromIsolatedWorld([\"history\",\"back\"],window.history.back),window.history.forward=function(){o.ipcRendererInternal.send(\"NAVIGATION_CONTROLLER_GO_FORWARD\")},a&&s.internalContextBridge.overrideGlobalValueFromIsolatedWorld([\"history\",\"forward\"],window.history.forward),window.history.go=function(e){o.ipcRendererInternal.send(\"NAVIGATION_CONTROLLER_GO_TO_OFFSET\",+e)},a&&s.internalContextBridge.overrideGlobalValueFromIsolatedWorld([\"history\",\"go\"],window.history.go);const getHistoryLength=()=>o.ipcRendererInternal.sendSync(\"NAVIGATION_CONTROLLER_LENGTH\");Object.defineProperty(window.history,\"length\",{get:getHistoryLength,set(){}}),a&&s.internalContextBridge.overrideGlobalPropertyFromIsolatedWorld([\"history\",\"length\"],getHistoryLength)}if(null!=t){let e=r?\"hidden\":\"visible\";o.ipcRendererInternal.on(\"GUEST_INSTANCE_VISIBILITY_CHANGE\",(function(t,n){e!==n&&(e=n,document.dispatchEvent(new Event(\"visibilitychange\")))}));const getDocumentHidden=()=>\"visible\"!==e;Object.defineProperty(document,\"hidden\",{get:getDocumentHidden}),a&&s.internalContextBridge.overrideGlobalPropertyFromIsolatedWorld([\"document\",\"hidden\"],getDocumentHidden);const getDocumentVisibilityState=()=>e;Object.defineProperty(document,\"visibilityState\",{get:getDocumentVisibilityState}),a&&s.internalContextBridge.overrideGlobalPropertyFromIsolatedWorld([\"document\",\"visibilityState\"],getDocumentVisibilityState)}}}).call(this,n(/*! @electron/internal/common/webpack-provider */\"./lib/common/webpack-provider.ts\").process)},events:\n/*!*************************!*\\\n  !*** external \"events\" ***!\n  \\*************************/\n/*! no static exports found */function(e,t){e.exports=require(\"events\")},module:\n/*!*************************!*\\\n  !*** external \"module\" ***!\n  \\*************************/\n/*! no static exports found */function(e,t){e.exports=require(\"module\")},path:\n/*!***********************!*\\\n  !*** external \"path\" ***!\n  \\***********************/\n/*! no static exports found */function(e,t){e.exports=require(\"path\")},stream:\n/*!*************************!*\\\n  !*** external \"stream\" ***!\n  \\*************************/\n/*! no static exports found */function(e,t){e.exports=require(\"stream\")},timers:\n/*!*************************!*\\\n  !*** external \"timers\" ***!\n  \\*************************/\n/*! no static exports found */function(e,t){e.exports=require(\"timers\")},util:\n/*!***********************!*\\\n  !*** external \"util\" ***!\n  \\***********************/\n/*! no static exports found */function(e,t){e.exports=require(\"util\")}})}(globalThis.process||binding.process).argv.includes(\"--profile-electron-init\")?setTimeout(___electron_webpack_init__,0):___electron_webpack_init__()}catch(e){console.error(\"Electron renderer_init.js script failed to run\"),console.error(e)}"
  },
  {
    "url": "events.js",
    "ranges": [
      {
        "start": 0,
        "end": 2230
      },
      {
        "start": 2286,
        "end": 2290
      },
      {
        "start": 2524,
        "end": 3316
      },
      {
        "start": 3364,
        "end": 3373
      },
      {
        "start": 3648,
        "end": 4407
      },
      {
        "start": 4966,
        "end": 4968
      },
      {
        "start": 5626,
        "end": 5999
      },
      {
        "start": 6148,
        "end": 6191
      },
      {
        "start": 6254,
        "end": 6382
      },
      {
        "start": 6958,
        "end": 6960
      },
      {
        "start": 7566,
        "end": 12183
      },
      {
        "start": 12286,
        "end": 12289
      },
      {
        "start": 12553,
        "end": 12555
      },
      {
        "start": 12796,
        "end": 12828
      },
      {
        "start": 12954,
        "end": 13006
      },
      {
        "start": 13176,
        "end": 13298
      },
      {
        "start": 14592,
        "end": 14712
      },
      {
        "start": 16038,
        "end": 16041
      },
      {
        "start": 16436,
        "end": 16473
      },
      {
        "start": 16540,
        "end": 16581
      },
      {
        "start": 16652,
        "end": 16684
      },
      {
        "start": 16852,
        "end": 16909
      },
      {
        "start": 17199,
        "end": 17237
      },
      {
        "start": 17330,
        "end": 17333
      },
      {
        "start": 17793,
        "end": 17795
      },
      {
        "start": 18009,
        "end": 18011
      },
      {
        "start": 18576,
        "end": 18654
      },
      {
        "start": 18675,
        "end": 18690
      },
      {
        "start": 18758,
        "end": 18760
      },
      {
        "start": 18943,
        "end": 18945
      },
      {
        "start": 19330,
        "end": 19332
      },
      {
        "start": 19921,
        "end": 19923
      },
      {
        "start": 22364,
        "end": 22365
      }
    ],
    "text": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  Boolean,\n  Error,\n  ErrorCaptureStackTrace,\n  MathMin,\n  NumberIsNaN,\n  ObjectCreate,\n  ObjectDefineProperty,\n  ObjectGetPrototypeOf,\n  ObjectSetPrototypeOf,\n  Promise,\n  PromiseReject,\n  PromiseResolve,\n  ReflectApply,\n  ReflectOwnKeys,\n  String,\n  Symbol,\n  SymbolFor,\n  SymbolAsyncIterator\n} = primordials;\nconst kRejection = SymbolFor('nodejs.rejection');\n\nlet spliceOne;\n\nconst {\n  kEnhanceStackBeforeInspector,\n  codes\n} = require('internal/errors');\nconst {\n  ERR_INVALID_ARG_TYPE,\n  ERR_OUT_OF_RANGE,\n  ERR_UNHANDLED_ERROR\n} = codes;\n\nconst {\n  inspect\n} = require('internal/util/inspect');\n\nconst kCapture = Symbol('kCapture');\nconst kErrorMonitor = Symbol('events.errorMonitor');\n\nfunction EventEmitter(opts) {\n  EventEmitter.init.call(this, opts);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\nmodule.exports.on = on;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.usingDomains = false;\n\nEventEmitter.captureRejectionSymbol = kRejection;\nObjectDefineProperty(EventEmitter, 'captureRejections', {\n  get() {\n    return EventEmitter.prototype[kCapture];\n  },\n  set(value) {\n    if (typeof value !== 'boolean') {\n      throw new ERR_INVALID_ARG_TYPE('EventEmitter.captureRejections',\n                                     'boolean', value);\n    }\n\n    EventEmitter.prototype[kCapture] = value;\n  },\n  enumerable: true\n});\n\nEventEmitter.errorMonitor = kErrorMonitor;\n\n// The default for captureRejections is false\nObjectDefineProperty(EventEmitter.prototype, kCapture, {\n  value: false,\n  writable: true,\n  enumerable: false\n});\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nlet defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('listener', 'Function', listener);\n  }\n}\n\nObjectDefineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new ERR_OUT_OF_RANGE('defaultMaxListeners',\n                                 'a non-negative number',\n                                 arg);\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function(opts) {\n\n  if (this._events === undefined ||\n      this._events === ObjectGetPrototypeOf(this)._events) {\n    this._events = ObjectCreate(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n\n\n  if (opts && opts.captureRejections) {\n    if (typeof opts.captureRejections !== 'boolean') {\n      throw new ERR_INVALID_ARG_TYPE('options.captureRejections',\n                                     'boolean', opts.captureRejections);\n    }\n    this[kCapture] = Boolean(opts.captureRejections);\n  } else {\n    // Assigning the kCapture property directly saves an expensive\n    // prototype lookup in a very sensitive hot path.\n    this[kCapture] = EventEmitter.prototype[kCapture];\n  }\n};\n\nfunction addCatch(that, promise, type, args) {\n  if (!that[kCapture]) {\n    return;\n  }\n\n  // Handle Promises/A+ spec, then could be a getter\n  // that throws on second use.\n  try {\n    const then = promise.then;\n\n    if (typeof then === 'function') {\n      then.call(promise, undefined, function(err) {\n        // The callback is called with nextTick to avoid a follow-up\n        // rejection from this promise.\n        process.nextTick(emitUnhandledRejectionOrErr, that, err, type, args);\n      });\n    }\n  } catch (err) {\n    that.emit('error', err);\n  }\n}\n\nfunction emitUnhandledRejectionOrErr(ee, err, type, args) {\n  if (typeof ee[kRejection] === 'function') {\n    ee[kRejection](err, type, ...args);\n  } else {\n    // We have to disable the capture rejections mechanism, otherwise\n    // we might end up in an infinite loop.\n    const prev = ee[kCapture];\n\n    // If the error handler throws, it is not catcheable and it\n    // will end up in 'uncaughtException'. We restore the previous\n    // value of kCapture in case the uncaughtException is present\n    // and the exception is handled.\n    try {\n      ee[kCapture] = false;\n      ee.emit('error', err);\n    } finally {\n      ee[kCapture] = prev;\n    }\n  }\n}\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new ERR_OUT_OF_RANGE('n', 'a non-negative number', n);\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\n// Returns the length and line number of the first sequence of `a` that fully\n// appears in `b` with a length of at least 4.\nfunction identicalSequenceRange(a, b) {\n  for (let i = 0; i < a.length - 3; i++) {\n    // Find the first entry of b that matches the current entry of a.\n    const pos = b.indexOf(a[i]);\n    if (pos !== -1) {\n      const rest = b.length - pos;\n      if (rest > 3) {\n        let len = 1;\n        const maxLen = MathMin(a.length - i, rest);\n        // Count the number of consecutive entries.\n        while (maxLen > len && a[i + len] === b[pos + len]) {\n          len++;\n        }\n        if (len > 3) {\n          return [len, i];\n        }\n      }\n    }\n  }\n\n  return [0, 0];\n}\n\nfunction enhanceStackTrace(err, own) {\n  let ctorInfo = '';\n  try {\n    const { name } = this.constructor;\n    if (name !== 'EventEmitter')\n      ctorInfo = ` on ${name} instance`;\n  } catch {}\n  const sep = `\\nEmitted 'error' event${ctorInfo} at:\\n`;\n\n  const errStack = err.stack.split('\\n').slice(1);\n  const ownStack = own.stack.split('\\n').slice(1);\n\n  const [ len, off ] = identicalSequenceRange(ownStack, errStack);\n  if (len > 0) {\n    ownStack.splice(off + 1, len - 2,\n                    '    [... lines matching original stack trace ...]');\n  }\n\n  return err.stack + sep + ownStack.join('\\n');\n}\n\nEventEmitter.prototype.emit = function emit(type, ...args) {\n  let doError = (type === 'error');\n\n  const events = this._events;\n  if (events !== undefined) {\n    if (doError && events[kErrorMonitor] !== undefined)\n      this.emit(kErrorMonitor, ...args);\n    doError = (doError && events.error === undefined);\n  } else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    let er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      try {\n        const capture = {};\n        ErrorCaptureStackTrace(capture, EventEmitter.prototype.emit);\n        ObjectDefineProperty(er, kEnhanceStackBeforeInspector, {\n          value: enhanceStackTrace.bind(this, er, capture),\n          configurable: true\n        });\n      } catch {}\n\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n\n    let stringifiedEr;\n    const { inspect } = require('internal/util/inspect');\n    try {\n      stringifiedEr = inspect(er);\n    } catch {\n      stringifiedEr = er;\n    }\n\n    // At least give some kind of context to the user\n    const err = new ERR_UNHANDLED_ERROR(stringifiedEr);\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  const handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    const result = ReflectApply(handler, this, args);\n\n    // We check if result is undefined first because that\n    // is the most common case so we do not pay any perf\n    // penalty\n    if (result !== undefined && result !== null) {\n      addCatch(this, result, type, args);\n    }\n  } else {\n    const len = handler.length;\n    const listeners = arrayClone(handler);\n    for (let i = 0; i < len; ++i) {\n      const result = ReflectApply(listeners[i], this, args);\n\n      // We check if result is undefined first because that\n      // is the most common case so we do not pay any perf\n      // penalty.\n      // This code is duplicated because extracting it away\n      // would make it non-inlineable.\n      if (result !== undefined && result !== null) {\n        addCatch(this, result, type, args);\n      }\n    }\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  let m;\n  let events;\n  let existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = ObjectCreate(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      const w = new Error('Possible EventEmitter memory leak detected. ' +\n                          `${existing.length} ${String(type)} listeners ` +\n                          `added to ${inspect(target, { depth: -1 })}. Use ` +\n                          'emitter.setMaxListeners() to increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      process.emitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  const state = { fired: false, wrapFn: undefined, target, type, listener };\n  const wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      checkListener(listener);\n\n      const events = this._events;\n      if (events === undefined)\n        return this;\n\n      const list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = ObjectCreate(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        let position = -1;\n\n        for (let i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          if (spliceOne === undefined)\n            spliceOne = require('internal/util').spliceOne;\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      const events = this._events;\n      if (events === undefined)\n        return this;\n\n      // Not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = ObjectCreate(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = ObjectCreate(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // Emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        for (const key of ReflectOwnKeys(events)) {\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = ObjectCreate(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      const listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (let i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  const events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  const evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  }\n  return listenerCount.call(emitter, type);\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  const events = this._events;\n\n  if (events !== undefined) {\n    const evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr) {\n  // At least since V8 8.3, this implementation is faster than the previous\n  // which always used a simple for-loop\n  switch (arr.length) {\n    case 2: return [arr[0], arr[1]];\n    case 3: return [arr[0], arr[1], arr[2]];\n    case 4: return [arr[0], arr[1], arr[2], arr[3]];\n    case 5: return [arr[0], arr[1], arr[2], arr[3], arr[4]];\n    case 6: return [arr[0], arr[1], arr[2], arr[3], arr[4], arr[5]];\n  }\n  return arr.slice();\n}\n\nfunction unwrapListeners(arr) {\n  const ret = arrayClone(arr);\n  for (let i = 0; i < ret.length; ++i) {\n    const orig = ret[i].listener;\n    if (typeof orig === 'function')\n      ret[i] = orig;\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise((resolve, reject) => {\n    const errorListener = (err) => {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    };\n    const resolver = (...args) => {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve(args);\n    };\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nconst AsyncIteratorPrototype = ObjectGetPrototypeOf(\n  ObjectGetPrototypeOf(async function* () {}).prototype);\n\nfunction createIterResult(value, done) {\n  return { value, done };\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticRemoveListener(emitter, name, listener, flags) {\n  if (typeof emitter.removeListener === 'function') {\n    emitter.removeListener(name, listener);\n  } else if (typeof emitter.removeEventListener === 'function') {\n    emitter.removeEventListener(name, listener, flags);\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('emitter', 'EventEmitter', emitter);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags && flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen to `error` events here.\n    emitter.addEventListener(name, (arg) => { listener(arg); }, flags);\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('emitter', 'EventEmitter', emitter);\n  }\n}\n\nfunction on(emitter, event) {\n  const unconsumedEvents = [];\n  const unconsumedPromises = [];\n  let error = null;\n  let finished = false;\n\n  const iterator = ObjectSetPrototypeOf({\n    next() {\n      // First, we consume all unread events\n      const value = unconsumedEvents.shift();\n      if (value) {\n        return PromiseResolve(createIterResult(value, false));\n      }\n\n      // Then we error, if an error happened\n      // This happens one time if at all, because after 'error'\n      // we stop listening\n      if (error) {\n        const p = PromiseReject(error);\n        // Only the first element errors\n        error = null;\n        return p;\n      }\n\n      // If the iterator is finished, resolve to done\n      if (finished) {\n        return PromiseResolve(createIterResult(undefined, true));\n      }\n\n      // Wait until an event happens\n      return new Promise(function(resolve, reject) {\n        unconsumedPromises.push({ resolve, reject });\n      });\n    },\n\n    return() {\n      eventTargetAgnosticRemoveListener(emitter, event, eventHandler);\n      eventTargetAgnosticRemoveListener(emitter, 'error', errorHandler);\n      finished = true;\n\n      for (const promise of unconsumedPromises) {\n        promise.resolve(createIterResult(undefined, true));\n      }\n\n      return PromiseResolve(createIterResult(undefined, true));\n    },\n\n    throw(err) {\n      if (!err || !(err instanceof Error)) {\n        throw new ERR_INVALID_ARG_TYPE('EventEmitter.AsyncIterator',\n                                       'Error', err);\n      }\n      error = err;\n      eventTargetAgnosticRemoveListener(emitter, event, eventHandler);\n      eventTargetAgnosticRemoveListener(emitter, 'error', errorHandler);\n    },\n\n    [SymbolAsyncIterator]() {\n      return this;\n    }\n  }, AsyncIteratorPrototype);\n\n  eventTargetAgnosticAddListener(emitter, event, eventHandler);\n  if (event !== 'error') {\n    addErrorHandlerIfEventEmitter(emitter, errorHandler);\n  }\n\n\n  return iterator;\n\n  function eventHandler(...args) {\n    const promise = unconsumedPromises.shift();\n    if (promise) {\n      promise.resolve(createIterResult(args, false));\n    } else {\n      unconsumedEvents.push(args);\n    }\n  }\n\n  function errorHandler(err) {\n    finished = true;\n\n    const toError = unconsumedPromises.shift();\n\n    if (toError) {\n      toError.reject(err);\n    } else {\n      // The next time we call next()\n      error = err;\n    }\n\n    iterator.return();\n  }\n}\n"
  },
  {
    "url": "file:///Users/simon/work/code/mapshaper-simplify/extracted/example.mjs",
    "ranges": [
      {
        "start": 0,
        "end": 1831
      }
    ],
    "text": "// const fs = require(\"fs\");\n// const path = require('path')\n\n// import {simplify} from '../src/commands/__simplify.mjs'\n// import { importGeoJSON } from '../src/geojson/geojson-import.js'\n// import { exportGeoJSON } from '../src/geojson/geojson-export.js'\n\n// import {\n// \tsimplify,\n// \timportGeoJSON,\n// \texportGeoJSON,\n// \tcleanPathsAfterImport,\n// \tbuildTopology,\n// \tparseLocalPath,\n// } from '../mapshaper.simplify.mjs'\n\n// const res = await fetch('./__country.json')\n// const geojson = await res.json()\n// console.log(geojson)\n\n// console.time('importGeoJSON')\n\n// console.timeEnd('importGeoJSON')\n\n// console.log(dataset)\n// // console.log(JSON.stringify(dataset))\n\n// console.time('simplify')\n// simplify(dataset, {\n// \tpercentage: 0.1,\n// \tkeep_shapes: true,\n// \tno_repair: false,\n// \tmethod: 'weighted_visvalingam'\n// })\n// console.timeEnd('simplify')\n\n// console.log(dataset)\n// // console.log(JSON.stringify(dataset))\n\n// console.time('exportGeoJSON')\n// const b = exportGeoJSON(dataset, {\n// \t// format: \"geojson\",\n// \t// v2: true\n\n// })\n// console.timeEnd('exportGeoJSON')\n\n// console.log(b[0].content)\n\nimport {\n\tpreBuild, \n\tsimplify\n} from '../mapshaper.simplify.mjs'\n\nconst res = await fetch('./__country.json')\nconst geojson = await res.json()\nconsole.log(geojson)\n\nconsole.time('preBuild')\nconst dataset = preBuild(geojson)\nconsole.timeEnd('preBuild')\n\nconsole.log(dataset)\n// console.log(JSON.stringify(dataset))\n\nconsole.time('simplify')\nconst geojson2 = simplify(dataset,  0.1)\nconsole.timeEnd('simplify')\nconsole.log(geojson2)\n\n// console.log(JSON.stringify(dataset))\n// console.log(JSON.stringify(geojson2))\n\nconsole.time('simplify')\nconst geojson3 = simplify(dataset,  0.5)\nconsole.timeEnd('simplify')\nconsole.log(geojson3)\n\n// console.log(JSON.stringify(dataset))\n// console.log(JSON.stringify(geojson3))"
  },
  {
    "url": "file:///Users/simon/work/code/mapshaper-simplify/mapshaper.simplify.mjs",
    "ranges": [
      {
        "start": 0,
        "end": 724
      },
      {
        "start": 1018,
        "end": 1146
      },
      {
        "start": 1384,
        "end": 1445
      },
      {
        "start": 1535,
        "end": 1682
      },
      {
        "start": 11286,
        "end": 11301
      },
      {
        "start": 11399,
        "end": 11590
      },
      {
        "start": 11761,
        "end": 11979
      },
      {
        "start": 12052,
        "end": 12122
      },
      {
        "start": 12290,
        "end": 12535
      },
      {
        "start": 12763,
        "end": 13050
      },
      {
        "start": 13792,
        "end": 14073
      },
      {
        "start": 14142,
        "end": 14207
      },
      {
        "start": 14401,
        "end": 14557
      },
      {
        "start": 15212,
        "end": 15348
      },
      {
        "start": 15423,
        "end": 15487
      },
      {
        "start": 15625,
        "end": 15659
      },
      {
        "start": 15951,
        "end": 16156
      },
      {
        "start": 16362,
        "end": 16556
      },
      {
        "start": 16904,
        "end": 17121
      },
      {
        "start": 17529,
        "end": 17817
      },
      {
        "start": 18027,
        "end": 19057
      },
      {
        "start": 19275,
        "end": 19601
      },
      {
        "start": 19758,
        "end": 19903
      },
      {
        "start": 20726,
        "end": 20796
      },
      {
        "start": 21676,
        "end": 21708
      },
      {
        "start": 21789,
        "end": 21901
      },
      {
        "start": 22828,
        "end": 22986
      },
      {
        "start": 23105,
        "end": 24965
      },
      {
        "start": 24987,
        "end": 25798
      },
      {
        "start": 25832,
        "end": 27905
      },
      {
        "start": 27944,
        "end": 28330
      },
      {
        "start": 28362,
        "end": 28377
      },
      {
        "start": 28401,
        "end": 28412
      },
      {
        "start": 28435,
        "end": 28451
      },
      {
        "start": 28477,
        "end": 28669
      },
      {
        "start": 28877,
        "end": 28880
      },
      {
        "start": 29923,
        "end": 30379
      },
      {
        "start": 30407,
        "end": 30494
      },
      {
        "start": 30547,
        "end": 31452
      },
      {
        "start": 31587,
        "end": 32633
      },
      {
        "start": 33083,
        "end": 33678
      },
      {
        "start": 33790,
        "end": 33803
      },
      {
        "start": 33836,
        "end": 34185
      },
      {
        "start": 34319,
        "end": 34333
      },
      {
        "start": 34403,
        "end": 34418
      },
      {
        "start": 34485,
        "end": 34655
      },
      {
        "start": 34754,
        "end": 34771
      },
      {
        "start": 35098,
        "end": 35504
      },
      {
        "start": 35567,
        "end": 35587
      },
      {
        "start": 35723,
        "end": 35741
      },
      {
        "start": 35846,
        "end": 35866
      },
      {
        "start": 36023,
        "end": 36186
      },
      {
        "start": 36214,
        "end": 36592
      },
      {
        "start": 36675,
        "end": 36796
      },
      {
        "start": 36840,
        "end": 37217
      },
      {
        "start": 37319,
        "end": 37343
      },
      {
        "start": 37466,
        "end": 37676
      },
      {
        "start": 37761,
        "end": 37782
      },
      {
        "start": 37867,
        "end": 37886
      },
      {
        "start": 37951,
        "end": 38323
      },
      {
        "start": 38561,
        "end": 38587
      },
      {
        "start": 38691,
        "end": 38785
      },
      {
        "start": 40384,
        "end": 40625
      },
      {
        "start": 40647,
        "end": 40791
      },
      {
        "start": 40819,
        "end": 41057
      },
      {
        "start": 41267,
        "end": 42338
      },
      {
        "start": 42428,
        "end": 42447
      },
      {
        "start": 42553,
        "end": 43122
      },
      {
        "start": 43340,
        "end": 44148
      },
      {
        "start": 44339,
        "end": 44887
      },
      {
        "start": 44967,
        "end": 48732
      },
      {
        "start": 48823,
        "end": 48840
      },
      {
        "start": 49591,
        "end": 49794
      },
      {
        "start": 49843,
        "end": 49955
      },
      {
        "start": 49991,
        "end": 50035
      },
      {
        "start": 50299,
        "end": 51798
      },
      {
        "start": 52471,
        "end": 53396
      },
      {
        "start": 53453,
        "end": 54864
      },
      {
        "start": 55121,
        "end": 55124
      },
      {
        "start": 55232,
        "end": 55277
      },
      {
        "start": 55433,
        "end": 55456
      },
      {
        "start": 55814,
        "end": 56198
      },
      {
        "start": 56221,
        "end": 56222
      },
      {
        "start": 56252,
        "end": 56253
      },
      {
        "start": 56280,
        "end": 56281
      },
      {
        "start": 56306,
        "end": 56307
      },
      {
        "start": 56329,
        "end": 56381
      },
      {
        "start": 56411,
        "end": 56444
      },
      {
        "start": 56475,
        "end": 56476
      },
      {
        "start": 56502,
        "end": 56529
      },
      {
        "start": 56552,
        "end": 56553
      },
      {
        "start": 56579,
        "end": 56580
      },
      {
        "start": 56610,
        "end": 56636
      },
      {
        "start": 56664,
        "end": 56665
      },
      {
        "start": 56692,
        "end": 56693
      },
      {
        "start": 56721,
        "end": 56722
      },
      {
        "start": 56749,
        "end": 56800
      },
      {
        "start": 56824,
        "end": 56825
      },
      {
        "start": 56853,
        "end": 56854
      },
      {
        "start": 56876,
        "end": 56877
      },
      {
        "start": 56904,
        "end": 56905
      },
      {
        "start": 56934,
        "end": 56935
      },
      {
        "start": 56959,
        "end": 57008
      },
      {
        "start": 57030,
        "end": 57053
      },
      {
        "start": 57075,
        "end": 57076
      },
      {
        "start": 57099,
        "end": 57121
      },
      {
        "start": 57152,
        "end": 57153
      },
      {
        "start": 57174,
        "end": 57175
      },
      {
        "start": 57197,
        "end": 57198
      },
      {
        "start": 57226,
        "end": 57227
      },
      {
        "start": 57251,
        "end": 57252
      },
      {
        "start": 57276,
        "end": 57277
      },
      {
        "start": 57306,
        "end": 57332
      },
      {
        "start": 57364,
        "end": 57398
      },
      {
        "start": 57427,
        "end": 57428
      },
      {
        "start": 57457,
        "end": 57488
      },
      {
        "start": 57513,
        "end": 57514
      },
      {
        "start": 57535,
        "end": 57536
      },
      {
        "start": 57557,
        "end": 57558
      },
      {
        "start": 57579,
        "end": 57580
      },
      {
        "start": 57602,
        "end": 57603
      },
      {
        "start": 57625,
        "end": 57626
      },
      {
        "start": 57658,
        "end": 57659
      },
      {
        "start": 57684,
        "end": 57685
      },
      {
        "start": 57714,
        "end": 57715
      },
      {
        "start": 57739,
        "end": 57764
      },
      {
        "start": 57792,
        "end": 57793
      },
      {
        "start": 57822,
        "end": 57823
      },
      {
        "start": 57854,
        "end": 57855
      },
      {
        "start": 57884,
        "end": 57885
      },
      {
        "start": 57918,
        "end": 57919
      },
      {
        "start": 57956,
        "end": 57957
      },
      {
        "start": 57983,
        "end": 57984
      },
      {
        "start": 58019,
        "end": 58020
      },
      {
        "start": 58052,
        "end": 58053
      },
      {
        "start": 58084,
        "end": 58118
      },
      {
        "start": 58145,
        "end": 58146
      },
      {
        "start": 58167,
        "end": 58192
      },
      {
        "start": 58218,
        "end": 58219
      },
      {
        "start": 58252,
        "end": 58253
      },
      {
        "start": 58282,
        "end": 58374
      },
      {
        "start": 58401,
        "end": 58402
      },
      {
        "start": 58435,
        "end": 58466
      },
      {
        "start": 58502,
        "end": 58503
      },
      {
        "start": 58532,
        "end": 58533
      },
      {
        "start": 58561,
        "end": 58562
      },
      {
        "start": 58590,
        "end": 58591
      },
      {
        "start": 58623,
        "end": 58624
      },
      {
        "start": 58659,
        "end": 58660
      },
      {
        "start": 58687,
        "end": 58787
      },
      {
        "start": 58819,
        "end": 58889
      },
      {
        "start": 58998,
        "end": 59028
      },
      {
        "start": 59140,
        "end": 59151
      },
      {
        "start": 59231,
        "end": 59258
      },
      {
        "start": 59362,
        "end": 59494
      },
      {
        "start": 59589,
        "end": 59660
      },
      {
        "start": 59814,
        "end": 59828
      },
      {
        "start": 59997,
        "end": 60011
      },
      {
        "start": 60078,
        "end": 60086
      },
      {
        "start": 60209,
        "end": 60496
      },
      {
        "start": 60566,
        "end": 60584
      },
      {
        "start": 60675,
        "end": 60881
      },
      {
        "start": 60928,
        "end": 61034
      },
      {
        "start": 61079,
        "end": 61087
      },
      {
        "start": 61125,
        "end": 61225
      },
      {
        "start": 61351,
        "end": 61366
      },
      {
        "start": 61396,
        "end": 61415
      },
      {
        "start": 61445,
        "end": 61457
      },
      {
        "start": 61591,
        "end": 61602
      },
      {
        "start": 61815,
        "end": 61829
      },
      {
        "start": 62036,
        "end": 62046
      },
      {
        "start": 62402,
        "end": 62463
      },
      {
        "start": 62616,
        "end": 62636
      },
      {
        "start": 62806,
        "end": 62826
      },
      {
        "start": 63030,
        "end": 63052
      },
      {
        "start": 63158,
        "end": 63178
      },
      {
        "start": 63287,
        "end": 63308
      },
      {
        "start": 63451,
        "end": 63472
      },
      {
        "start": 63970,
        "end": 63992
      },
      {
        "start": 64039,
        "end": 64060
      },
      {
        "start": 64101,
        "end": 64126
      },
      {
        "start": 64167,
        "end": 64186
      },
      {
        "start": 65383,
        "end": 65403
      },
      {
        "start": 65487,
        "end": 65518
      },
      {
        "start": 65789,
        "end": 65813
      },
      {
        "start": 65928,
        "end": 65952
      },
      {
        "start": 66067,
        "end": 66090
      },
      {
        "start": 66141,
        "end": 66167
      },
      {
        "start": 66231,
        "end": 66257
      },
      {
        "start": 66321,
        "end": 66347
      },
      {
        "start": 66446,
        "end": 66472
      },
      {
        "start": 66571,
        "end": 66594
      },
      {
        "start": 66740,
        "end": 66763
      },
      {
        "start": 66913,
        "end": 66935
      },
      {
        "start": 67017,
        "end": 67042
      },
      {
        "start": 67131,
        "end": 67156
      },
      {
        "start": 67245,
        "end": 67270
      },
      {
        "start": 67362,
        "end": 67387
      },
      {
        "start": 67479,
        "end": 67504
      },
      {
        "start": 67566,
        "end": 67591
      },
      {
        "start": 67653,
        "end": 67679
      },
      {
        "start": 67741,
        "end": 67767
      },
      {
        "start": 67829,
        "end": 67854
      },
      {
        "start": 68000,
        "end": 68025
      },
      {
        "start": 68176,
        "end": 68200
      },
      {
        "start": 68315,
        "end": 68342
      },
      {
        "start": 68474,
        "end": 68501
      },
      {
        "start": 68633,
        "end": 68660
      },
      {
        "start": 68831,
        "end": 68858
      },
      {
        "start": 69029,
        "end": 69053
      },
      {
        "start": 69247,
        "end": 69271
      },
      {
        "start": 69470,
        "end": 69493
      },
      {
        "start": 69628,
        "end": 69654
      },
      {
        "start": 69791,
        "end": 69817
      },
      {
        "start": 69954,
        "end": 69980
      },
      {
        "start": 70161,
        "end": 70187
      },
      {
        "start": 70392,
        "end": 70418
      },
      {
        "start": 70484,
        "end": 70510
      },
      {
        "start": 70576,
        "end": 70603
      },
      {
        "start": 70669,
        "end": 70696
      },
      {
        "start": 70762,
        "end": 70780
      },
      {
        "start": 71391,
        "end": 71409
      },
      {
        "start": 72078,
        "end": 72289
      },
      {
        "start": 72357,
        "end": 72378
      },
      {
        "start": 72485,
        "end": 72509
      },
      {
        "start": 72587,
        "end": 72610
      },
      {
        "start": 72667,
        "end": 72675
      },
      {
        "start": 72736,
        "end": 72758
      },
      {
        "start": 72854,
        "end": 73082
      },
      {
        "start": 73183,
        "end": 73389
      },
      {
        "start": 73459,
        "end": 73715
      },
      {
        "start": 73757,
        "end": 73778
      },
      {
        "start": 73820,
        "end": 73847
      },
      {
        "start": 73923,
        "end": 73985
      },
      {
        "start": 74067,
        "end": 74091
      },
      {
        "start": 74185,
        "end": 74207
      },
      {
        "start": 74301,
        "end": 74320
      },
      {
        "start": 74398,
        "end": 74421
      },
      {
        "start": 74491,
        "end": 74510
      },
      {
        "start": 74665,
        "end": 74798
      },
      {
        "start": 74831,
        "end": 75037
      },
      {
        "start": 75245,
        "end": 75265
      },
      {
        "start": 75415,
        "end": 75438
      },
      {
        "start": 75596,
        "end": 75622
      },
      {
        "start": 75843,
        "end": 75868
      },
      {
        "start": 75932,
        "end": 76382
      },
      {
        "start": 76428,
        "end": 76443
      },
      {
        "start": 76591,
        "end": 76648
      },
      {
        "start": 76752,
        "end": 76825
      },
      {
        "start": 76921,
        "end": 76972
      },
      {
        "start": 77040,
        "end": 77227
      },
      {
        "start": 77272,
        "end": 77355
      },
      {
        "start": 77411,
        "end": 77440
      },
      {
        "start": 77511,
        "end": 77527
      },
      {
        "start": 77576,
        "end": 77590
      },
      {
        "start": 77662,
        "end": 77682
      },
      {
        "start": 77754,
        "end": 77777
      },
      {
        "start": 77940,
        "end": 77960
      },
      {
        "start": 78071,
        "end": 78425
      },
      {
        "start": 78497,
        "end": 78525
      },
      {
        "start": 78693,
        "end": 79460
      },
      {
        "start": 79583,
        "end": 79836
      },
      {
        "start": 79896,
        "end": 80540
      },
      {
        "start": 80683,
        "end": 81067
      },
      {
        "start": 81093,
        "end": 81123
      },
      {
        "start": 81203,
        "end": 81711
      },
      {
        "start": 81752,
        "end": 81764
      },
      {
        "start": 81846,
        "end": 81999
      },
      {
        "start": 82067,
        "end": 82236
      },
      {
        "start": 82286,
        "end": 82296
      },
      {
        "start": 82335,
        "end": 82343
      },
      {
        "start": 82379,
        "end": 82389
      },
      {
        "start": 82692,
        "end": 82705
      },
      {
        "start": 82745,
        "end": 82757
      },
      {
        "start": 82815,
        "end": 82828
      },
      {
        "start": 82894,
        "end": 83063
      },
      {
        "start": 83121,
        "end": 83166
      },
      {
        "start": 83229,
        "end": 83237
      },
      {
        "start": 83315,
        "end": 83380
      },
      {
        "start": 83423,
        "end": 84633
      },
      {
        "start": 84669,
        "end": 84766
      },
      {
        "start": 84796,
        "end": 84813
      },
      {
        "start": 84889,
        "end": 85056
      },
      {
        "start": 85090,
        "end": 85102
      },
      {
        "start": 85134,
        "end": 85163
      },
      {
        "start": 85296,
        "end": 85316
      },
      {
        "start": 85470,
        "end": 85491
      },
      {
        "start": 85685,
        "end": 85704
      },
      {
        "start": 85832,
        "end": 85850
      },
      {
        "start": 86051,
        "end": 86292
      },
      {
        "start": 86556,
        "end": 86564
      },
      {
        "start": 86611,
        "end": 86633
      },
      {
        "start": 87017,
        "end": 87385
      }
    ],
    "text": "/*\n The buffer module from node.js, for the browser.\n\n @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n @license  MIT\n*/\nfunction Ob(a,b,c,d){for(var e,f,h=c+2;h<=d;h+=2){e=b[h],f=b[h+1];for(var g=h-2;g>=c&&a[e]<a[b[g]];g-=2)b[g+2]=b[g],b[g+3]=b[g+1];b[g+2]=e,b[g+3]=f}}function Pb(a,b,c,d){for(var h,g,e=c,f=d;e<d;){for(h=a[b[c+d>>2<<1]];e<=f;){for(;a[b[e]]<h;)e+=2;for(;a[b[f]]>h;)f-=2;e<=f&&(g=b[e],b[e]=b[f],b[f]=g,g=b[e+1],b[e+1]=b[f+1],b[f+1]=g,e+=2,f-=2)}if(40>f-c?Ob(a,b,c,f):Pb(a,b,c,f),40>d-e){Ob(a,b,e,d);break}c=e,f=d}}function Rb(a,b,c,d,e,f){return a-=d,b-=e,c-=f,Math.sqrt(a*a+b*b+c*c)}function z(a,b,c,d){return(a-=c)*a+(b-=d)*b}function Sb(a,b,c,d){return a-=c,b-=d,Math.sqrt(a*a+b*b)}function Tb(a,b,c,d,e,f){return(a-=d)*a+(b-=e)*b+(c-=f)*c}function Ub(a){for(var b=2*Math.PI;0>a;)a+=b;for(;a>=b;)a-=b;return a}function Vb(a,b,c,d){var e=Math.PI/180;return a*=e,c*=e,b*=e,d*=e,Math.atan2(Math.sin(c-a)*Math.cos(d),Math.cos(b)*Math.sin(d)-Math.sin(b)*Math.cos(d)*Math.cos(c-a))}function Wb(a,b,c){a*=Qb,b*=Qb;var d=Math.cos(b);c[0]=Math.cos(a)*d*6378137,c[1]=Math.sin(a)*d*6378137,c[2]=6378137*Math.sin(b)}function Xb(a,b,c,d){return a=c-a,c=d-b,b=Math.sin(c/2)*Math.sin(c/2)+Math.cos(b)*Math.cos(d)*Math.sin(a/2)*Math.sin(a/2),2*Math.atan2(Math.sqrt(b),Math.sqrt(1-b))}function Yb(a,b,c,d){var e=Math.PI/180;return 6378137*Xb(a*e,b*e,c*e,d*e)}function Zb(a,b,c,d,e,f){return(a=a*d-a*f+c*f-c*b+e*b-e*d)*a}function $b(a,b,c){return 0!==c&&(a>=b+c?a=b:b>=a+c||(a-=(b=a+c-b)*b/c*.25)),0>a&&(a=0),a}function ac(a,b,c,d,e,f){var h=z(c,d,e,f),g=((a-c)*(e-c)+(b-d)*(f-d))/h;return 0===h?z(a,b,c,d):(0>g&&(g=0),1<g&&(g=1),z(a,b,c+g*(e-c),d+g*(f-d)))}function ec(){dc=!0;for(var a=0;64>a;++a)F[a]=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[a],I[\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charCodeAt(a)]=a;I[45]=62,I[95]=63}function fc(a){dc||ec();for(var b=a.length,c=b%3,d=\"\",e=[],f=0,h=b-c;f<h;f+=16383){for(var n,g=e,l=g.push,p=a,r=f+16383>h?h:f+16383,u=[],t=f;t<r;t+=3)n=(p[t]<<16)+(p[t+1]<<8)+p[t+2],u.push(F[n>>18&63]+F[n>>12&63]+F[n>>6&63]+F[63&n]);n=u.join(\"\"),l.call(g,n)}return 1===c?(a=a[b-1],d+=F[a>>2],d+=F[a<<4&63],d+=\"==\"):2===c&&(a=(a[b-2]<<8)+a[b-1],d+=F[a>>10],d+=F[a>>4&63],d+=F[a<<2&63],d+=\"=\"),e.push(d),e.join(\"\")}function gc(a,b,c,d,e){var f=8*e-d-1,h=(1<<f)-1,g=h>>1,l=-7,n=c?-1:1,p=a[b+(e=c?e-1:0)];for(e+=n,c=p&(1<<-l)-1,p>>=-l,l+=f;0<l;c=256*c+a[b+e],e+=n,l-=8);for(f=c&(1<<-l)-1,c>>=-l,l+=d;0<l;f=256*f+a[b+e],e+=n,l-=8);if(0===c)c=1-g;else{if(c===h)return f?NaN:1/0*(p?-1:1);f+=Math.pow(2,d),c-=g}return(p?-1:1)*f*Math.pow(2,c-d)}function hc(a,b,c,d,e,f){var h,g=8*f-e-1,l=(1<<g)-1,n=l>>1,p=23===e?Math.pow(2,-24)-Math.pow(2,-77):0;f=d?0:f-1;var r=d?1:-1,u=0>b||0===b&&0>1/b?1:0;for(b=Math.abs(b),isNaN(b)||1/0===b?(b=isNaN(b)?1:0,d=l):(d=Math.floor(Math.log(b)/Math.LN2),1>b*(h=Math.pow(2,-d))&&(d--,h*=2),2<=(b=1<=d+n?b+p/h:b+p*Math.pow(2,1-n))*h&&(d++,h/=2),d+n>=l?(b=0,d=l):1<=d+n?(b=(b*h-1)*Math.pow(2,e),d+=n):(b=b*Math.pow(2,n-1)*Math.pow(2,e),d=0));8<=e;a[c+f]=255&b,f+=r,b/=256,e-=8);for(d=d<<e|b,g+=e;0<g;a[c+f]=255&d,f+=r,d/=256,g-=8);a[c+f-r]|=128*u}function kc(a,b){if((J.TYPED_ARRAY_SUPPORT?2147483647:1073741823)<b)throw new RangeError(\"Invalid typed array length\");return J.TYPED_ARRAY_SUPPORT?(a=new Uint8Array(b)).__proto__=J.prototype:(null===a&&(a=new J(b)),a.length=b),a}function J(a,b,c){if(!(J.TYPED_ARRAY_SUPPORT||this instanceof J))return new J(a,b,c);if(\"number\"==typeof a){if(\"string\"==typeof b)throw Error(\"If encoding is specified then the first argument must be a string\");return lc(this,a)}return mc(this,a,b,c)}function mc(a,b,c,d){if(\"number\"==typeof b)throw new TypeError('\"value\" argument must not be a number');if(\"undefined\"!=typeof ArrayBuffer&&b instanceof ArrayBuffer){if(b.byteLength,0>c||b.byteLength<c)throw new RangeError(\"'offset' is out of bounds\");if(b.byteLength<c+(d||0))throw new RangeError(\"'length' is out of bounds\");return b=void 0===c&&void 0===d?new Uint8Array(b):void 0===d?new Uint8Array(b,c):new Uint8Array(b,c,d),J.TYPED_ARRAY_SUPPORT?(a=b).__proto__=J.prototype:a=nc(a,b),a}if(\"string\"==typeof b){if(d=a,\"string\"==typeof(a=c)&&\"\"!==a||(a=\"utf8\"),!J.isEncoding(a))throw new TypeError('\"encoding\" must be a valid string encoding');return(b=(d=kc(d,c=0|oc(b,a))).write(b,a))!==c&&(d=d.slice(0,b)),d}return function pc(a,b){if(M(b)){var c=0|rc(b.length);return 0===(a=kc(a,c)).length||b.copy(a,0,0,c),a}if(b){if(\"undefined\"!=typeof ArrayBuffer&&b.buffer instanceof ArrayBuffer||\"length\"in b)return(c=\"number\"!=typeof b.length)||(c=(c=b.length)!=c),c?kc(a,0):nc(a,b);if(\"Buffer\"===b.type&&jc(b.data))return nc(a,b.data)}throw new TypeError(\"First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.\")}(a,b)}function qc(a){if(\"number\"!=typeof a)throw new TypeError('\"size\" argument must be a number');if(0>a)throw new RangeError('\"size\" argument must not be negative')}function lc(a,b){if(qc(b),a=kc(a,0>b?0:0|rc(b)),!J.TYPED_ARRAY_SUPPORT)for(var c=0;c<b;++c)a[c]=0;return a}function nc(a,b){var c=0>b.length?0:0|rc(b.length);a=kc(a,c);for(var d=0;d<c;d+=1)a[d]=255&b[d];return a}function rc(a){if(a>=(J.TYPED_ARRAY_SUPPORT?2147483647:1073741823))throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\"+(J.TYPED_ARRAY_SUPPORT?2147483647:1073741823).toString(16)+\" bytes\");return 0|a}function M(a){return!(null==a||!a._isBuffer)}function oc(a,b){if(M(a))return a.length;if(\"undefined\"!=typeof ArrayBuffer&&\"function\"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(a)||a instanceof ArrayBuffer))return a.byteLength;\"string\"!=typeof a&&(a=\"\"+a);var c=a.length;if(0===c)return 0;for(var d=!1;;)switch(b){case\"ascii\":case\"latin1\":case\"binary\":return c;case\"utf8\":case\"utf-8\":case void 0:return tc(a).length;case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return 2*c;case\"hex\":return c>>>1;case\"base64\":return uc(a).length;default:if(d)return tc(a).length;b=(\"\"+b).toLowerCase(),d=!0}}function vc(a,b,c){var d=!1;if((void 0===b||0>b)&&(b=0),b>this.length)return\"\";if((void 0===c||c>this.length)&&(c=this.length),0>=c)return\"\";if((c>>>=0)<=(b>>>=0))return\"\";for(a||(a=\"utf8\");;)switch(a){case\"hex\":for(a=b,b=c,c=this.length,(!a||0>a)&&(a=0),(!b||0>b||b>c)&&(b=c),d=\"\",c=a;c<b;++c)d=(a=d)+(d=16>(d=this[c])?\"0\"+d.toString(16):d.toString(16));return d;case\"utf8\":case\"utf-8\":return wc(this,b,c);case\"ascii\":for(a=\"\",c=Math.min(this.length,c);b<c;++b)a+=String.fromCharCode(127&this[b]);return a;case\"latin1\":case\"binary\":for(a=\"\",c=Math.min(this.length,c);b<c;++b)a+=String.fromCharCode(this[b]);return a;case\"base64\":return 0===b&&c===this.length?fc(this):fc(this.slice(b,c));case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":for(b=this.slice(b,c),c=\"\",a=0;a<b.length;a+=2)c+=String.fromCharCode(b[a]+256*b[a+1]);return c;default:if(d)throw new TypeError(\"Unknown encoding: \"+a);a=(a+\"\").toLowerCase(),d=!0}}function xc(a,b,c){var d=a[b];a[b]=a[c],a[c]=d}function yc(a,b,c,d,e){if(0===a.length)return-1;if(\"string\"==typeof c?(d=c,c=0):2147483647<c?c=2147483647:-2147483648>c&&(c=-2147483648),c=+c,isNaN(c)&&(c=e?0:a.length-1),0>c&&(c=a.length+c),c>=a.length){if(e)return-1;c=a.length-1}else if(0>c){if(!e)return-1;c=0}if(\"string\"==typeof b&&(b=J.from(b,d)),M(b))return 0===b.length?-1:zc(a,b,c,d,e);if(\"number\"==typeof b)return b&=255,J.TYPED_ARRAY_SUPPORT&&\"function\"==typeof Uint8Array.prototype.indexOf?e?Uint8Array.prototype.indexOf.call(a,b,c):Uint8Array.prototype.lastIndexOf.call(a,b,c):zc(a,[b],c,d,e);throw new TypeError(\"val must be string, number or Buffer\")}function zc(a,b,c,d,e){function f(n,p){return 1===h?n[p]:n.readUInt16BE(p*h)}var h=1,g=a.length,l=b.length;if(void 0!==d&&(\"ucs2\"===(d=String(d).toLowerCase())||\"ucs-2\"===d||\"utf16le\"===d||\"utf-16le\"===d)){if(2>a.length||2>b.length)return-1;h=2,g/=2,l/=2,c/=2}if(e)for(d=-1;c<g;c++)if(f(a,c)===f(b,-1===d?0:c-d)){if(-1===d&&(d=c),c-d+1===l)return d*h}else-1!==d&&(c-=c-d),d=-1;else for(c+l>g&&(c=g-l);0<=c;c--){for(g=!0,d=0;d<l;d++)if(f(a,c+d)!==f(b,d)){g=!1;break}if(g)return c}return-1}function wc(a,b,c){c=Math.min(a.length,c);for(var d=[];b<c;){var e=a[b],f=null,h=239<e?4:223<e?3:191<e?2:1;if(b+h<=c)switch(h){case 1:128>e&&(f=e);break;case 2:var g=a[b+1];128==(192&g)&&127<(e=(31&e)<<6|63&g)&&(f=e);break;case 3:g=a[b+1];var l=a[b+2];128==(192&g)&&128==(192&l)&&2047<(e=(15&e)<<12|(63&g)<<6|63&l)&&(55296>e||57343<e)&&(f=e);break;case 4:g=a[b+1],l=a[b+2];var n=a[b+3];128==(192&g)&&128==(192&l)&&128==(192&n)&&65535<(e=(15&e)<<18|(63&g)<<12|(63&l)<<6|63&n)&&1114112>e&&(f=e)}null===f?(f=65533,h=1):65535<f&&(f-=65536,d.push(f>>>10&1023|55296),f=56320|1023&f),d.push(f),b+=h}if((a=d.length)<=Cc)d=String.fromCharCode.apply(String,d);else{for(c=\"\",b=0;b<a;)c+=String.fromCharCode.apply(String,d.slice(b,b+=Cc));d=c}return d}function O(a,b,c){if(0!=a%1||0>a)throw new RangeError(\"offset is not uint\");if(a+b>c)throw new RangeError(\"Trying to access beyond buffer length\")}function P(a,b,c,d,e,f){if(!M(a))throw new TypeError('\"buffer\" argument must be a Buffer instance');if(b>e||b<f)throw new RangeError('\"value\" argument is out of bounds');if(c+d>a.length)throw new RangeError(\"Index out of range\")}function Dc(a,b,c,d){0>b&&(b=65535+b+1);for(var e=0,f=Math.min(a.length-c,2);e<f;++e)a[c+e]=(b&255<<8*(d?e:1-e))>>>8*(d?e:1-e)}function Ec(a,b,c,d){0>b&&(b=4294967295+b+1);for(var e=0,f=Math.min(a.length-c,4);e<f;++e)a[c+e]=b>>>8*(d?e:3-e)&255}function Fc(a,b,c,d){if(c+d>a.length)throw new RangeError(\"Index out of range\");if(0>c)throw new RangeError(\"Index out of range\")}function tc(a,b){b=b||1/0;for(var c,d=a.length,e=null,f=[],h=0;h<d;++h){if(55295<(c=a.charCodeAt(h))&&57344>c){if(!e){if(56319<c){-1<(b-=3)&&f.push(239,191,189);continue}if(h+1===d){-1<(b-=3)&&f.push(239,191,189);continue}e=c;continue}if(56320>c){-1<(b-=3)&&f.push(239,191,189),e=c;continue}c=65536+(e-55296<<10|c-56320)}else e&&-1<(b-=3)&&f.push(239,191,189);if(e=null,128>c){if(0>--b)break;f.push(c)}else if(2048>c){if(0>(b-=2))break;f.push(c>>6|192,63&c|128)}else if(65536>c){if(0>(b-=3))break;f.push(c>>12|224,c>>6&63|128,63&c|128)}else{if(!(1114112>c))throw Error(\"Invalid code point\");if(0>(b-=4))break;f.push(c>>18|240,c>>12&63|128,c>>6&63|128,63&c|128)}}return f}function Bc(a){for(var b=[],c=0;c<a.length;++c)b.push(255&a.charCodeAt(c));return b}function uc(a){if(2>(a=(a.trim?a.trim():a.replace(/^\\s+|\\s+$/g,\"\")).replace(Gc,\"\")).length)a=\"\";else for(;0!=a.length%4;)a+=\"=\";dc||ec();var b=a.length;if(0<b%4)throw Error(\"Invalid string. Length must be a multiple of 4\");var c=\"=\"===a[b-2]?2:\"=\"===a[b-1]?1:0,d=new cc(3*b/4-c),e=0<c?b-4:b,f=0;for(b=0;b<e;b+=4){var h=I[a.charCodeAt(b)]<<18|I[a.charCodeAt(b+1)]<<12|I[a.charCodeAt(b+2)]<<6|I[a.charCodeAt(b+3)];d[f++]=h>>16&255,d[f++]=h>>8&255,d[f++]=255&h}return 2===c?(h=I[a.charCodeAt(b)]<<2|I[a.charCodeAt(b+1)]>>4,d[f++]=255&h):1===c&&(h=I[a.charCodeAt(b)]<<10|I[a.charCodeAt(b+1)]<<4|I[a.charCodeAt(b+2)]>>2,d[f++]=h>>8&255,d[f++]=255&h),d}function Ac(a,b,c,d){for(var e=0;e<d&&!(e+c>=b.length||e>=a.length);++e)b[e+c]=a[e];return e}function Hc(a){return!!a.constructor&&\"function\"==typeof a.constructor.isBuffer&&a.constructor.isBuffer(a)}function Jc(){var a=w.toArray(arguments).join(\" \");throw Error(a)}function Kc(){throw new Lc(w.toArray(arguments).join(\" \"))}function Mc(){}function Q(){Jc.apply(null,w.toArray(arguments))}function R(){Kc.apply(null,w.toArray(arguments))}function Nc(){var a=Mc.apply,b=w.toArray(arguments),c=Ic.current_command;c&&\"help\"!=c&&b.unshift(\"[\"+c+\"]\"),a.call(Mc,null,b)}function Oc(){(Ic.VERBOSE||Ic.verbose)&&Nc.apply(null,arguments)}function Lc(a){return(a=Error(a)).name=\"UserError\",a}function ca(a){return(a||\"__id_\")+ ++Pc}function da(a){return\"function\"==typeof a}function ea(a){return a===Object(a)}function fa(a,b,c){return a<b?b:a>c?c:a}function ha(a){return Array.isArray(a)}function ia(a){return null!=a&&a.constructor==Number}function ja(a){return ia(a)&&!isNaN(a)}function ka(a){return ja(a)&&1/0!==a&&-1/0!==a}function ma(a){return ia(a)&&0<=a}function na(a){return ia(a)&&(0|a)===a}function oa(a){return null!=a&&a.toString===String.prototype.toString}function pa(a){return!!a&&a.getTime===Date.prototype.getTime}function qa(a){return!0===a||!1===a}function ra(a){return pa(a)?a.toISOString().replace(\":00.000Z\",\"Z\"):\"\"}function sa(a){ta(a)||Q(\"toArray() requires an array-like object\");try{var b=Array.prototype.slice.call(a,0)}catch(e){b=[];for(var c=0,d=a.length;c<d;c++)b[c]=a[c]}return b}function ta(a){return!!a&&(!!ha(a)||!oa(a)&&(0===a.length||0<a.length))}function ua(a){return(a+\"\").replace(/[\\\\\"']/g,\"\\\\$&\").replace(/\\u0000/g,\"\\\\0\")}function va(a){return a.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g,\"\\\\$&\")}function wa(a){return String(a).replace(/[&<>\"'\\/]/g,(function(b){return Qc[b]}))}function xa(a){for(var b=1,c=arguments.length;b<c;b++){var e,d=arguments[b]||{};for(e in d)0==e in a&&d.hasOwnProperty(e)&&(a[e]=d[e])}return a}function ya(a){var d,e,b=a||{},c=arguments.length;for(e=1;e<c;e++){var f=arguments[e]||{};for(d in f)f.hasOwnProperty(d)&&(b[d]=f[d])}return b}function za(a,b){function c(){this.__super__==c&&(this.__super__=b.prototype.__super__,b.apply(this,arguments),delete this.__super__)}c.prototype=b.prototype||b,a.prototype=ya(new c,a.prototype),a.prototype.constructor=a,a.prototype.__super__=c}function Aa(a,b,c,d){var f=\"undefined\"==typeof setImmediate?setTimeout:setImmediate,h=0;!function e(g,l){if(g)return d(g,null);f((function(){0==h<a.length?d(null,l):c(l,a[h++],e)}),0)}(null,b)}function Ba(a,b){ha(a)&&ha(b)||Q(\"Usage: merge(destArray, srcArray);\");for(var c=0,d=b.length;c<d;c++)a.push(b[c]);return a}function Ca(a,b){var c=Ta(b);return a.filter((function(d){return!Object.prototype.hasOwnProperty.call(c,d)}))}function Da(a,b){return a.filter((function(c){return b.includes(c)}))}function Ea(a,b){for(var c=b!=b,d=0,e=a.length||0;d<e;d++)if(a[d]===b||c&&a[d]!=a[d])return d;return-1}function Fa(a,b){return oa(a)?-1!=a.indexOf(b):ta(a)?-1!=Ea(a,b):void Q(\"Expected Array or String argument\")}function Ga(a,b){return a.reduce((function(c,d){return c||b(d)}),!1)}function Ha(a,b){return a.reduce((function(c,d){return c&&b(d)}),!0)}function Ia(a,b,c){return 0===(a=a.filter(b,c)).length?null:a[0]}function Ka(a,b,c){var d=[];for(b=void 0===b?0:b,c=void 0===c?1:c;a--;)d.push(b),b+=c;return d}function La(a,b){for(var d,c=[],e=0;e<a;e++)void 0!==(d=b(e))&&(c[e]=d);return 0<c.length?c:void 0}function Ma(a,b){ta(a)||Q(\"sum() expects an array, received:\",a);for(var e,c=0,d=0,f=0,h=a.length;f<h;f++)(e=a[f])?c+=e:isNaN(e)&&d++;return b&&(b.nan=d),c}function Na(a){for(var e,b=1/0,c=-1/0,d=0,f=0,h=a.length;f<h;f++)(e=a[f])!=e&&d++,e<b&&(b=e),e>c&&(c=e);return{min:b,max:c,nan:d}}function Oa(a){for(var d,b=new Set,c=[],e=0,f=a.length;e<f;e++)d=a[e],b.has(d)||(c.push(d),b.add(d));return c}function Pa(a,b){return a.map((function(c){return c[b]}))}function Qa(a){return a.reduce((function(b,c){return b[c]=c in b?b[c]+1:1,b}),{})}function Ra(a,b){return a.reduce((function(c,d){return c[d[b]]=d,c}),{})}function Sa(a,b){return a.reduce((function(c,d){var e=d[b];return e in c?c[e].push(d):c[e]=[d],c}),{})}function Ta(a,b){var c=1<arguments.length;return a.reduce((function(d,e){return d[e]=!c||b,d}),{})}function Ua(a,b,c){if(!ta(a))throw Error(\"#forEach() takes an array-like argument. \"+a);for(var d=0,e=a.length;d<e;d++)b.call(c,a[d],d)}function Va(a,b,c){Object.keys(a).forEach((function(d){b.call(c,a[d],d)}))}function Wa(a,b){for(var c=0,d=a.length;c<d;c++)a[c]=b;return a}function Xa(a,b){a.splice(0,a.length);for(var c=0,d=b.length;c<d;c++)a.push(b[c])}function Ya(a,b){for(var c=\"\",d=0;d<b;d++)c+=a;return c}function Za(a){return 1!=a?\"s\":\"\"}function $a(a,b){return-1!==a.indexOf(b,a.length-b.length)}function ab(a,b,c){return Ya(c||\" \",b-(a=String(a)).length)+a}function bb(a,b,c){return(a=String(a))+Ya(c||\" \",b-a.length)}function cb(a){return db(eb(a))}function db(a){return a.replace(Rc,\"\")}function eb(a){return a.replace(Sc,\"\")}function fb(a){var b=\"\",c=\"-\"==a[0]?1:0,d=a.indexOf(\".\"),e=a.length;for(d=(-1==d?e:d)-3;d>c;)b=\",\"+a.substring(d,e)+b,e=d,d-=3;return a.substring(0,e)+b}function gb(a,b){return 0<=b?a.toFixed(b):String(a)}function hb(a,b,c,d){return isNaN(a)?a=c||\"-\":(a=fb(a=gb(a,b)),d&&0<parseFloat(a)&&(a=\"+\"+a)),a}function ib(a){var b;for(b=a.length-1;0<b;b--){var c=Math.floor(Math.random()*(b+1)),d=a[b];a[b]=a[c],a[c]=d}}function jb(a){for(var b=[],c=1;c<arguments.length;c+=2)b.push(ob(arguments[c],arguments[c+1]));return a.sort((function(d,e){for(var f=0,h=0,g=b.length;h<g&&0===f;)f=b[h](d,e),h++;return f})),a}function kb(a,b){return b=pb(b),Array.prototype.sort.call(a,b),a}function lb(a,b){var c=Ka(a.length);return mb(c,a,b),c}function mb(a,b,c){var d=pb(c);a.sort((function(e,f){var h=d(b[e],b[f]);return 0<h||0===h&&e>f?1:-1}))}function nb(a,b){for(var c=b.length,d=[],e=0;e<c;e++){var f=b[e];(0>f||f>=c)&&Q(\"Out-of-bounds array idx\"),d[e]=a[f]}Xa(a,d)}function ob(a,b){var c=pb(b);return function(d,e){return c(d[a],e[a])}}function pb(a){return a=!1!==a,function(b,c){var d=0;return null==c?d=null==b?0:-1:null==b?d=1:b<c?d=a?-1:1:b>c?d=a?1:-1:b!=b?d=1:c!=c&&(d=-1),d}}function qb(a,b){return rb(a,0,a.length-1),!1===b&&Array.prototype.reverse.call(a),a}function rb(a,b,c){for(var f,h,d=b,e=c;d<c;){for(f=a[b+c>>1];d<=e;){for(;a[d]<f;)d++;for(;a[e]>f;)e--;d<=e&&(h=a[d],a[d]=a[e],a[e]=h,d++,e--)}b<e&&rb(a,b,e),b=d,e=c}}function sb(a,b){if(isNaN(b))return a.length;for(var c=1,d=0,e=a.length;d<e;d++)b>a[d]&&c++;return c}function tb(a,b){return ub(a,Math.ceil((1-b)*a.length))}function ub(a,b){(!a.length||1>b||b>a.length)&&Q(\"[findValueByRank()] invalid input\"),b=fa(0|b,1,a.length),--b;for(var e,f,h,g,c=0,d=a.length-1;c<d;){h=a[b],e=c,f=d;do{for(;a[e]<h;)e++;for(;h<a[f];)f--;e<=f&&(g=a[e],a[e]=a[f],a[f]=g,e++,f--)}while(e<=f);f<b&&(c=e),b<e&&(d=f)}return a[b]}function vb(a){var b=a.length,c=Math.floor(b/2)+1,d=ub(a,c);return 0==(1&b)&&(d=(d+ub(a,c-1))/2),d}function wb(a){for(var d,b=0,c=NaN,e=0,f=a.length;e<f;e++)d=a[e],isNaN(d)||(c=1==++b?d:d/b+(b-1)/b*c);return c}function xb(a){return yb(a).apply(null,Array.prototype.slice.call(arguments,1))}function yb(a){for(var b=/%([',+0]*)([1-9]?)((?:\\.[1-9])?)([sdifxX%])/g,c=[],d=[],e=0,f=\"\",h=b.exec(a);h;)e=a.substring(e,b.lastIndex-h[0].length),\"%%\"==h[0]?f+=e+\"%\":(c.push(f+e),f=\"\",d.push(h)),e=b.lastIndex,h=b.exec(a);return c.push(f+a.substr(e)),function(){var g=c[0],l=arguments.length;l!=d.length&&Q(\"[format()] Data does not match format string; format:\",a,\"data:\",arguments);for(var n=0;n<l;n++){var p=void 0,r=void 0,u=void 0,t=arguments[n],x=d[n],A=x[1],y=x[2],k=x[3]?parseInt(x[3].substr(1)):void 0,m=x[4],q=\"s\"==m,v=\"x\"==m||\"X\"==m,B=\"d\"==m||\"i\"==m,C=!q;x=\"\";var D=0,E=!1;q?u=String(t):v?(u=t.toString(16),\"X\"==m&&(u=u.toUpperCase())):C&&(\"-\"==(u=gb(t,B?0:k))[0]&&(E=!0,u=u.substr(1)),t=0==parseFloat(u),-1==A.indexOf(\"'\")&&-1==A.indexOf(\",\")||(u=fb(u)),t||(E?x=\"\":-1!=A.indexOf(\"+\")&&(x=\"+\"))),y&&(t=u.length+x.length)<(y=parseInt(y,10))&&(D=y-t,p=Ya(r=-1==A.indexOf(\"0\")?\" \":\"0\",D)),g+=(u=0==D?x+u:\"0\"==r?x+p+u:p+x+u)+c[n+1]}return g}}function zb(a){return a=a.split(\"*\").map((function(b){return va(b)})).join(\".*\"),new RegExp(\"^\"+a+\"$\")}function Ab(a,b){return na(a)?J.allocUnsafe?J.allocUnsafe(a):new J(a):J.from&&J.allocUnsafe?J.from(a,b):new J(a,b)}function Bb(a,b){var e,c=0,d=1<=b?b:1.2;return function(f){return f>c&&(c=Math.ceil(f*d),e=a?new a(c):Ab(c)),e}}function Cb(a,b,c,d,e,f){a===c&&d>b&&Q(\"copy error\");var h=1,g=0;for(f&&(h=-1,g=e-1),f=0;f<e;f++,g+=h)c[f+d]=a[b+g]}function Db(a,b,c){return c=c||a.length,b=new a.constructor(Math.max(a.length,b)),Cb(a,0,b,0,c),b}function Eb(a,b){var c;return a&&b&&(c=Fb(a,b).replace(/[-_]$/,\"\")),c||\"\"}function Fb(a,b){for(var c=0,d=a.length;c<d&&a[c]===b[c];c++);return a.substr(0,c)}function Gb(a){var b=0<(a=String(a)).indexOf(\"%\")?Number(a.replace(\"%\",\"\"))/100:Number(a);return 0<=b&&1>=b||R(xb(\"Invalid percentage: %s\",a)),b}function Hb(a,b){return b=String(b),/[0-9]$/.test(a)&&(b=\"-\"+b),a+b}function Ib(a,b){var c=Qa(a),d=b||Hb,e=[];return a.forEach((function(f){for(var l,h=0,g=f;-1<e.indexOf(g)||g==f&&1<c[g]||g!=f&&0<c[g];){if(h++,!(l=d(f,h))||l==g)throw Error(\"Naming error\");g=l}e.push(g)})),e}function Jb(a){return a||\"\"}function Kb(a){return Tc(a,Mb)}function Lb(a){return Tc(a,Uc)}function Tc(a,b){return b=(a=String(a).trim())?Number(b(a)):NaN,isNaN(b)?null:b}function Mb(a){return 0<a.indexOf(\",\")?a.replace(/,([0-9]{3})/g,\"$1\"):a}function Uc(a){return(a=a.replace(/[ .]([0-9]{3})/g,\"$1\")).replace(\",\",\".\")}function Nb(a){var b=a.length;if(2<=b){var c=a.charAt(0),d=a.charAt(b-1);if('\"'==c&&'\"'==d&&!a.includes('\",\"')||\"'\"==c&&\"'\"==d&&!a.includes(\"','\"))return a.substr(1,b-2)}return a}function Vc(){this.mx=this.my=1,this.bx=this.by=0}function U(){0<arguments.length&&this.setBounds.apply(this,arguments)}function Wc(a,b,c,d){return Xc(a,b,c,d).distance}function Xc(a,b,c,d){var e,f,h,g;if(c=d.getShapeIter(c),d=1/0,c.hasNext())var l=e=h=c.x,n=f=g=c.y;for(;c.hasNext();){var p=c.x,r=c.y,u=ac(a,b,l,n,p,r);u<d&&(d=u,e=l,f=n,h=p,g=r),l=p,n=r}return 1/0==d?{distance:1/0}:{segment:[[e,f],[h,g]],distance:Math.sqrt(d)}}function Yc(a,b){if(!(a=b.getShapeIter(a)).hasNext())return null;b=a.x;for(var c=a.y,d=0,e=0,f=0;a.hasNext();)d++,e+=a.x,f+=a.y;return 0!==d&&a.x===b&&a.y===c||(e+=b,f+=c,d++),{x:e/d,y:f/d}}function Zc(a,b){var c=0;return(a||[]).reduce((function(d,e){var f=b.getSimpleShapeBounds(e).area();return f>c&&(c=f,d=e),d}),null)}function bd(a,b){var h,g,c=b.getShapeIter(a),d=0,e=0,f=0;if(!c.hasNext())return null;var l=g=0,n=-c.x;for(h=-c.y;c.hasNext();){var p=g,r=l;g=c.x+n;var u=p*(l=c.y+h)-r*g;d+=u,e+=u*(p+g),f+=u*(r+l)}return 0==(c=d/2)?Yc(a,b):{x:e/(6*c)-n,y:f/(6*c)-h}}function dd(a){return 0<=a?a:~a}function fd(a,b){var c=new U;return gd(a,(function(d){b.mergeArcBounds(d,c)})),c}function hd(a,b,c,d){var e=0,f=-1;if(c>d){var h=c;c=d,d=h}for(h=c+1;h<d;h++)(c=a[h])<b&&c>e&&(f=h,e=c);return f}function gd(a,b){for(var c,d=0;d<a.length;d++)(c=a[d])instanceof Array?gd(c,b):w.isInteger(c)?void 0!==(c=b(c))&&(a[d]=c):c&&Q(\"Non-integer arc id in:\",a)}function kd(a,b,c,d){var e=!1,f=!1;return function id(a,b,c){for(var d=0,e=a.length;d<e;d++)b.forEachArcSegment(a[d],c)}(c,d,(function(h,g,l,n){1==(h=ld(a,b,l[h],n[h],l[g],n[g]))?e=!e:isNaN(h)&&(f=!0)})),f?-1:e?1:0}function ld(a,b,c,d,e,f){return(a=md(a,b,c,d,e,f))!=a?NaN:-1/0==a?0:1}function md(a,b,c,d,e,f){var h=-1/0;return a<c&&a<e||a>c&&a>e||b>d&&b>f||(a===c||a===e?a===c&&a===e?b!=d&&b!=f&&b>d==b>f||(h=NaN):a===c?b===d?h=NaN:e<c&&b<d&&(h=d):b===f?h=NaN:c<e&&b<f&&(h=f):(a=d+(a-c)*(f-d)/(e-c))>b?h=a:a==b&&(h=NaN)),h}function nd(a,b){return(b.isPlanar()?od:pd)(a,b)}function pd(a,b){return qd(a=b.getShapeIter(a))}function qd(a){for(var e,f,h,g,b=0,c=!1,d=Math.PI/180;a.hasNext();)e=a.x*d,f=Math.sin(a.y*d),c?b+=(e-h)*(2+f+g):c=!0,h=e,g=f;return b/2*40680631590769}function od(a,b){var c,d;if(a=b.getShapeIter(a),b=0,a.hasNext()){var e=c=0,f=-a.x;for(d=-a.y;a.hasNext();){var h=c,g=e;b+=(c=a.x+f)*g-h*(e=a.y+d)}}return b/2}function rd(a,b){return(b.isPlanar()?sd:td)(a,b)}function sd(a,b){return $c(a,b,!1)}function td(a,b){return $c(a,b,!0)}function vd(a,b){var c=function ed(a){var b=0;return a=a.forEachSegment((function(c,d,e,f){e=e[c]-e[d],c=f[c]-f[d],b+=Math.sqrt(e*e+c*c)})),b/a||0}(a),d=.0025*c;0<b&&(d=b,Nc(w.format(\"Applying snapping threshold of %s -- %.6f times avg. segment length\",b,b/c))),b=d;var e=0;if(c=a.getVertexData(),0<b){var f=c.xx,h=f.length;d=new Uint32Array(h);for(var g=0;g<h;g++)d[g]=g;for(wd(f,d,0,d.length-1),f=0,h=d.length;f<h;f++){for(var l,n,p=b,r=d,u=c.xx,t=c.yy,x=f,A=r.length,y=u[r[f]],k=t[r[f]],m=0;++x<A&&!((l=u[n=r[x]]-y)>p);)g=t[n]-k,0===l&&0===g||l*l+g*g>p*p||(u[n]=y,t[n]=k,m++);e+=m}}0<(b=e)&&a.dedupCoords(),Nc(w.format(\"Snapped %s point%s\",b,w.pluralSuffix(b)))}function wd(a,b,c,d){if(24<d-c){for(var g,e=a[b[c+d>>1]],f=c,h=d;f<=h;){for(;a[b[f]]<e;)f++;for(;a[b[h]]>e;)h--;f<=h&&(g=b[f],b[f]=b[h],b[h]=g,f++,h--)}h>c&&wd(a,b,c,h),f<d&&wd(a,b,f,d)}else for(h=c+1;h<=d;h++){for(e=b[h],f=h-1;f>=c&&a[e]<a[b[f]];f--)b[f+1]=b[f];b[f+1]=e}}function xd(a,b,c,d,e,f,h,g){ac(c,d,e,f,h,g)>b||(e=z(e,f,c,d),h=z(h,g,c,d),e<=b||h<=b||a.push(c,d))}function yd(a,b,c,d,e,f){return(c=Sb(c,d,e,f))<b&&(b=c,a[0]=e,a[1]=f),b}function zd(a,b,c){return(b<c?a<b||a>c:b>c?a>b||a<c:a!=b)&&(a=Math.abs(a-b)<Math.abs(a-c)?b:c),a}function Ad(a,b,c,d,e,f){return(a-e)*(d-f)-(b-f)*(c-e)}function Bd(a,b,c,d,e,f,h,g){return 0>=Ad(a,b,c,d,e,f)*Ad(a,b,c,d,h,g)&&0>=Ad(e,f,h,g,a,b)*Ad(e,f,h,g,c,d)}function Dd(a){return[-180+(a=w.isFiniteNumber(a)?a:1e-10),-90+a,180-a,90-a]}function Ed(a){var b=Dd(-1);return a=a instanceof U?a.toArray():a,V.containsBounds(b,a)}function Hd(a,b){b=w.extend({},b);var e=a.getBounds();!a.isPlanar()&&V.containsBounds(Dd(),e.toArray());var f=e.ymin,h=e.ymax-f,g=b.stripes||function Id(a){return a=a.getFilteredPointCount()-a.size(),0<(a=Math.ceil(Math.pow(10*a,.6)/40))?a:1}(a),l=new Uint32Array(g),n=1<g&&0<h?function c(y){return Math.floor((g-1)*(y-f)/h)}:function d(){return 0};0==0<=b.tolerance&&(b.tolerance=1e-14*Math.max.apply(null,e.toArray().map(Math.abs))),a.forEachSegment((function(y,k,m,q){for(y=n(q[y]),k=n(q[k]);l[y]+=2,y!=k;)y+=k>y?1:-1}));var p=function Gd(a){var b=4*a;return(!Fd||Fd.byteLength<b)&&(Fd=new ArrayBuffer(b)),new Uint32Array(Fd,0,a)}(w.sum(l)),r=0,u=[];w.forEach(l,(function(y){var k=r;r+=y,u.push(p.subarray(k,r))})),w.initializeArray(l,0),a.forEachSegment((function(y,k,m,q){m=n(q[y]),q=n(q[k]);for(var v,B;v=l[m],l[m]=v+2,(B=u[m])[v]=y,B[v+1]=k,m!=q;)m+=q>m?1:-1}));var t=a.getVertexData(),x=[];for(a=0;a<g;a++){var A=Jd(u[a],t.xx,t.yy,b);for(e=0;e<A.length;e++)x.push(A[e])}return function Kd(a,b){var c={},d=b||Md;return a.filter((function(e){return!((e=d(e))in c)&&(c[e]=!0)}))}(x,b.unique?Ld:null)}function Md(a){return a.a.join(\",\")+\";\"+a.b.join(\",\")}function Ld(a){return a.x+\",\"+a.y}function Jd(a,b,c,d){var h,g,l,e=a.length-2,f=[];d=(d||{}).tolerance;var n=0;for(h=a.length;n<h;n+=2)if(b[a[n]]>b[a[n+1]]){var p=n+1,r=a[n];a[n]=a[p],a[p]=r}for(Pb(b,a,0,a.length-2),g=0;g<e;){n=a[g],h=a[g+1],p=b[n],r=b[h];var u=c[n],t=c[h];for(l=g;l<e;){var x=a[l+=2],A=b[x];if(r<A)break;var y=c[x],k=a[l+1],m=b[k],q=c[k];if(u>=y){if(u>q&&t>y&&t>q)continue}else if(u<q&&t<y&&t<q)continue;n!=x&&n!=k&&h!=x&&h!=k&&(A=V.segmentIntersection(p,u,r,t,A,y,m,q,d))&&(m=[n,h],x=[x,k],f.push(Nd(A,m,x,b,c)),4==A.length&&f.push(Nd(A.slice(2),m,x,b,c)))}g+=2}return f}function Nd(a,b,c,d,e){var f=a[0];return b=Od(f,a=a[1],b[0],b[1],d,e),c=Od(f,a,c[0],c[1],d,e),{x:f,y:a,a:d=b[0]<c[0]?b:c,b:d==b?c:b}}function Od(a,b,c,d,e,f){return e[c]==a&&f[c]==b?[c,c]:e[d]==a&&f[d]==b?[d,d]:c<d?[c,d]:[d,c]}function Pd(a,b){var c=a.getVertexData(),d=0,e=0;for(b=Qd(b,a=a.getRetainedInterval(),c.zz),w.sortOn(b,\"z\",!0);0<b.length;){var f=b.pop(),h=a,g=c.xx,l=c.yy,n=c.zz,p=f,r=h,u=g,t=l,x=n,A=Rd(p.a,r,u,t,x);if(1==(h=Qd(g=Jd(A=A.concat(Rd(p.b,r,u,t,x)),g,l),h,n)).length){for(h=h[0],n=a,g=c.zz,l=[],p=h.a[0],r=h.a[1],u=h.z,t=p+1;t<=r;t++)g[t]!=u&&t!=r||(l.push({a:[p,t],b:h.b,z:u}),t!=r&&(g[t]=n),p=t);2>l.length&&Q(\"Error in unwindIntersection()\"),h=l,d++}for(n=0;n<h.length;n++){for(g=b,l=h[n],p=g.length;0<p&&!(g[p-1].z<=l.z);)g[p]=g[p-1],p--;g[p]=l}}return 5e5<++e?(Oc(\"Caught an infinite loop at intersection:\",f),0):d}function Qd(a,b,c){return a.reduce((function(d,e){var f=hd(c,b,e.a[0],e.a[1]),h=hd(c,b,e.b[0],e.b[1]);return null!==(e=-1==f&&-1==h?null:-1==h||-1!=f&&c[f]>c[h]?{a:e.a,b:e.b,z:c[f]}:{a:e.b,b:e.a,z:c[h]})&&d.push(e),d}),[])}function Rd(a,b,c,d,e){if(d=[],a[0]<=a[1]){var f=a[0];a=a[1]}else f=a[1],a=a[0];var h=f;for(f+=1;f<=a;f++)e[f]>=b&&(c[h]<c[f]?d.push(h,f):d.push(f,h),h=f);return d}function Sd(a){function b(t){for(var x=f(t);x>t;){var A=x,y=r[t];c(t,r[A]),c(A,y),x=f(t=x)}}function c(t,x){u[x]=t,r[t]=x}function f(t){var x=2*t+1,A=x+1,y=n;return x<y&&l(t,x)&&(t=x),A<y&&l(t,A)&&(t=A),t}var p,r,u,h=w.expandoBuffer(Int32Array),g=w.expandoBuffer(Int32Array),l=\"max\"==a?function e(t,x){return p[r[t]]<p[r[x]]}:function d(t,x){t=r[t],x=r[x];var A=p[t],y=p[x];return A>y||A===y&&t>x},n=0;this.init=function(t){for(p=t,n=t.length,r=h(n),u=g(n),t=0;t<n;t++)c(t,t);for(t=n-2>>1;0<=t;t--)b(t)},this.size=function(){return n},this.updateValue=function(t,x){var A=u[t];for(p[t]=x,0<=A&&A<n||Q(\"Out-of-range heap index.\"),t=A;0<t&&!l(t,x=t-1>>1);){A=x;var y=r[t];c(t,r[A]),c(A,y),t=x}b(t)},this.popValue=function(){return p[this.pop()]},this.getValue=function(t){return p[t]},this.peek=function(){return r[0]},this.peekValue=function(){return p[r[0]]},this.pop=function(){0>=n&&Q(\"Tried to pop from an empty heap.\");var t=r[0];return c(0,r[--n]),b(0),t}}function Xd(a,b,c){var d=a.getBounds().toArray();!0!==V.containsBounds(b,d)&&a.forEach3((function(e,f,h){for(var l,n,g=c?1/0:0,p=0,r=h.length;p<r;p++)if(l=e[p],n=f[p],l>=b[2]||l<=b[0]||n<=b[1]||n>=b[3]){if(0===g){n=l=0;for(var u=h.length;n<u;n++)(g=h[n])>l&&1/0>g&&(l=g);g=l}1/0!==h[p]&&(h[p]=g)}}))}function Yd(){throw\"deleted by simon\"}function ae(a){var d=new Yd({proj:\"+proj=aea +lon_0=-96 +lat_0=37.5 +lat_1=29.5 +lat_2=45.5\",bbox:[-129,23,-62,52]},a=a||{}).addFrame({name:\"AK\",proj:\"+proj=aea +lat_1=55 +lat_2=70 +lat_0=65 +lon_0=-148 +x_0=0 +y_0=0\",bbox:[-172.26,50.89,-127,73.21],origin:[-152,63],placement:[-1882782,-969242],scale:.37}).addFrame({name:\"HI\",proj:\"+proj=aea +lat_1=19 +lat_2=24 +lat_0=20.9 +lon_0=-156.5 +x_0=0 +y_0=0\",bbox:[-160.5,18.72,-154.57,22.58],origin:[-157,21],placement:[-1050326,-1055362]});return a.PR&&d.addFrame({name:\"PR\",proj:\"+proj=aea +lat_1=18 +lat_2=18.43 +lat_0=17.83 +lon_0=-66.43 +x_0=0 +y_0=0\",bbox:[-68.092,17.824,-65.151,18.787],origin:[-66.431,18.228],placement:[1993101,-1254517]}),a.VI&&d.addFrame({name:\"VI\",proj:\"+proj=aea +lat_1=18 +lat_2=18.43 +lat_0=17.83 +lon_0=-66.43 +x_0=0 +y_0=0\",bbox:[-65.104,17.665,-64.454,18.505],origin:[-66.431,18.228],placement:[1993101,-1254517]}),d}function ee(a,b){var c,d,e=0;for(c=a.length;e<c;e++){var f=a[e],h=0;for(d=f?f.length:0;h<d;h++)b(f[h],e)}}function fe(a){return a?a.map((function(b){return b.concat()})):null}function ke(a){var c,b={};if(!a)return null;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];d==a&&delete(d=w.extend({},d))[c],b[c]=d&&d.constructor===Object?ke(d):d}return b}function ne(a){if(w.isArray(a))var b=a;else if(b=[],w.isInteger(a))for(var c=0;c<a;c++)b.push({});else a&&Q(\"Invalid DataTable constructor argument:\",a);this.getRecords=function(){return b},this.getReadOnlyRecordAt=function(d){return ke(b[d])}}function oe(a){return(\"polygon\"==a.geometry_type||\"polyline\"==a.geometry_type)&&pe(a)}function qe(a){return\"point\"==a.geometry_type&&pe(a)}function pe(a){return w.some(a.shapes||[],(function(b){return!!b}))}function te(a){return(a=ue(a)).data&&(a.data=a.data.clone()),a}function ue(a){var b=w.extend({},a);return a.shapes&&(a=a.shapes,a=w.isArray(a)?a.map(fe):null,b.shapes=a),b}function ve(a){var b=new ArrayBuffer(16),c=new Float64Array(b),d=new Uint32Array(b),e=0|a;if(0==0<e)throw Error(\"Invalid size param: \"+a);return function(f,h){return c[0]=f,c[1]=h,(2147483647&(f=(f=d[0]^d[1])<<5^f>>7^d[2]^d[3]))%e}}function xe(a,b){this._n=this._i=0,this._inc=1,this._xx=a,this._yy=b,this.y=this.x=this.i=0}function ye(a,b,c){var d=0,e=0,f=1,h=0;this.init=function(g,l,n,p){return d=p||0,n?(e=g,f=1,h=g+l):(e=g+l-1,f=-1,h=g-1),this},this.hasNext=function(){var g=e,l=g,n=d,p=h,r=f;if(g==p)return!1;do{l+=r}while(l!=p&&c[l]<n);return e=l,this.x=a[g],this.y=b[g],this.i=g,!0}}function ze(a){this._arcs=a,this.y=this.x=this._n=this._i=0}function Ae(){function a(k){var m=[],q=[];b(k=k.map((function(v){for(var B=v?v.length:0,C=0;C<B;C++)m.push(v[C][0]),q.push(v[C][1]);return B})),m,q)}function b(k,m,q){var v=k.length;for(k instanceof Array&&(k=new Uint32Array(k)),m instanceof Array&&(m=new Float64Array(m)),q instanceof Array&&(q=new Float64Array(q)),g=m,l=q,p=k,r=null,u=0,y=null,n=new Uint32Array(v),q=m=0;q<v;q++)n[q]=m,m+=k[q];return m==g.length&&g.length==l.length||Q(\"ArcCollection#initXYData() Counting error\"),d(),A=new xe(g,l),this}function c(k){k?(k.length!=g.length&&Q(\"ArcCollection#initZData() mismatched arrays\"),k instanceof Array&&(k=new Float64Array(k)),y=new ye(g,l,r=k)):(r=null,u=0,y=null)}function d(){for(var E,G,H,k=g,m=l,q=p,v=q.length,B=new Float64Array(4*v),C=new U,D=0,K=0;K<v;K++)if(0<(E=q[K])){G=4*K;var L=H=void 0,N=void 0,Z=void 0,W=k,la=m,S=E,T=0|D,ba=isNaN(S)?W.length-T:S+T;for(0<ba&&(Z=L=W[T],N=H=la[T]),T++;T<ba;T++){var Ja=W[T];Ja<Z&&(Z=Ja),Ja>L&&(L=Ja),(S=la[T])<N&&(N=S),S>H&&(H=S)}H=[Z,N,L,H],B[G++]=H[0],B[G++]=H[1],B[G++]=H[2],B[G]=H[3],D+=E,C.mergeBounds(H)}t=B,x=C}function e(){var k=r,m=u;if(!k||!m)return this.getPointCount();for(var q=0,v=0,B=k.length;v<B;v++)k[v]>=m&&q++;return q}function f(){var k=e(),m=p.length,q=new Float64Array(k),v=new Float64Array(k);k=new Float64Array(k);for(var E,G,B=new Int32Array(m),C=0,D=0,H=0;H<m;H++){for(G=0,E=C+(E=p[H]);C<E;C++)r[C]>=u&&(q[D]=g[C],v[D]=l[C],k[D]=r[C],D++,G++);1==G&&Q(\"Collapsed arc\"),B[H]=G}return{xx:q,yy:v,zz:k,nn:B}}function h(k,m){var q=new Float64Array(m),v=0;return k.forEach((function(B){for(var C=0,D=B.length;C<D;v++,C++)q[v]=B[C]})),v!=m&&Q(\"Mismatched thresholds\"),q}var g,l,n,p,r,t,x,A,y,u=0;1==arguments.length?a(arguments[0]):3==arguments.length?b.apply(this,arguments):Q(\"ArcCollection() Invalid arguments\"),this.updateVertexData=function(k,m,q,v){b(k,m,q),c(v||null)},this.getVertexData=function(){return{xx:g,yy:l,zz:r,bb:t,nn:p,ii:n}},this.getCopy=function(){var k=new Ae(new Int32Array(p),new Float64Array(g),new Float64Array(l));return r&&(k.setThresholds(new Float64Array(r)),k.setRetainedInterval(u)),k},this.getFilteredCopy=function(){if(!r||0===u)return this.getCopy();var k=f(),m=new Ae(k.nn,k.xx,k.yy);return m.setThresholds(k.zz),m},this.toArray=function(){var k=[];return this.forEach((function(m){for(var q=[];m.hasNext();)q.push([m.x,m.y]);k.push(q)})),k},this.toJSON=function(){return this.toArray()},this.forEachArcSegment=function(k,m){var q=0<=k,v=q?k:~k;k=this.getRetainedInterval();var B=p[v],C=q?1:-1;v=q=q?n[v]:n[v]+B-1;for(var D=g,E=l,G=r,H=0,K=1;K<B;K++)v+=C,(0===k||G[v]>=k)&&(m(q,v,D,E),q=v,H++);return H},this.forEachSegment=function(k){for(var m=0,q=0,v=this.size();q<v;q++)m+=this.forEachArcSegment(q,k);return m},this.transformPoints=function(k){for(var C,m=g,q=l,v=-1,B=0,D=0,E=m.length;D<E;D++,B--){for(;0===B;)B=p[++v];(C=k(m[D],q[D],v))&&(m[D]=C[0],q[D]=C[1])}d()},this.forEach=function(k){for(var m=0,q=this.size();m<q;m++)k(this.getArcIter(m),m)},this.forEach2=function(k){for(var m=0,q=this.size();m<q;m++)k(n[m],p[m],g,l,r,m)},this.forEach3=function(k){for(var m,q,v,B,C,D=0,E=this.size();D<E;D++)q=(m=n[D])+p[D],v=g.subarray(m,q),B=l.subarray(m,q),r&&(C=r.subarray(m,q)),k(v,B,C,D)},this.filter=function(k){var m=function(q){return k(this.getArcIter(q),q)}.bind(this);return this.deleteArcs(m)},this.deleteArcs=function(k){for(var m=this.size(),q=new Int32Array(m),v=0,B=0;B<m;B++)k(B)?q[B]=v++:q[B]=-1;if(v<m){m=k=0,v=w.copyElements;for(var C,D=0,E=q.length;D<E;D++)B=q[D],C=p[D],-1<B&&(v(g,n[D],g,k,C),v(l,n[D],l,k,C),r&&v(r,n[D],r,k,C),p[B]=C,k+=C,m++);b(p.subarray(0,m),g.subarray(0,k),l.subarray(0,k)),r&&c(r.subarray(0,k))}return q},this.dedupCoords=function(){for(var C,D,k=0,m=0,q=0,v=this.size(),B=r;k<v;){for(var E,H,K,G=void 0,L=m,N=q,Z=C=p[k],W=g,la=l,S=B,T=0,ba=0;T<Z;)K=W[E=L+T],H=la[E],(D=K==K&&H==H&&(0===ba||K!=W[E-1]||H!=la[E-1]))&&(W[G=N+ba]=K,la[G]=H,ba++),S&&0<ba&&(D||S[E]>S[G])&&(S[G]=S[E]),T++;D=1<ba?ba:0,p[k]=D,m+=C,q+=D,k++}return m>q&&(b(p,g.subarray(0,q),l.subarray(0,q)),B&&c(B.subarray(0,q))),m-q},this.getVertex=function(k,m){return k=this.indexOfVertex(k,m),{x:g[k],y:l[k]}},this.indexOfVertex=function(k,m){var q=0>k?~k:k,v=p[q];return 0>m&&(m=v+m),q!=k&&(m=v-m-1),(0>m||m>=v)&&Q(\"[ArcCollection] out-of-range vertex id\"),n[q]+m},this.arcIsClosed=function(k){var m=this.indexOfVertex(k,0);return m!=(k=this.indexOfVertex(k,-1))&&g[m]==g[k]&&l[m]==l[k]},this.arcIsLollipop=function(k){if(2>=this.getArcLength(k)||!this.arcIsClosed(k))return!1;var m=this.indexOfVertex(k,1);return k=this.indexOfVertex(k,-2),g[m]==g[k]&&l[m]==l[k]},this.arcIsDegenerate=function(k){k=this.getArcIter(k);for(var q,v,m=0;k.hasNext();){if(0<m&&(q!=k.x||v!=k.y))return!1;q=k.x,v=k.y,m++}return!0},this.getArcLength=function(k){return p[dd(k)]},this.getArcIter=function(k){var m=0<=k,q=m?k:~k,v=r&&u?y:A;return q>=p.length&&Q(\"#getArcId() out-of-range arc id:\",k),v.init(n[q],p[q],m,u)},this.getShapeIter=function(k){return new ze(this).init(k)},this.setThresholds=function(k){var m=this.getPointCount(),q=null;return k&&(k.length==m?q=k:k.length==this.size()?q=h(k,m):Q(\"Invalid threshold data\")),c(q),this},this.flatten=function(){if(0<u){var k=f();this.updateVertexData(k.nn,k.xx,k.yy),u=0}else r=null},this.getRetainedInterval=function(){return u},this.setRetainedInterval=function(k){return u=k,this},this.getRetainedPct=function(){return this.getPctByThreshold(u)},this.setRetainedPct=function(k){if(1<=k)u=0;else{var m=u=this.getThresholdByPct(k);0>=k?m=1/0:1<=k&&(m=0),u=m}return this},this.getRemovableThresholds=function(k){r||Q(\"[arcs] Missing simplification data.\"),k|=1;for(var q,m=new Float64Array(Math.ceil(r.length/k)),v=0,B=0,C=this.getPointCount();v<C;v+=k)1/0!=(q=r[v])&&(m[B++]=q);return m.subarray(0,B)},this.getArcThresholds=function(k){0<=k&&k<this.size()||Q(\"[arcs] Invalid arc id:\",k);var m=n[k];return r.subarray(m,m+p[k])},this.getPctByThreshold=function(k,m){return 0<k?(m=this.getRemovableThresholds(m),k=w.findRankByValue(m,k),k=0<m.length?1-(k-1)/m.length:1):k=1,k},this.getThresholdByPct=function(k,m){var q=(m=this.getRemovableThresholds(m)).length;return 1>(k=0===q||1<=k?0:0>=k?q+1:Math.floor((1-k)*(q+2)))?0:k>m.length?1/0:w.findValueByRank(m,k)},this.arcIntersectsBBox=function(k,m){var q=t;return q[k*=4]<=m[2]&&q[k+2]>=m[0]&&q[k+3]>=m[1]&&q[k+1]<=m[3]},this.arcIsContained=function(k,m){var q=t;return q[k*=4]>=m[0]&&q[k+2]<=m[2]&&q[k+1]>=m[1]&&q[k+3]<=m[3]},this.arcIsSmaller=function(k,m){var q=t;return q[2+(k*=4)]-q[k]<m&&q[k+3]-q[k+1]<m},this.isPlanar=function(){return!Ed(this.getBounds())},this.size=function(){return n&&n.length||0},this.getPointCount=function(){return g&&g.length||0},this.getFilteredPointCount=e,this.getBounds=function(){return x.clone()},this.getSimpleShapeBounds=function(k,m){m=m||new U;for(var q=0,v=k.length;q<v;q++)this.mergeArcBounds(k[q],m);return m},this.getSimpleShapeBounds2=function(k,m){m=m||[];var q=t,v=4*dd(k[0]);m[0]=q[v],m[1]=q[++v],m[2]=q[++v],m[3]=q[++v];for(var B=1,C=k.length;B<C;B++)q[v=4*dd(k[B])]<m[0]&&(m[0]=q[v]),q[++v]<m[1]&&(m[1]=q[v]),q[++v]>m[2]&&(m[2]=q[v]),q[++v]>m[3]&&(m[3]=q[v]);return m},this.getMultiShapeBounds=function(k,m){if(m=m||new U,k)for(var q=0,v=k.length;q<v;q++)this.getSimpleShapeBounds(k[q],m);return m},this.mergeArcBounds=function(k,m){0>k&&(k=~k),k*=4,m.mergeBounds(t[k],t[k+1],t[k+2],t[k+3])}}function Ge(a){if(a=function Fe(a){var c,b=require(\"mproj\");return a=a.replace(/(^| )([\\w]+)($| )/,(function(d,e,f,h){return f in b.internal.pj_list?e+\"+proj=\"+f+h:d})),(c=/^(\\+[^ ]+ *)+$/.test(a)?a:a in Ee?Ee[a]:/^(esri|epsg|nad83|nad27):[0-9]+$/i.test(String(a))?\"+init=\"+a.toLowerCase():a in Ic.defs?Ic.defs[a]:function Zd(a){var b=[],c=(a=a.trim().split(/ +/).filter((function(e){return!/^\\+/.test(e)||(b.push(e.substr(1)),!1)})))[0],d=function $d(a){var b={};return a.forEach((function(c){!function be(a,b){var c=(a=a.split(\"=\"))[0].split(\".\"),d=c.pop();b=c.reduce((function(e,f){if(0==f in e)e[f]={};else if(!w.isObject(e[f]))return{};return e[f]}),b),1<a.length?b[d]=function ce(a){var b;return 0<a.indexOf(\",\")?b=a.split(\",\").map(parseFloat):(null===(b=w.parseNumber(a))&&(b=a),b)}(a[1]):0!=d in b||c.length||(b[d]={})}(c,b)})),b}(b);return 1!=a.length?null:a=\"albersusa\"==c?new ae(d):null}(a))||R(\"Unknown projection definition:\",a),c}(a),w.isString(a))try{var b=require(\"mproj\").pj_init(a)}catch(c){R(\"Unable to use projection\",a,\"(\"+c.message+\")\")}else b=a;return b||null}function He(a){var b=a.info||{},c=b.crs;if(!c&&b.prj){b=b.prj;try{var d=require(\"mproj\").internal.wkt_to_proj4(b)}catch(e){R(\"Unusable .prj file (\"+e.message+\")\")}c=Ge(d)}return!c&&Ed(function Ce(a){var b=new U;return a.layers.forEach((function(c){var d=a.arcs,e=null;\"point\"==c.geometry_type?e=function de(a){var b=new U;return ee(a,(function(c){b.mergePoint(c[0],c[1])})),b}(c.shapes):\"polygon\"!=c.geometry_type&&\"polyline\"!=c.geometry_type||(e=fd(c.shapes,d)),(c=e)&&b.mergeBounds(c)})),b}(a))&&(c=Ge(\"wgs84\")),c}function Le(a,b,c){return function ge(a,b){if(!a)return null;w.isArray(a)||Q(\"Expected an array, received:\",a);for(var e,c=0,d=a.length,f=0;f<d;f++)null===(e=b(a[f],f,a))?(c++,a[f]=null):w.isArray(e)&&(a[f]=e);return c==d?null:0<c?a.filter((function(h){return!!h})):a}(a,(function(d){return d=function Me(a,b){for(var c=0,d=0,e=a.length;d<e;d++)b.arcIsDegenerate(a[d])&&(c++,a[d]=null);return 0<c?a.filter((function(f){return null!==f})):a}(d,b),\"polygon\"==c&&d&&(Ne(d),0===V.getPlanarPathArea(d,b)&&(d=null)),d}))}function Ne(a){var b=a.length;if(2<=b){if(a[0]==~a[b-1])a.pop(),a.shift();else for(var c=1;c<b;c++)if(a[c-1]==~a[c]){a.splice(c-1,2);break}a.length<b&&Ne(a)}}function Oe(a){w.isNumber(a)&&0!==a||Q(\"Rounding increment must be a non-zero number.\");var b=1/a;return 1<b&&(b=Math.round(b)),function(c){return Math.round(c*b)/b}}function Re(a){return-1e38<a[0]&&-1e38<a[1]}function Se(a){var b=1e4,c=new Float64Array(b),d=new Float64Array(b),e=0;this.endPath=function(){a(c,d,e),e=0},this.addPoint=function(f,h){e>=b&&(b=Math.ceil(1.3*b),c=w.extendBuffer(c,b),d=w.extendBuffer(d,b)),c[e]=f,d[e]=h,e++}}function Te(a){function b(m){var q=x<p.length?p[x]:null;q?q!=m&&R(\"Unable to import mixed-geometry GeoJSON features\"):(p[x]=m,r?m!=r&&(r=\"mixed\"):r=m)}function c(m){m>f.length&&(m=Math.max(m,Math.ceil(1.5*f.length)),f=w.extendBuffer(f,m,A),h=w.extendBuffer(h,m,A))}function d(m){(g[x]||(g[x]=[])).push(m)}var e=0<a.reserved_points?a.reserved_points:2e4,f=new Float64Array(e),h=new Float64Array(e),g=[],l=[],n=[],p=[],r=a.type||null,u=null,t=-1,x=-1,A=0,y=0,k=0;a.precision&&(u=Oe(a.precision)),w.extend(this,new Se((function(m,q,v){var B=0;c(A+v);for(var C=0;C<v;C++){var D=m[C],E=q[C];u&&(D=u(D),E=u(E)),0<C&&D==H&&E==G?y++:(f[A]=D,h[A]=E,A++,B++);var G=E,H=D}\"polygon\"==r&&0<B&&(m[0]!=m[v-1]||q[0]!=q[v-1])&&(c(A+1),f[A]=m[0],h[A]=q[0],k++,A++,B++),t++,n[t]=B,d([t])}))),this.startShape=function(m){g[++x]=null,m&&(l[x]=m)},this.importLine=function(m){2>m.length?Oc(\"Skipping a defective line\"):(b(\"polyline\"),this.importPath(m))},this.importPoints=function(m){b(\"point\"),m=m.filter(Re),u&&m.forEach((function(q){q[0]=u(q[0]),q[1]=u(q[1])})),m.forEach(d)},this.importRing=function(m,q){var v=V.getPlanarPathArea2(m);!v||4>m.length?Oc(\"Skipping a defective ring\"):(b(\"polygon\"),(!0===q&&0<v||!1===q&&0>v)&&m.reverse(),this.importPath(m))},this.importPath=function(m){for(var q,v=0,B=m.length;v<B;v++)q=m[v],this.addPoint(q[0],q[1]);this.endPath()},this.done=function(){var m={name:\"\"};if(0<y&&Oc(w.format(\"Removed %,d duplicate point%s\",y,w.pluralSuffix(y))),0<k&&Nc(w.format(\"Closed %,d open polygon ring%s\",k,w.pluralSuffix(k))),0<A){A<f.length&&(f=f.subarray(0,A),h=h.subarray(0,A));var q=new Ae(n,f,h)}return\"mixed\"==r?m=function se(a,b,c){return w.uniq(c).map((function(d){for(var g,e=[],f=[],h=0,l=0,n=a.length;l<n;l++)c[l]==d&&(d&&f.push(a[l]),g=b[l],e.push(g),g||h++);return{geometry_type:d,shapes:f,data:h<f.length?new ne(e):null}}))}(g,l,p):(m={geometry_type:r},r&&(m.shapes=g),0<l.length&&(m.data=new ne(l)),m=[m]),m.forEach((function(v){if(v.data){var C,D,B=function le(a){var c,d,b={};for(c=0;c<a.length;c++){var e=Object.keys(a[c]||{});for(d=0;d<e.length;d++)b[e[d]]=1+(0|b[e[d]])}return Object.keys(b).filter((function(f){return b[f]<a.length}))}(v=v.data.getRecords());for(C=0;C<v.length;C++){var E=v[C]||(v[C]={});for(D=0;D<B.length;D++){var G=B[D];0==G in E&&(E[G]=void 0)}}}})),{arcs:q||null,info:{},layers:m}}}function Ue(a){var b=a.id_field||Y.ID_FIELD,c=new Te(a);this.parseObject=function(d){if(d&&d.type)if(\"Feature\"==d.type){var e=d.geometry,f=d.properties||{};\"id\"in d&&(f[b]=d.id)}else e=d;else e=null;c.startShape(f),e&&Y.importGeometry(e,c,a)},this.done=function(){return c.done()}}function Ye(a,b,c){if(\"point\"==c)return function Xe(a){return a&&0!==a.length?{bounds:(a={points:a,pointCount:a.length,bounds:V.getPathBounds(a)}).bounds,pathData:[a],partCount:1,pointCount:a.pointCount}:{partCount:0,pointCount:0}}(a);var d=0,e=new U,f=[];return!a||\"polyline\"!=c&&\"polygon\"!=c||a.forEach((function(h){for(var p,r,u,t,g=b.getShapeIter(h),l=[],n=0;g.hasNext();)p=g.x,r=g.y,0!==n&&u==p&&t==r||(l.push([p,r]),n++),u=p,t=r;g={points:l,pointCount:l.length},l=!0,g.ids=h,\"polygon\"==c?(g.area=V.getPlanarPathArea2(g.points),l=3<g.pointCount&&0!==g.area):\"polyline\"==c&&(l=1<g.pointCount),l?(d+=g.pointCount,g.bounds=V.getPathBounds(g.points),e.mergeBounds(g.bounds),f.push(g)):Oc(\"Skipping a collapsed\",c,\"path\")})),{pointCount:d,pathData:f,pathCount:f.length,bounds:e}}function Ze(a){return JSON.stringify(a).replace(/\\n/g,\"\\n\").replace(/\\r/g,\"\\r\")}function af(a){function b(g,l,n,p,r){r=r(n);var t,x,A,u=c(g[n],l[n]);for(u=d[u];-1!=u;){if(t=f[u][0],x=f[u][1],A=t.length,t[0]===g[p]&&t[A-1]===g[n]&&t[A-2]===g[r]&&x[0]===l[p]&&x[A-1]===l[n]&&x[A-2]===l[r])return u;u=e[u]}return null}var c=ve(a=Math.floor(.25*a+1)),d=new Int32Array(a),e=[],f=[],h=0;w.initializeArray(d,-1),this.addArc=function(g,l){var n=g.length-1;n=c(g[n],l[n]);var p=d[n],r=f.length;return d[n]=r,f.push([g,l]),h+=g.length,e.push(p),r},this.findDuplicateArc=function(g,l,n,p,r,u){return null===(r=b(g,l,n,p,r))?b(g,l,p,n,u):~r},this.getVertexData=function(){for(var r,u,g=new Float64Array(h),l=new Float64Array(h),n=new Uint32Array(f.length),p=0,t=0,x=f.length;t<x;t++)u=(r=f[t])[0].length,w.copyElements(r[0],0,g,p,u),w.copyElements(r[1],0,l,p,u),n[t]=u,p+=u;return{xx:g,yy:l,nn:n}}}function bf(a){if(a.arcs){var b=a.arcs.getVertexData(),c=function cf(a,b,c){function d(y){var k=r[y],m=y+1;return m<n&&r[m]===k?y+1:f(y,y-(k=a[k])+1)?y-k+2:-1}function e(y){var k=r[y],m=y-1;return 0<=m&&r[m]===k?y-1:f(y,y+(k=a[k])-1)?y+k-2:-1}function f(y,k){return b[y]==b[k]&&c[y]==c[k]}function h(y){var k=p[y],m=e(y),q=d(y);if(-1==m||-1==q)return!0;for(;y!=k;){var C,v=e(k),B=d(k);if(!(C=-1==v||-1==B)){C=b[m];var D=b[q],E=b[v],G=b[B],H=c[m],K=c[q];v=c[v],B=c[B],C=!(C==G&&D==E&&H==B&&K==v||C==E&&D==G&&H==v&&K==B)}if(C)return!0;k=p[k]}return!1}function g(y,k,m,q,v){for(var B=new(b.subarray&&c.subarray?Float64Array:Array)(m-k+v-q+2),C=0;k<=m;k++)B[C++]=y[k];for(k=q;k<=v;k++)B[C++]=y[k];return B}function l(y,k){var m=u.findDuplicateArc(b,c,y,k,d,e);return null===m&&(m=u.addArc(t.call(b,y,k+1),t.call(c,y,k+1))),m}var n=b.length,p=function we(a,b){var h,c=a.length,d=Math.floor(1.3*c)||1,e=ve(d),f=new Int32Array(d);for(d=new Int32Array(c),h=0;h<c;h++){var g=a[h],l=b[h];g!=g||l!=l?l=-1:(l=f[g=e(g,l)]-1,f[g]=h+1),d[h]=0<=l?l:h}for(g=a.length-1;0<=g;g--)if(!((e=d[g])>=g)){f=g,h=-1;do{e=d[c=e],b[c]==b[g]&&a[c]==a[g]?(d[c]=f,f=c):(-1<h&&(d[h]=c),h=c)}while(e<c);-1<h&&(d[h]=h),d[g]=f}return d}(b,c),r=function ef(a,b){a=new Int32Array(a);for(var c=0,d=0,e=b.length;d<e;d++)for(var f=0,h=b[d];f<h;f++,c++)a[c]=d;return a}(n,a),u=new af(n),t=b.subarray&&c.subarray?b.subarray:Array.prototype.slice,x=function(y){for(var q,k=[],m=0,v=0,B=y.length;v<B;v++){q=y[v];var C=k,D=C.push;if(2>q)var E=null;else{var G=void 0,H=m,K=m+q-1;E=[];for(var L=-1,N=H;N<K;N++)h(N)&&(-1<L?E.push(l(G,N)):L=N,G=N);if(-1==L){var Z=(N=E).push;a:{for(L=H,H=K,G=p[L],K=r[L];G!=L&&!(r[G]<K);)G=p[G];if(G==L)H=l(L,H);else{for(G=L;G<H;G++)if(null!==(L=u.findDuplicateArc(b,c,G,G,d,e))){H=L;break a}Q(\"Unmatched ring; id:\",K,\"len:\",a[K]),H=void 0}}Z.call(N,H)}else if(L==H)h(K)||Q(\"Topology error\"),E.push(l(G,N));else{Z=(N=E).push,H+=1;var W=u.findDuplicateArc(b,c,G,L,d,e);null===W&&(W=u.addArc(g(b,G,K,H,L),g(c,G,K,H,L))),Z.call(N,W)}}D.call(C,E),m+=q}return k}(a),A=u.getVertexData();return A.paths=x,A}(b.nn,b.xx,b.yy);a.arcs.updateVertexData(c.nn,c.xx,c.yy),a.layers.forEach((function(d){\"polyline\"!=d.geometry_type&&\"polygon\"!=d.geometry_type||(d.shapes=function df(a,b){return a.map((function(e){return function c(e,f){return e?e.map((function(h){return function d(e,f){return e.reduce((function(h,g){var l=dd(g);if(l=f[l]){if(0>g){(g=l=l.concat()).reverse();for(var n=0,p=g.length;n<p;n++)g[n]=~g[n]}for(g=0,n=l.length;g<n;g++)h.push(l[g])}return h}),[])}(h,f)})):null}(e,b)}))}(d.shapes,c.paths))}))}}function kf(a,b,c){var h,d={},e=a.layers,f=function pf(a,b){var c=b.geojson_type||\"\";return\"Feature\"==c||\"FeatureCollection\"==c||\"GeometryCollection\"!=c&&(c&&R(\"Unsupported GeoJSON type:\",b.geojson_type),w.some(a,(function(d){var e=d.data?d.data.getFields():[];return d=sf(e,b),e=!!tf(e,b),d||e})))}(e,b);return d.type=f?\"FeatureCollection\":\"GeometryCollection\",b.gj2008&&function qf(a,b){!(a=a.info||{}).crs&&\"input_geojson_crs\"in a&&(b.crs=a.input_geojson_crs)}(a,d),b.bbox&&(h=function of(a,b){var c=He(a);b=b&&c&&(c&&c.is_latlong||!1);var f,d=new U,e=new U;return a.layers.forEach((function(h){oe(h)?function jd(a,b,c,d){var e=0;a.forEach((function(f,h){if(f&&0!==f.length){d&&d(h);for(var g=0,l=f.length;g<l;g++){var n=f[g];if(c&&c({i:g,shapeId:h,shape:f,arcs:n}),b)for(var p=0,r=n.length;p<r;p++,e++){var u=n[p];b({i:p,shapeId:h,partId:g,arcId:u,segId:e})}}}}))}(h.shapes,null,(function(g){(0>(g=a.arcs.getSimpleShapeBounds(g.arcs)).centerX()?d:e).mergeBounds(g)})):qe(h)&&ee(h.shapes,(function(g){(0>g[0]?d:e).mergePoint(g[0],g[1])}))})),(c=(new U).mergeBounds(e).mergeBounds(d)).hasBounds()&&(f=c.toArray()),b&&e.hasBounds()&&d.hasBounds()&&(b=e.xmin-d.xmax,c=360+d.xmin-e.xmax,0<b&&b>c&&(f[0]=e.xmin,f[2]=d.xmax)),f||null}(a,b.rfc7946||b.v2))&&(d.bbox=h),e=e.reduce((function(g,l){return l=function lf(a,b,c,d,e){var f=function mf(a,b){var c=a?a.getFields():[],d=tf(c,b);return sf(c,b)?(a=a.getRecords(),d==Y.ID_FIELD?a.map((function(e){return delete(e=w.extend({},e))[d],e})):a):null}(a.data,c),h=a.shapes,g=function nf(a,b){var d=tf(a?a.getFields():[],b);return d?a.getRecords().map((function(e){return d in e?e[d]:null})):null}(a.data,c),l=c.ndjson?Ze:c.prettify?function $e(a){function b(e,f){return e in c&&w.isArray(f)&&(e=JSON.stringify(f)).indexOf(!1)?\"\"+e.replace(/,/g,\", \")+\"\":f}var c=w.arrayToIndex(a),d=/\"\\u1000\\u2fd5\\u0310|\\u1000\\u2fd5\\u0310\"/g;return function(e){return JSON.stringify(e,b,\"  \").replace(d,\"\")}}([\"bbox\",\"coordinates\"]):JSON.stringify;return f&&h&&f.length!==h.length&&Q(\"Mismatch between number of properties and number of shapes\"),(h||f||[]).reduce((function(n,p,r){p=h?h[r]:null;var u=Y.exporters[a.geometry_type];if(p=p?u(p,b.arcs,c):null,d)p={type:\"Feature\",geometry:p,properties:f?f[r]:null},g&&(p.id=g[r]);else if(!p)return n;return e&&(p=l(p),\"buffer\"==e&&(r=p,p=/^utf-?8$/i.test(\"utf8\")?ie(r):iconv.encode(r,\"utf8\"))),n.push(p),n}),[])}(l,a,b,f,c),0<g.length?g.concat(l):l}),[]),\"Feature\"==b.geojson_type&&1==e.length?e[0]:b.ndjson?Y.formatCollectionAsNDJSON(e):c?Y.formatCollection(d,e):(d[rf(d.type)]=e,d)}function rf(a){return\"FeatureCollection\"==a?\"features\":\"GeometryCollection\"==a?\"geometries\":void Q(\"Invalid collection type:\",a)}function sf(a,b){return!(b.drop_table||b.cut_table||0===a.length||1==a.length&&a[0]==Y.ID_FIELD)}function tf(a,b){var c=[];return b=b.id_field,w.isString(b)?c.push(b):w.isArray(b)&&(c=b),c.push(Y.ID_FIELD),w.find(c,(function(d){return w.contains(a,d)}))}function preBuild(a){let b={snap:!0,no_repair:!1};var c=b||{},d=Object.keys(Y.pathImporters);return a=w.isString(a)?JSON.parse(a):a,c=new Ue(c),((d=\"Feature\"==a.type?{type:\"FeatureCollection\",features:[a]}:d.includes(a.type)?{type:\"GeometryCollection\",geometries:[a]}:a).features||d.geometries||[]).forEach(c.parseObject),d=c.done(),\"crs\"in a&&(d.info.input_geojson_crs=a.crs),d.info.import_options=b,function Qe(a,b){var d,c=a.arcs;(b.snap||b.auto_snap||b.snap_interval)&&(b.snap_interval&&(d=function Ke(a,b){var h,c=w.isString(a)?a:\"\",d=/(sq|)([a-z]+)(2|)$/i.exec(c);if(w.isNumber(a))c=a;else if(\"\"===c)c=NaN;else if(d){var e=Ie[d[2].toLowerCase()],f=!(!d[1]&&!d[3]);c=Number(c.substring(0,c.length-d[0].length)),e||isNaN(c)||R(\"Unknown units: \"+d[0])}else c=Number(c);isNaN(c)&&R(\"Invalid parameter:\",a),d=e;var g=0,l=0;return b&&(b.is_latlong?l=1:0<b.to_meter?l=b.to_meter:Q(\"Invalid CRS\")),d&&((g=Je[d])||Q(\"Unknown units:\",d)),g&&l?h=g/l:g||l?g&&!l?R(\"Unable to convert\",d,\"to unknown coordinates\"):!g&&l&&(h=1/l):h=1,e&&b&&b.is_latlong&&R(\"Parameter does not support distance units with latlong datasets\"),f&&R(\"Expected a distance, received an area:\",a),c*h}(b.snap_interval,He(a))),c&&vd(c,d)),a.layers.forEach((function(e){if(oe(e)){var f=e.shapes;e=e.geometry_type;for(var h=0,g=f.length;h<g;h++)f[h]=Le(f[h],c,e)}}))}(d,b),bf(d),d.info.input_files=[\"input.json\"],d.info.input_formats=[\"geojson\"],d}function simplify(a,b){(a=w.extend({},a)).layers=a.layers.map(te),a.arcs&&(a.arcs=a.arcs.getFilteredCopy());a:{var c={percentage:b,keep_shapes:!0,no_repair:!1,method:\"weighted_visvalingam\"};if((b=a.arcs)&&0!==b.size()){c=c||{};var d=c=w.defaults({method:\"weighted_visvalingam\",spherical:!c.planar&&!a.arcs.isPlanar()},c),e=X.getWeightedSimplifier(d,d.spherical);if(b.setThresholds(new Float64Array(b.getPointCount())),d.spherical?(function Wd(a,b){var c=w.expandoBuffer(Float64Array),d=w.expandoBuffer(Float64Array),e=w.expandoBuffer(Float64Array);a.forEach3((function(f,h,g){var l=f.length,n=c(l),p=d(l);l=e(l),V.convLngLatToSph(f,h,n,p,l),b(g,n,p,l)}))}(b,e),Xd(b,Dd(1e-12),!1)):function Vd(a,b){a.forEach3((function(c,d,e){b(e,c,d)}))}(b,e),d.lock_box&&((d=b.getBounds()).padBounds(-1e-14,-1e-14,-1e-14,-1e-14),Xd(b,d.toArray(),!0)),c.percentage||0===c.percentage)b.setRetainedPct(w.parsePercent(c.percentage));else if(!c.interval&&0!==c.interval&&!c.resolution&&c.presimplify)break a;if(b=a.arcs,c.keep_shapes&&function Td(a,b){b.forEach((function(c){\"polygon\"==c.geometry_type&&function Ud(a,b){b.forEach((function(c){for(var f,h,d=0,e=c?c.length:0,g=0;g<e;g++)(h=a.getSimpleShapeBounds(c[g]).area())>d&&(f=c[g],d=h);if(f&&0!==f.length){for(c=f,d=a.getRetainedInterval(),a.setRetainedInterval(1/0),e=V.getPlanarPathArea(c,a);1e-10>=e;){var l=void 0,n=c;f=0;for(var p=a.getVertexData(),r=0;r<n.length;r++)0>(g=n[r])&&(g=~g),h=(e=p.ii[g])+p.nn[g]-1,-1!=(e=hd(p.zz,1/0,e,h))&&(e=p.zz[e])>f&&(f=e,l=g);if(0<f){for(h=(e=p.ii[l])+p.nn[l]-1,g=p.zz,l=0;e<=h;e++)g[e]===f&&(g[e]=1/0,l++);e=l}else e=0;if(0===e){Oc(\"[protectMultiRing()] Failed on ring:\",c);break}e=V.getPlanarPathArea(c,a)}a.setRetainedInterval(d)}else Oc(\"[protectShape()] Invalid shape:\",c)}))}(a,c.shapes)}))}(b,a.layers),!c.no_repair&&0<b.getRetainedInterval()){for(c=d=Hd(b);0<Pd(b,c);)c=Hd(b);d=(b=d.length)>(c=c.length)?b-c:0,0<b&&(b=w.format(\"Repaired %'i intersection%s\",d,w.pluralSuffix(d)),0<c&&(b+=w.format(\"; %'i intersection%s could not be repaired\",c,w.pluralSuffix(c))),Nc(b))}}}return function hf(a,b){var d,c=(b=b||{}).extension||\"json\";return(b.precision||b.rfc7946)&&function Pe(a,b){var c=Oe(b);!function De(a,b){a.arcs&&a.arcs.transformPoints(b),a.layers.forEach((function(c){qe(c)&&function re(a,b){qe(a)&&ee(a.shapes,(function(c){var d=b(c[0],c[1]);c[0]=d[0],c[1]=d[1]}))}(c,b)}))}(a,(function(d,e){return[c(d),c(e)]}))}(a=function Be(a){return(a=w.extend({},a)).layers=a.layers.map(ue),a.arcs&&(a.arcs=a.arcs.getFilteredCopy()),a}(a),b.precision||1e-6),(b.v2||b.rfc7946)&&(d=function jf(a){if(!(a=He(a))||!a||!a.is_latlong){var b=\"RFC 7946 warning: non-WGS84 GeoJSON output.\";a&&(b+=' Tip: use \"-proj wgs84\" to convert.')}return b}(a))&&Nc(d),b.file&&(c=function gf(a){var b={filename:\"\",directory:\"\",basename:\"\",extension:\"\"},c=-1==a.indexOf(\"/\")&&-1!=a.indexOf(\"\\\\\")?\"\\\\\":\"/\",d=a.split(c),e=d.pop(),f=/\\.([a-z][a-z0-9]*)$/i;return(f=f.test(e)?f.exec(e)[0]:\"\")||e.includes(\"*\")?(b.filename=e,b.extension=f?f.slice(1):\"\",b.basename=e.slice(0,e.length-f.length),b.directory=d.join(c)):b.directory=e?a:d.join(c),b}(b.file).extension),(b.combine_layers?[a.layers]:a.layers.map((function(e){return[e]}))).map((function(e){var f=function ff(a){return a.reduce((function(b,c){return null===b?b=c.name||null:b&&c.name&&(b=w.mergeNames(b,c.name)),b}),null)||\"\"}(e)||\"output\";return{content:kf(e=w.defaults({layers:e},a),b),filename:f+\".\"+c}}))}(a,{})[0].content}var aa={},w=Object.freeze({__proto__:null,get default(){return w},get getUniqueName(){return ca},get isFunction(){return da},get isObject(){return ea},get clamp(){return fa},get isArray(){return ha},get isNumber(){return ia},get isValidNumber(){return ja},get isFiniteNumber(){return ka},get isNonNegNumber(){return ma},get isInteger(){return na},get isString(){return oa},get isDate(){return pa},get isBoolean(){return qa},get formatDateISO(){return ra},get toArray(){return sa},get isArrayLike(){return ta},get addslashes(){return ua},get regexEscape(){return va},get htmlEscape(){return wa},get defaults(){return xa},get extend(){return ya},get inherit(){return za},get reduceAsync(){return Aa},get merge(){return Ba},get difference(){return Ca},get intersection(){return Da},get indexOf(){return Ea},get contains(){return Fa},get some(){return Ga},get every(){return Ha},get find(){return Ia},get range(){return Ka},get repeat(){return La},get sum(){return Ma},get getArrayBounds(){return Na},get uniq(){return Oa},get pluck(){return Pa},get countValues(){return Qa},get indexOn(){return Ra},get groupBy(){return Sa},get arrayToIndex(){return Ta},get forEach(){return Ua},get forEachProperty(){return Va},get initializeArray(){return Wa},get replaceArray(){return Xa},get repeatString(){return Ya},get pluralSuffix(){return Za},get endsWith(){return $a},get lpad(){return ab},get rpad(){return bb},get trim(){return cb},get ltrim(){return db},get rtrim(){return eb},get addThousandsSep(){return fb},get numToStr(){return gb},get formatNumber(){return hb},get shuffle(){return ib},get sortOn(){return jb},get genericSort(){return kb},get getSortedIds(){return lb},get sortArrayIndex(){return mb},get reorderArray(){return nb},get getKeyComparator(){return ob},get getGenericComparator(){return pb},get quicksort(){return qb},get quicksortPartition(){return rb},get findRankByValue(){return sb},get findValueByPct(){return tb},get findValueByRank(){return ub},get findMedian(){return vb},get mean(){return wb},get format(){return xb},get formatter(){return yb},get wildcardToRegExp(){return zb},get createBuffer(){return Ab},get expandoBuffer(){return Bb},get copyElements(){return Cb},get extendBuffer(){return Db},get mergeNames(){return Eb},get findStringPrefix(){return Fb},get parsePercent(){return Gb},get formatVersionedName(){return Hb},get uniqifyNames(){return Ib},get parseString(){return Jb},get parseNumber(){return Kb},get parseIntlNumber(){return Lb},get cleanNumericString(){return Mb},get trimQuotes(){return Nb}}),Qb=Math.PI/180,bc=Object.freeze({__proto__:null,R:6378137,D2R:Qb,R2D:180/Math.PI,degreesToMeters:function(a){return a*Qb*6378137},distance3D:Rb,distanceSq:z,distance2D:Sb,distanceSq3D:Tb,innerAngle2:function(a,b,c,d,e,f){return(a=Math.abs(Math.atan2(b-d,a-c)-Math.atan2(f-d,e-c)))>Math.PI&&(a=2*Math.PI-a),a},standardAngle:Ub,signedAngle:function(a,b,c,d,e,f){return a==c&&b==d||c==e&&d==f?NaN:(a-=c,b-=d,c=e-c,d=f-d,Ub(Math.atan2(a*d-b*c,a*c+b*d)))},bearing2D:function(a,b,c,d){return(a=Math.PI/2-Math.atan2(d-b,c-a))>Math.PI?a-2*Math.PI:a},bearing:Vb,signedAngleSph:function(a,b,c,d,e,f){return a==c&&b==d||c==e&&d==f?NaN:(a=Vb(c,d,a,b),c=Vb(c,d,e,f),Ub(2*Math.PI+a-c))},convLngLatToSph:function(a,b,c,d,e){for(var f=[],h=0,g=a.length;h<g;h++)Wb(a[h],b[h],f),c[h]=f[0],d[h]=f[1],e[h]=f[2]},xyzToLngLat:function(a,b,c,d){var e=Rb(0,0,0,a,b,c);c=Math.asin(c/e)/Qb,d[0]=Math.atan2(b/e,a/e)/Qb,d[1]=c},lngLatToXYZ:Wb,sphericalDistance:Xb,greatCircleDistance:Yb,innerAngle:function(a,b,c,d,e,f){var h=Sb(a,b,c,d),g=Sb(c,d,e,f);return 0===h||0===g||(a=((a-c)*(e-c)+(b-d)*(f-d))/(h*g))>=1-1e-14?0:a<=1e-14-1?Math.PI:Math.acos(a)},innerAngle3D:function(a,b,c,d,e,f,h,g,l){var n=Rb(a,b,c,d,e,f),p=Rb(d,e,f,h,g,l);return 0===n||0===p||1<=(a=((a-d)*(h-d)+(b-e)*(g-e)+(c-f)*(l-f))/(n*p))?0:-1>=a?Math.PI:Math.acos(a)},triangleArea:function(a,b,c,d,e,f){return Math.abs(((b-f)*(c-e)+(d-f)*(e-a))/2)},cosine:function(a,b,c,d,e,f){var h=Sb(a,b,c,d)*Sb(c,d,e,f),g=0;return 0<h&&(1<(g=((a-c)*(e-c)+(b-d)*(f-d))/h)?g=1:-1>g&&(g=-1)),g},cosine3D:function(a,b,c,d,e,f,h,g,l){var n=Rb(a,b,c,d,e,f)*Rb(d,e,f,h,g,l),p=0;return 0<n&&(1<(p=((a-d)*(h-d)+(b-e)*(g-e)+(c-f)*(l-f))/n)?p=1:-1>p&&(p=-1)),p},triangleArea3D:function(a,b,c,d,e,f,h,g,l){return.5*Math.sqrt(Zb(a,b,d,e,h,g)+Zb(a,c,d,f,h,l)+Zb(b,c,e,f,g,l))},pointSegDistSq:function(a,b,c,d,e,f){return $b(z(a,b,c,d),a=z(a,b,e,f),c=z(c,d,e,f))},pointSegDistSq3D:function(a,b,c,d,e,f,h,g,l){return $b(Tb(a,b,c,d,e,f),a=Tb(a,b,c,h,g,l),d=Tb(d,e,f,h,g,l))},pointSegDistSq2:ac,containsBounds:function(a,b){return a[0]<=b[0]&&a[2]>=b[2]&&a[1]<=b[1]&&a[3]>=b[3]}}),F=[],I=[],cc=\"undefined\"!=typeof Uint8Array?Uint8Array:Array,dc=!1,ic={}.toString,jc=Array.isArray||function(a){return\"[object Array]\"==ic.call(a)};J.TYPED_ARRAY_SUPPORT=void 0===aa.TYPED_ARRAY_SUPPORT||aa.TYPED_ARRAY_SUPPORT,J.poolSize=8192,J._augment=function(a){return a.__proto__=J.prototype,a},J.from=function(a,b,c){return mc(null,a,b,c)},J.TYPED_ARRAY_SUPPORT&&(J.prototype.__proto__=Uint8Array.prototype,J.__proto__=Uint8Array),J.alloc=function(a,b,c){return qc(a),0>=a?kc(null,a):void 0!==b?\"string\"==typeof c?kc(null,a).fill(b,c):kc(null,a).fill(b):kc(null,a)},J.allocUnsafe=function(a){return lc(null,a)},J.allocUnsafeSlow=function(a){return lc(null,a)},J.isBuffer=function sc(a){return null!=a&&(!!a._isBuffer||Hc(a)||\"function\"==typeof a.readFloatLE&&\"function\"==typeof a.slice&&Hc(a.slice(0,0)))},J.compare=function(a,b){if(!M(a)||!M(b))throw new TypeError(\"Arguments must be Buffers\");if(a===b)return 0;for(var c=a.length,d=b.length,e=0,f=Math.min(c,d);e<f;++e)if(a[e]!==b[e]){c=a[e],d=b[e];break}return c<d?-1:d<c?1:0},J.isEncoding=function(a){switch(String(a).toLowerCase()){case\"hex\":case\"utf8\":case\"utf-8\":case\"ascii\":case\"latin1\":case\"binary\":case\"base64\":case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return!0;default:return!1}},J.concat=function(a,b){if(!jc(a))throw new TypeError('\"list\" argument must be an Array of Buffers');if(0===a.length)return J.alloc(0);var c;if(void 0===b)for(c=b=0;c<a.length;++c)b+=a[c].length;b=J.allocUnsafe(b);var d=0;for(c=0;c<a.length;++c){var e=a[c];if(!M(e))throw new TypeError('\"list\" argument must be an Array of Buffers');e.copy(b,d),d+=e.length}return b},J.byteLength=oc,J.prototype._isBuffer=!0,J.prototype.swap16=function(){var a=this.length;if(0!=a%2)throw new RangeError(\"Buffer size must be a multiple of 16-bits\");for(var b=0;b<a;b+=2)xc(this,b,b+1);return this},J.prototype.swap32=function(){var a=this.length;if(0!=a%4)throw new RangeError(\"Buffer size must be a multiple of 32-bits\");for(var b=0;b<a;b+=4)xc(this,b,b+3),xc(this,b+1,b+2);return this},J.prototype.swap64=function(){var a=this.length;if(0!=a%8)throw new RangeError(\"Buffer size must be a multiple of 64-bits\");for(var b=0;b<a;b+=8)xc(this,b,b+7),xc(this,b+1,b+6),xc(this,b+2,b+5),xc(this,b+3,b+4);return this},J.prototype.toString=function(){var a=0|this.length;return 0===a?\"\":0===arguments.length?wc(this,0,a):vc.apply(this,arguments)},J.prototype.equals=function(a){if(!M(a))throw new TypeError(\"Argument must be a Buffer\");return this===a||0===J.compare(this,a)},J.prototype.inspect=function(){var a=\"\";return 0<this.length&&(a=this.toString(\"hex\",0,50).match(/.{2}/g).join(\" \"),50<this.length&&(a+=\" ... \")),\"<Buffer \"+a+\">\"},J.prototype.compare=function(a,b,c,d,e){if(!M(a))throw new TypeError(\"Argument must be a Buffer\");if(void 0===b&&(b=0),void 0===c&&(c=a?a.length:0),void 0===d&&(d=0),void 0===e&&(e=this.length),0>b||c>a.length||0>d||e>this.length)throw new RangeError(\"out of range index\");if(d>=e&&b>=c)return 0;if(d>=e)return-1;if(b>=c)return 1;if(this===a)return 0;var f=(e>>>=0)-(d>>>=0),h=(c>>>=0)-(b>>>=0),g=Math.min(f,h);for(d=this.slice(d,e),a=a.slice(b,c),b=0;b<g;++b)if(d[b]!==a[b]){f=d[b],h=a[b];break}return f<h?-1:h<f?1:0},J.prototype.includes=function(a,b,c){return-1!==this.indexOf(a,b,c)},J.prototype.indexOf=function(a,b,c){return yc(this,a,b,c,!0)},J.prototype.lastIndexOf=function(a,b,c){return yc(this,a,b,c,!1)},J.prototype.write=function(a,b,c,d){if(void 0===b)d=\"utf8\",c=this.length,b=0;else if(void 0===c&&\"string\"==typeof b)d=b,c=this.length,b=0;else{if(!isFinite(b))throw Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");b|=0,isFinite(c)?(c|=0,void 0===d&&(d=\"utf8\")):(d=c,c=void 0)}var e=this.length-b;if((void 0===c||c>e)&&(c=e),0<a.length&&(0>c||0>b)||b>this.length)throw new RangeError(\"Attempt to write outside buffer bounds\");for(d||(d=\"utf8\"),e=!1;;)switch(d){case\"hex\":a:{if(b=Number(b)||0,d=this.length-b,c?(c=Number(c))>d&&(c=d):c=d,0!=(d=a.length)%2)throw new TypeError(\"Invalid hex string\");for(c>d/2&&(c=d/2),d=0;d<c;++d){if(e=parseInt(a.substr(2*d,2),16),isNaN(e)){a=d;break a}this[b+d]=e}a=d}return a;case\"utf8\":case\"utf-8\":return Ac(tc(a,this.length-b),this,b,c);case\"ascii\":return Ac(Bc(a),this,b,c);case\"latin1\":case\"binary\":return Ac(Bc(a),this,b,c);case\"base64\":return Ac(uc(a),this,b,c);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":d=a,e=this.length-b;for(var f=[],h=0;h<d.length&&!(0>(e-=2));++h){var g=d.charCodeAt(h);a=g>>8,g%=256,f.push(g),f.push(a)}return Ac(f,this,b,c);default:if(e)throw new TypeError(\"Unknown encoding: \"+d);d=(\"\"+d).toLowerCase(),e=!0}},J.prototype.toJSON=function(){return{type:\"Buffer\",data:Array.prototype.slice.call(this._arr||this,0)}};var Cc=4096;J.prototype.slice=function(a,b){var c=this.length;if(0>(a=~~a)?0>(a+=c)&&(a=0):a>c&&(a=c),0>(b=void 0===b?c:~~b)?0>(b+=c)&&(b=0):b>c&&(b=c),b<a&&(b=a),J.TYPED_ARRAY_SUPPORT)(b=this.subarray(a,b)).__proto__=J.prototype;else{b=new J(c=b-a,void 0);for(var d=0;d<c;++d)b[d]=this[d+a]}return b},J.prototype.readUIntLE=function(a,b,c){a|=0,b|=0,c||O(a,b,this.length),c=this[a];for(var d=1,e=0;++e<b&&(d*=256);)c+=this[a+e]*d;return c},J.prototype.readUIntBE=function(a,b,c){a|=0,b|=0,c||O(a,b,this.length),c=this[a+--b];for(var d=1;0<b&&(d*=256);)c+=this[a+--b]*d;return c},J.prototype.readUInt8=function(a,b){return b||O(a,1,this.length),this[a]},J.prototype.readUInt16LE=function(a,b){return b||O(a,2,this.length),this[a]|this[a+1]<<8},J.prototype.readUInt16BE=function(a,b){return b||O(a,2,this.length),this[a]<<8|this[a+1]},J.prototype.readUInt32LE=function(a,b){return b||O(a,4,this.length),(this[a]|this[a+1]<<8|this[a+2]<<16)+16777216*this[a+3]},J.prototype.readUInt32BE=function(a,b){return b||O(a,4,this.length),16777216*this[a]+(this[a+1]<<16|this[a+2]<<8|this[a+3])},J.prototype.readIntLE=function(a,b,c){a|=0,b|=0,c||O(a,b,this.length),c=this[a];for(var d=1,e=0;++e<b&&(d*=256);)c+=this[a+e]*d;return c>=128*d&&(c-=Math.pow(2,8*b)),c},J.prototype.readIntBE=function(a,b,c){a|=0,b|=0,c||O(a,b,this.length),c=b;for(var d=1,e=this[a+--c];0<c&&(d*=256);)e+=this[a+--c]*d;return e>=128*d&&(e-=Math.pow(2,8*b)),e},J.prototype.readInt8=function(a,b){return b||O(a,1,this.length),128&this[a]?-1*(255-this[a]+1):this[a]},J.prototype.readInt16LE=function(a,b){return b||O(a,2,this.length),32768&(a=this[a]|this[a+1]<<8)?4294901760|a:a},J.prototype.readInt16BE=function(a,b){return b||O(a,2,this.length),32768&(a=this[a+1]|this[a]<<8)?4294901760|a:a},J.prototype.readInt32LE=function(a,b){return b||O(a,4,this.length),this[a]|this[a+1]<<8|this[a+2]<<16|this[a+3]<<24},J.prototype.readInt32BE=function(a,b){return b||O(a,4,this.length),this[a]<<24|this[a+1]<<16|this[a+2]<<8|this[a+3]},J.prototype.readFloatLE=function(a,b){return b||O(a,4,this.length),gc(this,a,!0,23,4)},J.prototype.readFloatBE=function(a,b){return b||O(a,4,this.length),gc(this,a,!1,23,4)},J.prototype.readDoubleLE=function(a,b){return b||O(a,8,this.length),gc(this,a,!0,52,8)},J.prototype.readDoubleBE=function(a,b){return b||O(a,8,this.length),gc(this,a,!1,52,8)},J.prototype.writeUIntLE=function(a,b,c,d){a=+a,b|=0,c|=0,d||P(this,a,b,c,Math.pow(2,8*c)-1,0),d=1;var e=0;for(this[b]=255&a;++e<c&&(d*=256);)this[b+e]=a/d&255;return b+c},J.prototype.writeUIntBE=function(a,b,c,d){a=+a,b|=0,c|=0,d||P(this,a,b,c,Math.pow(2,8*c)-1,0);var e=1;for(this[b+(d=c-1)]=255&a;0<=--d&&(e*=256);)this[b+d]=a/e&255;return b+c},J.prototype.writeUInt8=function(a,b,c){return a=+a,b|=0,c||P(this,a,b,1,255,0),J.TYPED_ARRAY_SUPPORT||(a=Math.floor(a)),this[b]=255&a,b+1},J.prototype.writeUInt16LE=function(a,b,c){return a=+a,b|=0,c||P(this,a,b,2,65535,0),J.TYPED_ARRAY_SUPPORT?(this[b]=255&a,this[b+1]=a>>>8):Dc(this,a,b,!0),b+2},J.prototype.writeUInt16BE=function(a,b,c){return a=+a,b|=0,c||P(this,a,b,2,65535,0),J.TYPED_ARRAY_SUPPORT?(this[b]=a>>>8,this[b+1]=255&a):Dc(this,a,b,!1),b+2},J.prototype.writeUInt32LE=function(a,b,c){return a=+a,b|=0,c||P(this,a,b,4,4294967295,0),J.TYPED_ARRAY_SUPPORT?(this[b+3]=a>>>24,this[b+2]=a>>>16,this[b+1]=a>>>8,this[b]=255&a):Ec(this,a,b,!0),b+4},J.prototype.writeUInt32BE=function(a,b,c){return a=+a,b|=0,c||P(this,a,b,4,4294967295,0),J.TYPED_ARRAY_SUPPORT?(this[b]=a>>>24,this[b+1]=a>>>16,this[b+2]=a>>>8,this[b+3]=255&a):Ec(this,a,b,!1),b+4},J.prototype.writeIntLE=function(a,b,c,d){a=+a,b|=0,d||P(this,a,b,c,(d=Math.pow(2,8*c-1))-1,-d),d=0;var e=1,f=0;for(this[b]=255&a;++d<c&&(e*=256);)0>a&&0===f&&0!==this[b+d-1]&&(f=1),this[b+d]=(a/e>>0)-f&255;return b+c},J.prototype.writeIntBE=function(a,b,c,d){a=+a,b|=0,d||P(this,a,b,c,(d=Math.pow(2,8*c-1))-1,-d);var e=1,f=0;for(this[b+(d=c-1)]=255&a;0<=--d&&(e*=256);)0>a&&0===f&&0!==this[b+d+1]&&(f=1),this[b+d]=(a/e>>0)-f&255;return b+c},J.prototype.writeInt8=function(a,b,c){return a=+a,b|=0,c||P(this,a,b,1,127,-128),J.TYPED_ARRAY_SUPPORT||(a=Math.floor(a)),0>a&&(a=255+a+1),this[b]=255&a,b+1},J.prototype.writeInt16LE=function(a,b,c){return a=+a,b|=0,c||P(this,a,b,2,32767,-32768),J.TYPED_ARRAY_SUPPORT?(this[b]=255&a,this[b+1]=a>>>8):Dc(this,a,b,!0),b+2},J.prototype.writeInt16BE=function(a,b,c){return a=+a,b|=0,c||P(this,a,b,2,32767,-32768),J.TYPED_ARRAY_SUPPORT?(this[b]=a>>>8,this[b+1]=255&a):Dc(this,a,b,!1),b+2},J.prototype.writeInt32LE=function(a,b,c){return a=+a,b|=0,c||P(this,a,b,4,2147483647,-2147483648),J.TYPED_ARRAY_SUPPORT?(this[b]=255&a,this[b+1]=a>>>8,this[b+2]=a>>>16,this[b+3]=a>>>24):Ec(this,a,b,!0),b+4},J.prototype.writeInt32BE=function(a,b,c){return a=+a,b|=0,c||P(this,a,b,4,2147483647,-2147483648),0>a&&(a=4294967295+a+1),J.TYPED_ARRAY_SUPPORT?(this[b]=a>>>24,this[b+1]=a>>>16,this[b+2]=a>>>8,this[b+3]=255&a):Ec(this,a,b,!1),b+4},J.prototype.writeFloatLE=function(a,b,c){return c||Fc(this,0,b,4),hc(this,a,b,!0,23,4),b+4},J.prototype.writeFloatBE=function(a,b,c){return c||Fc(this,0,b,4),hc(this,a,b,!1,23,4),b+4},J.prototype.writeDoubleLE=function(a,b,c){return c||Fc(this,0,b,8),hc(this,a,b,!0,52,8),b+8},J.prototype.writeDoubleBE=function(a,b,c){return c||Fc(this,0,b,8),hc(this,a,b,!1,52,8),b+8},J.prototype.copy=function(a,b,c,d){if(c||(c=0),d||0===d||(d=this.length),b>=a.length&&(b=a.length),b||(b=0),0<d&&d<c&&(d=c),d===c||0===a.length||0===this.length)return 0;if(0>b)throw new RangeError(\"targetStart out of bounds\");if(0>c||c>=this.length)throw new RangeError(\"sourceStart out of bounds\");if(0>d)throw new RangeError(\"sourceEnd out of bounds\");d>this.length&&(d=this.length),a.length-b<d-c&&(d=a.length-b+c);var e=d-c;if(this===a&&c<b&&b<d)for(d=e-1;0<=d;--d)a[d+b]=this[d+c];else if(1e3>e||!J.TYPED_ARRAY_SUPPORT)for(d=0;d<e;++d)a[d+b]=this[d+c];else Uint8Array.prototype.set.call(a,this.subarray(c,c+e),b);return e},J.prototype.fill=function(a,b,c,d){if(\"string\"==typeof a){if(\"string\"==typeof b?(d=b,b=0,c=this.length):\"string\"==typeof c&&(d=c,c=this.length),1===a.length){var e=a.charCodeAt(0);256>e&&(a=e)}if(void 0!==d&&\"string\"!=typeof d)throw new TypeError(\"encoding must be a string\");if(\"string\"==typeof d&&!J.isEncoding(d))throw new TypeError(\"Unknown encoding: \"+d)}else\"number\"==typeof a&&(a&=255);if(0>b||this.length<b||this.length<c)throw new RangeError(\"Out of range index\");if(c<=b)return this;if(b>>>=0,c=void 0===c?this.length:c>>>0,a||(a=0),\"number\"==typeof a)for(d=b;d<c;++d)this[d]=a;else for(e=(a=M(a)?a:tc(new J(a,d).toString())).length,d=0;d<c-b;++d)this[d+b]=a[d%e];return this};var $c,Gc=/[^+\\/0-9A-Za-z-_]/g,Ic={DEBUG:!1,QUIET:!1,VERBOSE:!1,defs:{},input_files:[]},Pc=0,Qc={\"&\":\"&amp;\",\"<\":\"&lt;\",\">\":\"&gt;\",'\"':\"&quot;\",\"'\":\"&#39;\",\"/\":\"&#x2F;\"},Rc=/^\\s+/,Sc=/\\s+$/;Vc.prototype.isNull=function(){return!this.mx||!this.my||isNaN(this.bx)||isNaN(this.by)},Vc.prototype.invert=function(){var a=new Vc;return a.mx=1/this.mx,a.my=1/this.my,a.bx=-this.bx/this.mx,a.by=-this.by/this.my,a},Vc.prototype.transform=function(a,b,c){return(c=c||[])[0]=a*this.mx+this.bx,c[1]=b*this.my+this.by,c},Vc.prototype.toString=function(){return JSON.stringify(Object.assign({},this))},U.from=function(){var a=new U;return a.setBounds.apply(a,arguments)},U.prototype.toString=function(){return JSON.stringify({xmin:this.xmin,xmax:this.xmax,ymin:this.ymin,ymax:this.ymax})},U.prototype.toArray=function(){return this.hasBounds()?[this.xmin,this.ymin,this.xmax,this.ymax]:[]},U.prototype.hasBounds=function(){return this.xmin<=this.xmax&&this.ymin<=this.ymax},U.prototype.sameBounds=U.prototype.equals=function(a){return a&&this.xmin===a.xmin&&this.xmax===a.xmax&&this.ymin===a.ymin&&this.ymax===a.ymax},U.prototype.width=function(){return this.xmax-this.xmin||0},U.prototype.height=function(){return this.ymax-this.ymin||0},U.prototype.area=function(){return this.width()*this.height()||0},U.prototype.empty=function(){return this.xmin=this.ymin=this.xmax=this.ymax=void 0,this},U.prototype.setBounds=function(a,b,c,d){return 1==arguments.length&&(w.isArrayLike(a)?(b=a[1],c=a[2],d=a[3],a=a[0]):(b=a.ymin,c=a.xmax,d=a.ymax,a=a.xmin)),this.xmin=a,this.ymin=b,this.xmax=c,this.ymax=d,(a>c||b>d)&&this.update(),this},U.prototype.centerX=function(){return.5*(this.xmin+this.xmax)},U.prototype.centerY=function(){return.5*(this.ymax+this.ymin)},U.prototype.containsPoint=function(a,b){return a>=this.xmin&&a<=this.xmax&&b<=this.ymax&&b>=this.ymin},U.prototype.containsBufferedPoint=U.prototype.containsCircle=function(a,b,c){return a+c>this.xmin&&a-c<this.xmax&&b-c<this.ymax&&b+c>this.ymin},U.prototype.intersects=function(a){return a.xmin<=this.xmax&&a.xmax>=this.xmin&&a.ymax>=this.ymin&&a.ymin<=this.ymax},U.prototype.contains=function(a){return a.xmin>=this.xmin&&a.ymax<=this.ymax&&a.xmax<=this.xmax&&a.ymin>=this.ymin},U.prototype.shift=function(a,b){this.setBounds(this.xmin+a,this.ymin+b,this.xmax+a,this.ymax+b)},U.prototype.padBounds=function(a,b,c,d){this.xmin-=a,this.ymin-=b,this.xmax+=c,this.ymax+=d},U.prototype.scale=function(a,b){var c=.5*(this.xmax-this.xmin),d=.5*(this.ymax-this.ymin);--a,b=void 0===b?a:b-1,this.xmin-=c*a,this.ymin-=d*b,this.xmax+=c*a,this.ymax+=d*b},U.prototype.cloneBounds=U.prototype.clone=function(){return new U(this.xmin,this.ymin,this.xmax,this.ymax)},U.prototype.clearBounds=function(){this.setBounds(new U)},U.prototype.mergePoint=function(a,b){void 0===this.xmin?this.setBounds(a,b,a,b):(a<this.xmin?this.xmin=a:a>this.xmax&&(this.xmax=a),b<this.ymin?this.ymin=b:b>this.ymax&&(this.ymax=b))},U.prototype.fillOut=function(a,b,c){3>arguments.length&&(c=b=.5);var d=this.width(),e=this.height(),f=d/e;return isNaN(a)||0>=a||(f<a?(d=e*a-d,this.xmin-=(1-b)*d,this.xmax+=b*d):(d=d/a-e,this.ymin-=(1-c)*d,this.ymax+=c*d)),this},U.prototype.update=function(){if(this.xmin>this.xmax){var a=this.xmin;this.xmin=this.xmax,this.xmax=a}this.ymin>this.ymax&&(a=this.ymin,this.ymin=this.ymax,this.ymax=a)},U.prototype.transform=function(a){return this.xmin=this.xmin*a.mx+a.bx,this.xmax=this.xmax*a.mx+a.bx,this.ymin=this.ymin*a.my+a.by,this.ymax=this.ymax*a.my+a.by,this.update(),this},U.prototype.getTransform=function(a,b){var c=new Vc;return c.mx=a.width()/this.width()||1,c.bx=a.xmin-c.mx*this.xmin,b?(c.my=-a.height()/this.height()||1,c.by=a.ymax-c.my*this.ymin):(c.my=a.height()/this.height()||1,c.by=a.ymin-c.my*this.ymin),c},U.prototype.mergeCircle=function(a,b,c){0>c&&(c=-c),this.mergeBounds([a-c,b-c,a+c,b+c])},U.prototype.mergeBounds=function(a){if(a instanceof U)var b=a.xmin,c=a.ymin,d=a.xmax,e=a.ymax;else 4==arguments.length?(b=arguments[0],c=arguments[1],d=arguments[2],e=arguments[3]):4==a.length?(b=a[0],c=a[1],d=a[2],e=a[3]):Q(\"Bounds#mergeBounds() invalid argument:\",a);return void 0===this.xmin?this.setBounds(b,c,d,e):(b<this.xmin&&(this.xmin=b),c<this.ymin&&(this.ymin=c),d>this.xmax&&(this.xmax=d),e>this.ymax&&(this.ymax=e)),this},$c=function(){function a(d,e,f,h){b+=c(f[d],h[d],f[e],h[e])}var b,c;return function(d,e,f){f&&e.isPlanar()&&Q(\"Expected lat-long coordinates\"),c=f?Yb:Sb,f=b=0;for(var h=d.length;f<h;f++)e.forEachArcSegment(d[f],a);return b}}();var Fd,ad=Object.freeze({__proto__:null,pathIsClosed:function(a,b){var c=a[a.length-1];return a=b.getVertex(a[0],0),b=b.getVertex(c,-1),a.x===b.x&&a.y===b.y},getPointToPathDistance:Wc,getPointToPathInfo:Xc,getPointToShapeDistance:function(a,b,c,d){return(c||[]).reduce((function(e,f){return f=Wc(a,b,f,d),Math.min(e,f)}),1/0)},getAvgPathXY:Yc,getMaxPath:Zc,countVerticesInPath:function(a,b){for(a=b.getShapeIter(a),b=0;a.hasNext();)b++;return b},getPathBounds:function(a){for(var b=new U,c=0,d=a.length;c<d;c++)b.mergePoint(a[c][0],a[c][1]);return b},get calcPathLen(){return $c}}),cd=Object.freeze({__proto__:null,getShapeCentroid:function(a,b){return(a=Zc(a,b))?bd(a,b):null},getPathCentroid:bd}),ud=Object.freeze({__proto__:null,calcPolsbyPopperCompactness:function(a,b){return 0>=b?0:Math.abs(a)*Math.PI*4/(b*b)},calcSchwartzbergCompactness:function(a,b){return 0>=b?0:2*Math.PI*Math.sqrt(Math.abs(a)/Math.PI)/b},getPathWinding:function(a,b){return(0<(a=nd(a,b))?1:0>a&&-1)||0},getShapeArea:function(a,b){return(a||[]).reduce((function(c,d){return c+nd(d,b)}),0)},getPlanarShapeArea:function(a,b){return(a||[]).reduce((function(c,d){return c+od(d,b)}),0)},getSphericalShapeArea:function(a,b){return b.isPlanar()&&Q(\"[getSphericalShapeArea()] Function requires decimal degree coordinates\"),(a||[]).reduce((function(c,d){return c+pd(d,b)}),0)},testPointInPolygon:function(a,b,c,d){var e=!1,f=!1;return c&&c.forEach((function(h){1==(h=kd(a,b,h,d))?e=!e:-1==h&&(f=!0)})),f||e},testPointInRing:kd,testRayIntersection:ld,getRayIntersection:md,getPathArea:nd,getSphericalPathArea:pd,getSphericalPathArea2:qd,getPlanarPathArea2:function(a){for(var c,d,e,f,h,g,l,b=0,n=0,p=a.length;n<p;n++)l=a[n],0===n?(d=c=0,h=-l[0],g=-l[1]):b+=(c=l[0]+h)*f-e*(d=l[1]+g),e=c,f=d;return b/2},getPlanarPathArea:od,getPathPerimeter:rd,getShapePerimeter:function(a,b){return(a||[]).reduce((function(c,d){return c+rd(d,b)}),0)},getSphericalShapePerimeter:function(a,b){return b.isPlanar()&&Q(\"[getSphericalShapePerimeter()] Function requires decimal degree coordinates\"),(a||[]).reduce((function(c,d){return c+td(d,b)}),0)},getPlanarPathPerimeter:sd,getSphericalPathPerimeter:td}),Cd=Object.freeze({__proto__:null,segmentIntersection:function(a,b,c,d,e,f,h,g,l){var r,n=0<=l?l:1e-14*Math.max.apply(null,[a,b,c,d,e,f,h,g].map(Math.abs)),p=n*n;if(xd(l=[],p,a,b,e,f,h,g),xd(l,p,c,d,e,f,h,g),xd(l,p,e,f,a,b,c,d),xd(l,p,h,g,a,b,c,d),(r=!(l=0===l.length?null:l))&&(r=z(a,b,e,f)<=p||z(a,b,h,g)<=p||z(c,d,e,f)<=p||z(c,d,h,g)<=p),r)return null;if(Bd(a,b,c,d,e,f,h,g))if(r=(c-a)*(g-f)-(d-b)*(h-e),p=[a+(p=Ad(e,f,h,g,a,b)/r)*(c-a),b+p*(d-b)],1e-18>Math.abs(r))a=null;else{if(0<n){r=p[0];var u=p[1];n=yd(p,n,r,u,a,b),n=yd(p,n,r,u,c,d),n=yd(p,n,r,u,e,f),yd(p,n,r,u,h,g)}n=p[0],r=p[1],n=zd(n,a,c),n=zd(n,e,h),r=zd(r,b,d),r=zd(r,f,g),p[0]=n,p[1]=r,a=p}else a=null;return l||a||null},findClosestPointOnSeg:function(a,b,c,d,e,f){var h=e-c,g=f-d,l=h*h+g*g;return.1>=(a=0===l?-1:((a-c)*h+(b-d)*g)/l)?[c,d]:.9<=a?[e,f]:[c+a*h,d+a*g]},orient2D:Ad,segmentHit:Bd}),V=Object.assign({},bc,ud,ad,Cd,cd),X={getArcCalculator:function(a,b){var c=new Sd,d=w.expandoBuffer(Int32Array),e=w.expandoBuffer(Int32Array),f=b?function(h,g,l,n,p,r){return a(n[h],p[h],r[h],n[g],p[g],r[g],n[l],p[l],r[l])}:function(h,g,l,n,p){return a(n[h],p[h],n[g],p[g],n[l],p[l])};return function(h,g,l,n){var x,p=h.length,r=d(p),u=e(p),t=-1/0;for(n&&!b?Q(\"[visvalingam] Received z-axis data for 2D simplification\"):!n&&b?Q(\"[visvalingam] Missing z-axis data for 3D simplification\"):h.length>g.length&&Q(\"[visvalingam] Incompatible data arrays:\",h.length,g.length),x=0;x<p;x++){var A=x-1,y=x+1,k=0>A||y>=p?1/0:f(A,x,y,g,l,n);h[x]=k,u[x]=y,r[x]=A}for(c.init(h);0<c.size()&&1/0!==(k=h[x=c.pop()]);)k<t?h[x]=t:t=k,A=r[x],y=u[x],0<A&&(k=f(r[A],A,y,g,l,n),c.updateValue(A,k)),y<p-1&&(k=f(A,y,u[y],g,l,n),c.updateValue(y,k)),u[A]=y,r[y]=A}}};X.standardMetric=V.triangleArea,X.standardMetric3D=V.triangleArea3D,X.getWeightedMetric=function(a){var b=X.getWeightFunction(a);return function(c,d,e,f,h,g){var l=V.triangleArea(c,d,e,f,h,g);return c=V.cosine(c,d,e,f,h,g),b(c)*l}},X.getWeightedMetric3D=function(a){var b=X.getWeightFunction(a);return function(c,d,e,f,h,g,l,n,p){var r=V.triangleArea3D(c,d,e,f,h,g,l,n,p);return c=V.cosine3D(c,d,e,f,h,g,l,n,p),b(c)*r}},X.getWeightCoefficient=function(a){return a&&w.isNumber(a&&a.weighting)?a.weighting:.7},X.getWeightFunction=function(a){var b=X.getWeightCoefficient(a);return function(c){return-c*b+1}},X.weight=function(a){return.7*-a+1},X.getEffectiveAreaSimplifier=function(a){return X.getPathSimplifier(a?X.standardMetric3D:X.standardMetric,a)},X.getWeightedSimplifier=function(a,b){return a=b?X.getWeightedMetric3D(a):X.getWeightedMetric(a),X.getPathSimplifier(a,b)},X.getPathSimplifier=function(a,b){return X.scaledSimplify(X.getArcCalculator(a,b))},X.scaledSimplify=function(a){return function(b,c,d,e){for(a(b,c,d,e),c=1,d=b.length-1;c<d;c++)b[c]=.65*Math.sqrt(b[c])}};var Y={ID_FIELD:\"FID\",typeLookup:{LineString:\"polyline\",MultiLineString:\"polyline\",Polygon:\"polygon\",MultiPolygon:\"polygon\",Point:\"point\",MultiPoint:\"point\"},translateGeoJSONType:function(a){return Y.typeLookup[a]||null},pathIsRing:function(a){var b=a[0],c=a[a.length-1];return 4<=a.length&&b[0]==c[0]&&b[1]==c[1]}},ie=function he(a){var b=null;return\"utf8\"!=(a=(a||\"\").toLowerCase().replace(/[_-]/g,\"\"))?null:(\"undefined\"!=typeof TextEncoder&&(b=new TextEncoder(a)),function(c){return b?J.from(b.encode(c).buffer):w.createBuffer(c,a)})}(\"utf8\");!function je(a){\"utf8\"!=(a=(a||\"\").toLowerCase().replace(/[_-]/g,\"\"))||\"undefined\"!=typeof TextDecoder&&new TextDecoder(a)}(\"utf8\"),ne.prototype={fieldExists:function(a){return w.contains(this.getFields(),a)},toString:function(){return JSON.stringify(this)},toJSON:function(){return this.getRecords()},addField:function(a,b){var c=w.isFunction(b);w.isNumber(b)||w.isString(b)||c||Q(\"DataTable#addField() requires a string, number or function for initialization\"),this.fieldExists(a)&&Q(\"DataTable#addField() tried to add a field that already exists:\",a),this.getRecords().forEach((function(d,e){d[a]=c?b(d,e):b}))},getRecordAt:function(a){return this.getRecords()[a]},addIdField:function(){this.addField(\"FID\",(function(a,b){return b}))},deleteField:function(a){this.getRecords().forEach((function(b){delete b[a]}))},getFields:function(){var a=this.getRecords();a:{for(var b=0,c=a?a.length:0;b<c;b++)if(a[b]){a=a[b];break a}a=null}return function me(a,b){return\"ascending\"==b&&a.sort((function(c,d){return c.toLowerCase()<d.toLowerCase()?-1:1})),a}(a=a?Object.keys(a):[],void 0)},isEmpty:function(){return 0===this.getFields().length||0===this.size()},update:function(a){for(var b=this.getRecords(),c=0,d=b.length;c<d;c++)b[c]=a(b[c],c)},clone:function(){return new ne(this.getRecords().map(ke))},size:function(){return this.getRecords().length}},xe.prototype.init=function(a,b,c){return c?(this._i=a,this._inc=1):(this._i=a+b-1,this._inc=-1),this._n=b,this},xe.prototype.hasNext=function(){var a=this._i;return 0<this._n&&(this._i=a+this._inc,this.x=this._xx[a],this.y=this._yy[a],this.i=a,this._n--,!0)},ze.prototype.hasNext=function(){var a=this._arc;return 0!=this._i<this._n&&(a.hasNext()?(this.x=a.x,this.y=a.y,!0):(this.nextArc(),this.hasNext()))},ze.prototype.init=function(a){return this._ids=a,this._n=a.length,this.reset(),this},ze.prototype.nextArc=function(){var a=this._i+1;a<this._n&&(this._arc=this._arcs.getArcIter(this._ids[a]),0<a&&this._arc.hasNext()),this._i=a},ze.prototype.reset=function(){this._i=-1,this.nextArc()};var Ee={robinson:\"+proj=robin +datum=WGS84\",webmercator:\"+proj=merc +a=6378137 +b=6378137\",wgs84:\"+proj=longlat +datum=WGS84\"},Ie={m:\"meters\",meter:\"meters\",meters:\"meters\",mi:\"miles\",mile:\"miles\",miles:\"miles\",km:\"kilometers\",ft:\"feet\",feet:\"feet\"},Je={meters:1,kilometers:1e3,feet:.3048,miles:1609.344};Y.importGeometry=function(a,b,c){var d=a.type;d in Y.pathImporters?c.geometry_type&&c.geometry_type!=Y.translateGeoJSONType(d)||Y.pathImporters[d](a.coordinates,b):\"GeometryCollection\"==d?a.geometries.forEach((function(e){Y.importGeometry(e,b,c)})):Oc(\"GeoJSON.importGeometry() Unsupported geometry type:\",a.type)},Y.pathImporters={LineString:function(a,b){b.importLine(a)},MultiLineString:function(a,b){for(var c=0;c<a.length;c++)Y.pathImporters.LineString(a[c],b)},Polygon:function(a,b){for(var c=0;c<a.length;c++)b.importRing(a[c],0<c)},MultiPolygon:function(a,b){for(var c=0;c<a.length;c++)Y.pathImporters.Polygon(a[c],b)},Point:function(a,b){b.importPoints([a])},MultiPoint:function(a,b){b.importPoints(a)}},Y.formatCollectionAsNDJSON=function(a){var b=w.createBuffer(\"\\n\",\"utf8\");return a=a.reduce((function(c,d,e){return 0<e&&c.push(b),c.push(d),c}),[]),J.concat(a)},Y.formatCollection=function(a,b){return a=JSON.stringify(a).replace(/\\}$/,', \"'+rf(a.type)+'\": [\\n'),w.isString(b[0])?a+b.join(\",\\n\")+\"\\n]}\":Y.joinOutputBuffers(a,\"\\n]}\",b)},Y.joinOutputBuffers=function(a,b,c){var d=w.createBuffer(\",\\n\",\"utf8\");return(a=c.reduce((function(e,f,h){return 0<h&&e.push(d),e.push(f),e}),[w.createBuffer(a,\"utf8\")])).push(w.createBuffer(b,\"utf8\")),J.concat(a)},Y.exportPointGeom=function(a){var b=null;return 1==a.length?b={type:\"Point\",coordinates:a[0]}:1<a.length&&(b={type:\"MultiPoint\",coordinates:a}),b},Y.exportLineGeom=function(a,b){return 0===(a=Ye(a,b,\"polyline\")).pointCount?null:1==(a=a.pathData.map((function(c){return c.points}))).length?{type:\"LineString\",coordinates:a[0]}:{type:\"MultiLineString\",coordinates:a}},Y.exportPolygonGeom=function(a,b,c){if(0===(a=Ye(a,b,\"polygon\")).pointCount)return null;b=function We(a,b,c){var d=[],e=[],f=c?-1:1;if((a||[]).forEach((function(g){0<g.area*f?e.push([g]):0>g.area*f&&d.push(g)})),0===d.length)return e;var h=function Ve(a){function b(d){return a[d]}if(!a.length)return function(){return[]};var c=new(require(\"flatbush\"))(a.length);return a.forEach((function(d){d=d.bounds,c.add(d.xmin,d.ymin,d.xmax,d.ymax)})),c.finish(),function(d,e,f,h){return c.search(d,e,f,h).map(b)}}(e.map((function(g,l){return{bounds:g[0].bounds,idx:l}})));return d.forEach((function(g){for(var u,t,x,A,l=-1,n=0,p=g.area*-f,r=g.bounds,y=0,k=(r=h(r.xmin,r.ymin,r.xmax,r.ymax)).length;y<k;y++){var m;if(t=r[y].idx,x=(u=e[t][0]).area*f,m=(A=u.bounds.contains(g.bounds)&&x>p)&&1<r.length){m=g;var q=b;!1===u.bounds.contains(m.bounds)?m=!1:(m=q.getVertex(m.ids[0],0),m=1==V.testPointInRing(m.x,m.y,u.ids,q)),m=!m}!m&&A&&(0===n||x<n)&&(n=x,l=t)}-1!=l&&e[l].push(g)})),e}(a.pathData,b,c.invert_y);var d=(c.rfc7946||c.v2)&&!c.invert_y;return 1==(c=b.map((function(e){return e.map((function(f){return d&&f.points.reverse(),f.points}))}))).length?{type:\"Polygon\",coordinates:c[0]}:{type:\"MultiPolygon\",coordinates:c}},Y.exporters={polygon:Y.exportPolygonGeom,polyline:Y.exportLineGeom,point:Y.exportPointGeom};export{preBuild,simplify};\n"
  },
  {
    "url": "fs.js",
    "ranges": [
      {
        "start": 0,
        "end": 3832
      },
      {
        "start": 4119,
        "end": 4121
      },
      {
        "start": 4237,
        "end": 4440
      },
      {
        "start": 4583,
        "end": 4764
      },
      {
        "start": 4979,
        "end": 5005
      },
      {
        "start": 5265,
        "end": 5267
      },
      {
        "start": 5625,
        "end": 5627
      },
      {
        "start": 5865,
        "end": 5867
      },
      {
        "start": 6105,
        "end": 6178
      },
      {
        "start": 6256,
        "end": 6673
      },
      {
        "start": 7203,
        "end": 7205
      },
      {
        "start": 7485,
        "end": 7487
      },
      {
        "start": 7988,
        "end": 7990
      },
      {
        "start": 8816,
        "end": 8818
      },
      {
        "start": 9048,
        "end": 9050
      },
      {
        "start": 9361,
        "end": 9363
      },
      {
        "start": 9618,
        "end": 9620
      },
      {
        "start": 11003,
        "end": 11005
      },
      {
        "start": 11195,
        "end": 11197
      },
      {
        "start": 11340,
        "end": 11342
      },
      {
        "start": 11919,
        "end": 11922
      },
      {
        "start": 12318,
        "end": 12425
      },
      {
        "start": 13923,
        "end": 14192
      },
      {
        "start": 15107,
        "end": 15109
      },
      {
        "start": 15539,
        "end": 15682
      },
      {
        "start": 15992,
        "end": 16138
      },
      {
        "start": 17406,
        "end": 17683
      },
      {
        "start": 18549,
        "end": 18610
      },
      {
        "start": 19038,
        "end": 19167
      },
      {
        "start": 19480,
        "end": 19482
      },
      {
        "start": 19863,
        "end": 19865
      },
      {
        "start": 20212,
        "end": 20214
      },
      {
        "start": 20832,
        "end": 20834
      },
      {
        "start": 21237,
        "end": 21239
      },
      {
        "start": 21579,
        "end": 21581
      },
      {
        "start": 21801,
        "end": 21804
      },
      {
        "start": 21923,
        "end": 21925
      },
      {
        "start": 22565,
        "end": 22567
      },
      {
        "start": 23005,
        "end": 23007
      },
      {
        "start": 23345,
        "end": 23347
      },
      {
        "start": 23517,
        "end": 23519
      },
      {
        "start": 23693,
        "end": 23695
      },
      {
        "start": 23845,
        "end": 23847
      },
      {
        "start": 24013,
        "end": 24015
      },
      {
        "start": 24157,
        "end": 24159
      },
      {
        "start": 24940,
        "end": 24942
      },
      {
        "start": 25714,
        "end": 25716
      },
      {
        "start": 26297,
        "end": 26299
      },
      {
        "start": 26725,
        "end": 26727
      },
      {
        "start": 27066,
        "end": 27068
      },
      {
        "start": 27443,
        "end": 27445
      },
      {
        "start": 27818,
        "end": 27820
      },
      {
        "start": 28062,
        "end": 28064
      },
      {
        "start": 28374,
        "end": 28376
      },
      {
        "start": 28683,
        "end": 28685
      },
      {
        "start": 29033,
        "end": 29035
      },
      {
        "start": 29366,
        "end": 29368
      },
      {
        "start": 30978,
        "end": 30980
      },
      {
        "start": 31637,
        "end": 31639
      },
      {
        "start": 32040,
        "end": 32042
      },
      {
        "start": 32491,
        "end": 32493
      },
      {
        "start": 32720,
        "end": 32722
      },
      {
        "start": 32908,
        "end": 32910
      },
      {
        "start": 33152,
        "end": 33154
      },
      {
        "start": 33348,
        "end": 33350
      },
      {
        "start": 33787,
        "end": 33789
      },
      {
        "start": 34111,
        "end": 34114
      },
      {
        "start": 34390,
        "end": 34392
      },
      {
        "start": 34627,
        "end": 34629
      },
      {
        "start": 34970,
        "end": 34972
      },
      {
        "start": 35272,
        "end": 35274
      },
      {
        "start": 35580,
        "end": 35582
      },
      {
        "start": 35841,
        "end": 35843
      },
      {
        "start": 36183,
        "end": 36185
      },
      {
        "start": 36483,
        "end": 36485
      },
      {
        "start": 36826,
        "end": 36828
      },
      {
        "start": 37110,
        "end": 37112
      },
      {
        "start": 37420,
        "end": 37422
      },
      {
        "start": 37682,
        "end": 37684
      },
      {
        "start": 38030,
        "end": 38032
      },
      {
        "start": 38336,
        "end": 38338
      },
      {
        "start": 38988,
        "end": 38990
      },
      {
        "start": 39717,
        "end": 39719
      },
      {
        "start": 40429,
        "end": 40431
      },
      {
        "start": 40871,
        "end": 40873
      },
      {
        "start": 41252,
        "end": 41254
      },
      {
        "start": 42146,
        "end": 42182
      },
      {
        "start": 43295,
        "end": 43297
      },
      {
        "start": 43985,
        "end": 44201
      },
      {
        "start": 44267,
        "end": 44292
      },
      {
        "start": 44470,
        "end": 44475
      },
      {
        "start": 44762,
        "end": 44885
      },
      {
        "start": 45128,
        "end": 45152
      },
      {
        "start": 45205,
        "end": 45247
      },
      {
        "start": 49113,
        "end": 49138
      },
      {
        "start": 49377,
        "end": 49381
      },
      {
        "start": 52816,
        "end": 52837
      },
      {
        "start": 53107,
        "end": 53110
      },
      {
        "start": 53581,
        "end": 53584
      },
      {
        "start": 54058,
        "end": 54061
      },
      {
        "start": 54615,
        "end": 54618
      },
      {
        "start": 54990,
        "end": 54992
      },
      {
        "start": 55186,
        "end": 55188
      },
      {
        "start": 55293,
        "end": 55295
      },
      {
        "start": 55402,
        "end": 56625
      },
      {
        "start": 56693,
        "end": 56698
      },
      {
        "start": 56745,
        "end": 56750
      },
      {
        "start": 56820,
        "end": 56825
      },
      {
        "start": 56874,
        "end": 57012
      },
      {
        "start": 57088,
        "end": 57093
      },
      {
        "start": 57148,
        "end": 57153
      },
      {
        "start": 57231,
        "end": 57236
      },
      {
        "start": 57293,
        "end": 57858
      }
    ],
    "text": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Maintainers, keep in mind that ES1-style octal literals (`0666`) are not\n// allowed in strict mode. Use ES6-style octal literals instead (`0o666`).\n\n'use strict';\n\n// Most platforms don't allow reads or writes >= 2 GB.\n// See https://github.com/libuv/libuv/pull/1501.\nconst kIoMaxLength = 2 ** 31 - 1;\n\n// When using FSReqCallback, make sure to create the object only *after* all\n// parameter validation has happened, so that the objects are not kept in memory\n// in case they are created but never used due to an exception.\n\nconst {\n  Map,\n  MathMax,\n  Number,\n  NumberIsSafeInteger,\n  ObjectCreate,\n  ObjectDefineProperties,\n  ObjectDefineProperty,\n  Promise,\n  String,\n} = primordials;\n\nconst { fs: constants } = internalBinding('constants');\nconst {\n  S_IFIFO,\n  S_IFLNK,\n  S_IFMT,\n  S_IFREG,\n  S_IFSOCK,\n  F_OK,\n  R_OK,\n  W_OK,\n  X_OK,\n  O_WRONLY,\n  O_SYMLINK\n} = constants;\n\nconst pathModule = require('path');\nconst { isArrayBufferView } = require('internal/util/types');\nconst binding = internalBinding('fs');\nconst { Buffer } = require('buffer');\nconst {\n  codes: {\n    ERR_FS_FILE_TOO_LARGE,\n    ERR_INVALID_ARG_VALUE,\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_CALLBACK,\n    ERR_FEATURE_UNAVAILABLE_ON_PLATFORM\n  },\n  uvException\n} = require('internal/errors');\n\nconst { FSReqCallback, statValues } = binding;\nconst { toPathIfFileURL } = require('internal/url');\nconst internalUtil = require('internal/util');\nconst {\n  copyObject,\n  Dirent,\n  getDirents,\n  getOptions,\n  getValidatedPath,\n  getValidMode,\n  handleErrorFromBinding,\n  nullCheck,\n  preprocessSymlinkDestination,\n  Stats,\n  getStatsFromBinding,\n  realpathCacheKey,\n  stringToFlags,\n  stringToSymlinkType,\n  toUnixTimestamp,\n  validateBufferArray,\n  validateOffsetLengthRead,\n  validateOffsetLengthWrite,\n  validatePath,\n  validateRmOptions,\n  validateRmOptionsSync,\n  validateRmdirOptions,\n  validateStringAfterArrayBufferView,\n  warnOnNonPortableTemplate\n} = require('internal/fs/utils');\nconst {\n  Dir,\n  opendir,\n  opendirSync\n} = require('internal/fs/dir');\nconst {\n  CHAR_FORWARD_SLASH,\n  CHAR_BACKWARD_SLASH,\n} = require('internal/constants');\nconst {\n  isUint32,\n  parseFileMode,\n  validateBuffer,\n  validateInteger,\n  validateInt32\n} = require('internal/validators');\n// 2 ** 32 - 1\nconst kMaxUserId = 4294967295;\n\nlet truncateWarn = true;\nlet fs;\n\n// Lazy loaded\nlet promises = null;\nlet watchers;\nlet ReadFileContext;\nlet ReadStream;\nlet WriteStream;\nlet rimraf;\nlet rimrafSync;\n\n// These have to be separate because of how graceful-fs happens to do it's\n// monkeypatching.\nlet FileReadStream;\nlet FileWriteStream;\n\nconst isWindows = process.platform === 'win32';\nconst isOSX = process.platform === 'darwin';\n\n\nfunction showTruncateDeprecation() {\n  if (truncateWarn) {\n    process.emitWarning(\n      'Using fs.truncate with a file descriptor is deprecated. Please use ' +\n      'fs.ftruncate with a file descriptor instead.',\n      'DeprecationWarning', 'DEP0081');\n    truncateWarn = false;\n  }\n}\n\nfunction maybeCallback(cb) {\n  if (typeof cb === 'function')\n    return cb;\n\n  throw new ERR_INVALID_CALLBACK(cb);\n}\n\n// Ensure that callbacks run in the global context. Only use this function\n// for callbacks that are passed to the binding layer, callbacks that are\n// invoked from JS already run in the proper scope.\nfunction makeCallback(cb) {\n  if (typeof cb !== 'function') {\n    throw new ERR_INVALID_CALLBACK(cb);\n  }\n\n  return (...args) => cb(...args);\n}\n\n// Special case of `makeCallback()` that is specific to async `*stat()` calls as\n// an optimization, since the data passed back to the callback needs to be\n// transformed anyway.\nfunction makeStatsCallback(cb) {\n  if (typeof cb !== 'function') {\n    throw new ERR_INVALID_CALLBACK(cb);\n  }\n\n  return (err, stats) => {\n    if (err) return cb(err);\n    cb(err, getStatsFromBinding(stats));\n  };\n}\n\nconst isFd = isUint32;\n\nfunction isFileType(stats, fileType) {\n  // Use stats array directly to avoid creating an fs.Stats instance just for\n  // our internal use.\n  let mode = stats[1];\n  if (typeof mode === 'bigint')\n    mode = Number(mode);\n  return (mode & S_IFMT) === fileType;\n}\n\nfunction access(path, mode, callback) {\n  if (typeof mode === 'function') {\n    callback = mode;\n    mode = F_OK;\n  }\n\n  path = getValidatedPath(path);\n  mode = getValidMode(mode, 'access');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.access(pathModule.toNamespacedPath(path), mode, req);\n}\n\nfunction accessSync(path, mode) {\n  path = getValidatedPath(path);\n  mode = getValidMode(mode, 'access');\n\n  const ctx = { path };\n  binding.access(pathModule.toNamespacedPath(path), mode, undefined, ctx);\n  handleErrorFromBinding(ctx);\n}\n\nfunction exists(path, callback) {\n  maybeCallback(callback);\n\n  function suppressedCallback(err) {\n    callback(err ? false : true);\n  }\n\n  try {\n    fs.access(path, F_OK, suppressedCallback);\n  } catch {\n    return callback(false);\n  }\n}\n\nObjectDefineProperty(exists, internalUtil.promisify.custom, {\n  value: (path) => {\n    return new Promise((resolve) => fs.exists(path, resolve));\n  }\n});\n\n// fs.existsSync never throws, it only returns true or false.\n// Since fs.existsSync never throws, users have established\n// the expectation that passing invalid arguments to it, even like\n// fs.existsSync(), would only get a false in return, so we cannot signal\n// validation errors to users properly out of compatibility concerns.\n// TODO(joyeecheung): deprecate the never-throw-on-invalid-arguments behavior\nfunction existsSync(path) {\n  try {\n    path = getValidatedPath(path);\n  } catch {\n    return false;\n  }\n  const ctx = { path };\n  const nPath = pathModule.toNamespacedPath(path);\n  binding.access(nPath, F_OK, undefined, ctx);\n\n  // In case of an invalid symlink, `binding.access()` on win32\n  // will **not** return an error and is therefore not enough.\n  // Double check with `binding.stat()`.\n  if (isWindows && ctx.errno === undefined) {\n    binding.stat(nPath, false, undefined, ctx);\n  }\n\n  return ctx.errno === undefined;\n}\n\nfunction readFileAfterOpen(err, fd) {\n  const context = this.context;\n\n  if (err) {\n    context.callback(err);\n    return;\n  }\n\n  context.fd = fd;\n\n  const req = new FSReqCallback();\n  req.oncomplete = readFileAfterStat;\n  req.context = context;\n  binding.fstat(fd, false, req);\n}\n\nfunction readFileAfterStat(err, stats) {\n  const context = this.context;\n\n  if (err)\n    return context.close(err);\n\n  const size = context.size = isFileType(stats, S_IFREG) ? stats[8] : 0;\n\n  if (size > kIoMaxLength) {\n    err = new ERR_FS_FILE_TOO_LARGE(size);\n    return context.close(err);\n  }\n\n  try {\n    if (size === 0) {\n      context.buffers = [];\n    } else {\n      context.buffer = Buffer.allocUnsafeSlow(size);\n    }\n  } catch (err) {\n    return context.close(err);\n  }\n  context.read();\n}\n\nfunction readFile(path, options, callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options, { flag: 'r' });\n  if (!ReadFileContext)\n    ReadFileContext = require('internal/fs/read_file_context');\n  const context = new ReadFileContext(callback, options.encoding);\n  context.isUserFd = isFd(path); // File descriptor ownership\n\n  if (context.isUserFd) {\n    process.nextTick(function tick(context) {\n      readFileAfterOpen.call({ context }, null, path);\n    }, context);\n    return;\n  }\n\n  const flagsNumber = stringToFlags(options.flag);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  req.context = context;\n  req.oncomplete = readFileAfterOpen;\n  binding.open(pathModule.toNamespacedPath(path),\n               flagsNumber,\n               0o666,\n               req);\n}\n\nfunction tryStatSync(fd, isUserFd) {\n  const ctx = {};\n  const stats = binding.fstat(fd, false, undefined, ctx);\n  if (ctx.errno !== undefined && !isUserFd) {\n    fs.closeSync(fd);\n    throw uvException(ctx);\n  }\n  return stats;\n}\n\nfunction tryCreateBuffer(size, fd, isUserFd) {\n  let threw = true;\n  let buffer;\n  try {\n    if (size > kIoMaxLength) {\n      throw new ERR_FS_FILE_TOO_LARGE(size);\n    }\n    buffer = Buffer.allocUnsafe(size);\n    threw = false;\n  } finally {\n    if (threw && !isUserFd) fs.closeSync(fd);\n  }\n  return buffer;\n}\n\nfunction tryReadSync(fd, isUserFd, buffer, pos, len) {\n  let threw = true;\n  let bytesRead;\n  try {\n    bytesRead = fs.readSync(fd, buffer, pos, len);\n    threw = false;\n  } finally {\n    if (threw && !isUserFd) fs.closeSync(fd);\n  }\n  return bytesRead;\n}\n\nfunction readFileSync(path, options) {\n  options = getOptions(options, { flag: 'r' });\n  const isUserFd = isFd(path); // File descriptor ownership\n  const fd = isUserFd ? path : fs.openSync(path, options.flag, 0o666);\n\n  const stats = tryStatSync(fd, isUserFd);\n  const size = isFileType(stats, S_IFREG) ? stats[8] : 0;\n  let pos = 0;\n  let buffer; // Single buffer with file data\n  let buffers; // List for when size is unknown\n\n  if (size === 0) {\n    buffers = [];\n  } else {\n    buffer = tryCreateBuffer(size, fd, isUserFd);\n  }\n\n  let bytesRead;\n\n  if (size !== 0) {\n    do {\n      bytesRead = tryReadSync(fd, isUserFd, buffer, pos, size - pos);\n      pos += bytesRead;\n    } while (bytesRead !== 0 && pos < size);\n  } else {\n    do {\n      // The kernel lies about many files.\n      // Go ahead and try to read some bytes.\n      buffer = Buffer.allocUnsafe(8192);\n      bytesRead = tryReadSync(fd, isUserFd, buffer, 0, 8192);\n      if (bytesRead !== 0) {\n        buffers.push(buffer.slice(0, bytesRead));\n      }\n      pos += bytesRead;\n    } while (bytesRead !== 0);\n  }\n\n  if (!isUserFd)\n    fs.closeSync(fd);\n\n  if (size === 0) {\n    // Data was collected into the buffers list.\n    buffer = Buffer.concat(buffers, pos);\n  } else if (pos < size) {\n    buffer = buffer.slice(0, pos);\n  }\n\n  if (options.encoding) buffer = buffer.toString(options.encoding);\n  return buffer;\n}\n\nfunction close(fd, callback) {\n  validateInt32(fd, 'fd', 0);\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.close(fd, req);\n}\n\nfunction closeSync(fd) {\n  validateInt32(fd, 'fd', 0);\n\n  const ctx = {};\n  binding.close(fd, undefined, ctx);\n  handleErrorFromBinding(ctx);\n}\n\nfunction open(path, flags, mode, callback) {\n  path = getValidatedPath(path);\n  if (arguments.length < 3) {\n    callback = flags;\n    flags = 'r';\n    mode = 0o666;\n  } else if (typeof mode === 'function') {\n    callback = mode;\n    mode = 0o666;\n  } else {\n    mode = parseFileMode(mode, 'mode', 0o666);\n  }\n  const flagsNumber = stringToFlags(flags);\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n\n  binding.open(pathModule.toNamespacedPath(path),\n               flagsNumber,\n               mode,\n               req);\n}\n\n\nfunction openSync(path, flags, mode) {\n  path = getValidatedPath(path);\n  const flagsNumber = stringToFlags(flags);\n  mode = parseFileMode(mode, 'mode', 0o666);\n\n  const ctx = { path };\n  const result = binding.open(pathModule.toNamespacedPath(path),\n                              flagsNumber, mode,\n                              undefined, ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n// usage:\n// fs.read(fd, buffer, offset, length, position, callback);\n// OR\n// fs.read(fd, {}, callback)\nfunction read(fd, buffer, offset, length, position, callback) {\n  validateInt32(fd, 'fd', 0);\n\n  if (arguments.length <= 3) {\n    // Assume fs.read(fd, options, callback)\n    let options = {};\n    if (arguments.length < 3) {\n      // This is fs.read(fd, callback)\n      // buffer will be the callback\n      callback = buffer;\n    } else {\n      // This is fs.read(fd, {}, callback)\n      // buffer will be the options object\n      // offset is the callback\n      options = buffer;\n      callback = offset;\n    }\n\n    ({\n      buffer = Buffer.alloc(16384),\n      offset = 0,\n      length = buffer.length,\n      position\n    } = options);\n  }\n\n  validateBuffer(buffer);\n  callback = maybeCallback(callback);\n\n  if (offset == null) {\n    offset = 0;\n  } else {\n    validateInteger(offset, 'offset');\n  }\n\n  length |= 0;\n\n  if (length === 0) {\n    return process.nextTick(function tick() {\n      callback(null, 0, buffer);\n    });\n  }\n\n  if (buffer.byteLength === 0) {\n    throw new ERR_INVALID_ARG_VALUE('buffer', buffer,\n                                    'is empty and cannot be written');\n  }\n\n  validateOffsetLengthRead(offset, length, buffer.byteLength);\n\n  if (!NumberIsSafeInteger(position))\n    position = -1;\n\n  function wrapper(err, bytesRead) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback(err, bytesRead || 0, buffer);\n  }\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n\n  binding.read(fd, buffer, offset, length, position, req);\n}\n\nObjectDefineProperty(read, internalUtil.customPromisifyArgs,\n                     { value: ['bytesRead', 'buffer'], enumerable: false });\n\n// usage:\n// fs.readSync(fd, buffer, offset, length, position);\n// OR\n// fs.readSync(fd, buffer, {}) or fs.readSync(fd, buffer)\nfunction readSync(fd, buffer, offset, length, position) {\n  validateInt32(fd, 'fd', 0);\n\n  if (arguments.length <= 3) {\n    // Assume fs.read(fd, buffer, options)\n    const options = offset || {};\n\n    ({ offset = 0, length = buffer.length, position } = options);\n  }\n\n  validateBuffer(buffer);\n\n  if (offset == null) {\n    offset = 0;\n  } else {\n    validateInteger(offset, 'offset');\n  }\n\n  length |= 0;\n\n  if (length === 0) {\n    return 0;\n  }\n\n  if (buffer.byteLength === 0) {\n    throw new ERR_INVALID_ARG_VALUE('buffer', buffer,\n                                    'is empty and cannot be written');\n  }\n\n  validateOffsetLengthRead(offset, length, buffer.byteLength);\n\n  if (!NumberIsSafeInteger(position))\n    position = -1;\n\n  const ctx = {};\n  const result = binding.read(fd, buffer, offset, length, position,\n                              undefined, ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\nfunction readv(fd, buffers, position, callback) {\n  function wrapper(err, read) {\n    callback(err, read || 0, buffers);\n  }\n\n  validateInt32(fd, 'fd', /* min */ 0);\n  validateBufferArray(buffers);\n  callback = maybeCallback(callback || position);\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n\n  if (typeof position !== 'number')\n    position = null;\n\n  return binding.readBuffers(fd, buffers, position, req);\n}\n\nObjectDefineProperty(readv, internalUtil.customPromisifyArgs,\n                     { value: ['bytesRead', 'buffers'], enumerable: false });\n\nfunction readvSync(fd, buffers, position) {\n  validateInt32(fd, 'fd', 0);\n  validateBufferArray(buffers);\n\n  const ctx = {};\n\n  if (typeof position !== 'number')\n    position = null;\n\n  const result = binding.readBuffers(fd, buffers, position, undefined, ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n// usage:\n//  fs.write(fd, buffer[, offset[, length[, position]]], callback);\n// OR\n//  fs.write(fd, string[, position[, encoding]], callback);\nfunction write(fd, buffer, offset, length, position, callback) {\n  function wrapper(err, written) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback(err, written || 0, buffer);\n  }\n\n  validateInt32(fd, 'fd', 0);\n\n  if (isArrayBufferView(buffer)) {\n    callback = maybeCallback(callback || position || length || offset);\n    if (offset == null || typeof offset === 'function') {\n      offset = 0;\n    } else {\n      validateInteger(offset, 'offset');\n    }\n    if (typeof length !== 'number')\n      length = buffer.length - offset;\n    if (typeof position !== 'number')\n      position = null;\n    validateOffsetLengthWrite(offset, length, buffer.byteLength);\n\n    const req = new FSReqCallback();\n    req.oncomplete = wrapper;\n    return binding.writeBuffer(fd, buffer, offset, length, position, req);\n  }\n\n  validateStringAfterArrayBufferView(buffer, 'buffer');\n\n  if (typeof position !== 'function') {\n    if (typeof offset === 'function') {\n      position = offset;\n      offset = null;\n    } else {\n      position = length;\n    }\n    length = 'utf8';\n  }\n  callback = maybeCallback(position);\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n  return binding.writeString(fd, String(buffer), offset, length, req);\n}\n\nObjectDefineProperty(write, internalUtil.customPromisifyArgs,\n                     { value: ['bytesWritten', 'buffer'], enumerable: false });\n\n// Usage:\n//  fs.writeSync(fd, buffer[, offset[, length[, position]]]);\n// OR\n//  fs.writeSync(fd, string[, position[, encoding]]);\nfunction writeSync(fd, buffer, offset, length, position) {\n  validateInt32(fd, 'fd', 0);\n  const ctx = {};\n  let result;\n  if (isArrayBufferView(buffer)) {\n    if (position === undefined)\n      position = null;\n    if (offset == null) {\n      offset = 0;\n    } else {\n      validateInteger(offset, 'offset');\n    }\n    if (typeof length !== 'number')\n      length = buffer.byteLength - offset;\n    validateOffsetLengthWrite(offset, length, buffer.byteLength);\n    result = binding.writeBuffer(fd, buffer, offset, length, position,\n                                 undefined, ctx);\n  } else {\n    validateStringAfterArrayBufferView(buffer, 'buffer');\n\n    if (offset === undefined)\n      offset = null;\n    result = binding.writeString(fd, buffer, offset, length,\n                                 undefined, ctx);\n  }\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n// usage:\n// fs.writev(fd, buffers[, position], callback);\nfunction writev(fd, buffers, position, callback) {\n  function wrapper(err, written) {\n    callback(err, written || 0, buffers);\n  }\n\n  validateInt32(fd, 'fd', 0);\n  validateBufferArray(buffers);\n  callback = maybeCallback(callback || position);\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n\n  if (typeof position !== 'number')\n    position = null;\n\n  return binding.writeBuffers(fd, buffers, position, req);\n}\n\nObjectDefineProperty(writev, internalUtil.customPromisifyArgs, {\n  value: ['bytesWritten', 'buffer'],\n  enumerable: false\n});\n\nfunction writevSync(fd, buffers, position) {\n  validateInt32(fd, 'fd', 0);\n  validateBufferArray(buffers);\n\n  const ctx = {};\n\n  if (typeof position !== 'number')\n    position = null;\n\n  const result = binding.writeBuffers(fd, buffers, position, undefined, ctx);\n\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\nfunction rename(oldPath, newPath, callback) {\n  callback = makeCallback(callback);\n  oldPath = getValidatedPath(oldPath, 'oldPath');\n  newPath = getValidatedPath(newPath, 'newPath');\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.rename(pathModule.toNamespacedPath(oldPath),\n                 pathModule.toNamespacedPath(newPath),\n                 req);\n}\n\nfunction renameSync(oldPath, newPath) {\n  oldPath = getValidatedPath(oldPath, 'oldPath');\n  newPath = getValidatedPath(newPath, 'newPath');\n  const ctx = { path: oldPath, dest: newPath };\n  binding.rename(pathModule.toNamespacedPath(oldPath),\n                 pathModule.toNamespacedPath(newPath), undefined, ctx);\n  handleErrorFromBinding(ctx);\n}\n\nfunction truncate(path, len, callback) {\n  if (typeof path === 'number') {\n    showTruncateDeprecation();\n    return fs.ftruncate(path, len, callback);\n  }\n  if (typeof len === 'function') {\n    callback = len;\n    len = 0;\n  } else if (len === undefined) {\n    len = 0;\n  }\n\n  validateInteger(len, 'len');\n  callback = maybeCallback(callback);\n  fs.open(path, 'r+', (er, fd) => {\n    if (er) return callback(er);\n    const req = new FSReqCallback();\n    req.oncomplete = function oncomplete(er) {\n      fs.close(fd, (er2) => {\n        callback(er || er2);\n      });\n    };\n    binding.ftruncate(fd, len, req);\n  });\n}\n\nfunction truncateSync(path, len) {\n  if (typeof path === 'number') {\n    // legacy\n    showTruncateDeprecation();\n    return fs.ftruncateSync(path, len);\n  }\n  if (len === undefined) {\n    len = 0;\n  }\n  // Allow error to be thrown, but still close fd.\n  const fd = fs.openSync(path, 'r+');\n  let ret;\n\n  try {\n    ret = fs.ftruncateSync(fd, len);\n  } finally {\n    fs.closeSync(fd);\n  }\n  return ret;\n}\n\nfunction ftruncate(fd, len = 0, callback) {\n  if (typeof len === 'function') {\n    callback = len;\n    len = 0;\n  }\n  validateInt32(fd, 'fd', 0);\n  validateInteger(len, 'len');\n  len = MathMax(0, len);\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.ftruncate(fd, len, req);\n}\n\nfunction ftruncateSync(fd, len = 0) {\n  validateInt32(fd, 'fd', 0);\n  validateInteger(len, 'len');\n  len = MathMax(0, len);\n  const ctx = {};\n  binding.ftruncate(fd, len, undefined, ctx);\n  handleErrorFromBinding(ctx);\n}\n\n\nfunction lazyLoadRimraf() {\n  if (rimraf === undefined)\n    ({ rimraf, rimrafSync } = require('internal/fs/rimraf'));\n}\n\nfunction rmdir(path, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  callback = makeCallback(callback);\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\n\n  if (options && options.recursive) {\n    validateRmOptions(path, { ...options, force: true }, (err, options) => {\n      if (err) {\n        return callback(err);\n      }\n\n      lazyLoadRimraf();\n      return rimraf(path, options, callback);\n    });\n  } else {\n    validateRmdirOptions(options);\n    const req = new FSReqCallback();\n    req.oncomplete = callback;\n    return binding.rmdir(path, req);\n  }\n}\n\nfunction rmdirSync(path, options) {\n  path = getValidatedPath(path);\n\n  if (options && options.recursive) {\n    options = validateRmOptionsSync(path, { ...options, force: true });\n    lazyLoadRimraf();\n    return rimrafSync(pathModule.toNamespacedPath(path), options);\n  }\n\n  validateRmdirOptions(options);\n  const ctx = { path };\n  binding.rmdir(pathModule.toNamespacedPath(path), undefined, ctx);\n  return handleErrorFromBinding(ctx);\n}\n\nfunction rm(path, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  validateRmOptions(path, options, (err, options) => {\n    if (err) {\n      return callback(err);\n    }\n    lazyLoadRimraf();\n    return rimraf(pathModule.toNamespacedPath(path), options, callback);\n  });\n}\n\nfunction rmSync(path, options) {\n  options = validateRmOptionsSync(path, options);\n\n  lazyLoadRimraf();\n  return rimrafSync(pathModule.toNamespacedPath(path), options);\n}\n\nfunction fdatasync(fd, callback) {\n  validateInt32(fd, 'fd', 0);\n  const req = new FSReqCallback();\n  req.oncomplete = makeCallback(callback);\n  binding.fdatasync(fd, req);\n}\n\nfunction fdatasyncSync(fd) {\n  validateInt32(fd, 'fd', 0);\n  const ctx = {};\n  binding.fdatasync(fd, undefined, ctx);\n  handleErrorFromBinding(ctx);\n}\n\nfunction fsync(fd, callback) {\n  validateInt32(fd, 'fd', 0);\n  const req = new FSReqCallback();\n  req.oncomplete = makeCallback(callback);\n  binding.fsync(fd, req);\n}\n\nfunction fsyncSync(fd) {\n  validateInt32(fd, 'fd', 0);\n  const ctx = {};\n  binding.fsync(fd, undefined, ctx);\n  handleErrorFromBinding(ctx);\n}\n\nfunction mkdir(path, options, callback) {\n  let mode = 0o777;\n  let recursive = false;\n  if (typeof options === 'function') {\n    callback = options;\n  } else if (typeof options === 'number' || typeof options === 'string') {\n    mode = options;\n  } else if (options) {\n    if (options.recursive !== undefined)\n      recursive = options.recursive;\n    if (options.mode !== undefined)\n      mode = options.mode;\n  }\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n\n  if (typeof recursive !== 'boolean')\n    throw new ERR_INVALID_ARG_TYPE('options.recursive', 'boolean', recursive);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.mkdir(pathModule.toNamespacedPath(path),\n                parseFileMode(mode, 'mode'), recursive, req);\n}\n\nfunction mkdirSync(path, options) {\n  let mode = 0o777;\n  let recursive = false;\n  if (typeof options === 'number' || typeof options === 'string') {\n    mode = options;\n  } else if (options) {\n    if (options.recursive !== undefined)\n      recursive = options.recursive;\n    if (options.mode !== undefined)\n      mode = options.mode;\n  }\n  path = getValidatedPath(path);\n  if (typeof recursive !== 'boolean')\n    throw new ERR_INVALID_ARG_TYPE('options.recursive', 'boolean', recursive);\n\n  const ctx = { path };\n  const result = binding.mkdir(pathModule.toNamespacedPath(path),\n                               parseFileMode(mode, 'mode'), recursive,\n                               undefined, ctx);\n  handleErrorFromBinding(ctx);\n  if (recursive) {\n    return result;\n  }\n}\n\nfunction readdir(path, options, callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options, {});\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  if (!options.withFileTypes) {\n    req.oncomplete = callback;\n  } else {\n    req.oncomplete = (err, result) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n      getDirents(path, result, callback);\n    };\n  }\n  binding.readdir(pathModule.toNamespacedPath(path), options.encoding,\n                  !!options.withFileTypes, req);\n}\n\nfunction readdirSync(path, options) {\n  options = getOptions(options, {});\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const result = binding.readdir(pathModule.toNamespacedPath(path),\n                                 options.encoding, !!options.withFileTypes,\n                                 undefined, ctx);\n  handleErrorFromBinding(ctx);\n  return options.withFileTypes ? getDirents(path, result) : result;\n}\n\nfunction fstat(fd, options = { bigint: false }, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  validateInt32(fd, 'fd', 0);\n  callback = makeStatsCallback(callback);\n\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.fstat(fd, options.bigint, req);\n}\n\nfunction lstat(path, options = { bigint: false }, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  callback = makeStatsCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.lstat(pathModule.toNamespacedPath(path), options.bigint, req);\n}\n\nfunction stat(path, options = { bigint: false }, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  callback = makeStatsCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.stat(pathModule.toNamespacedPath(path), options.bigint, req);\n}\n\nfunction fstatSync(fd, options = { bigint: false }) {\n  validateInt32(fd, 'fd', 0);\n  const ctx = { fd };\n  const stats = binding.fstat(fd, options.bigint, undefined, ctx);\n  handleErrorFromBinding(ctx);\n  return getStatsFromBinding(stats);\n}\n\nfunction lstatSync(path, options = { bigint: false }) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const stats = binding.lstat(pathModule.toNamespacedPath(path),\n                              options.bigint, undefined, ctx);\n  handleErrorFromBinding(ctx);\n  return getStatsFromBinding(stats);\n}\n\nfunction statSync(path, options = { bigint: false }) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const stats = binding.stat(pathModule.toNamespacedPath(path),\n                             options.bigint, undefined, ctx);\n  handleErrorFromBinding(ctx);\n  return getStatsFromBinding(stats);\n}\n\nfunction readlink(path, options, callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options, {});\n  path = getValidatedPath(path, 'oldPath');\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.readlink(pathModule.toNamespacedPath(path), options.encoding, req);\n}\n\nfunction readlinkSync(path, options) {\n  options = getOptions(options, {});\n  path = getValidatedPath(path, 'oldPath');\n  const ctx = { path };\n  const result = binding.readlink(pathModule.toNamespacedPath(path),\n                                  options.encoding, undefined, ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\nfunction symlink(target, path, type_, callback_) {\n  const type = (typeof type_ === 'string' ? type_ : null);\n  const callback = makeCallback(arguments[arguments.length - 1]);\n\n  target = getValidatedPath(target, 'target');\n  path = getValidatedPath(path);\n\n  if (isWindows && type === null) {\n    let absoluteTarget;\n    try {\n      // Symlinks targets can be relative to the newly created path.\n      // Calculate absolute file name of the symlink target, and check\n      // if it is a directory. Ignore resolve error to keep symlink\n      // errors consistent between platforms if invalid path is\n      // provided.\n      absoluteTarget = pathModule.resolve(path, '..', target);\n    } catch { }\n    if (absoluteTarget !== undefined) {\n      stat(absoluteTarget, (err, stat) => {\n        const resolvedType = !err && stat.isDirectory() ? 'dir' : 'file';\n        const resolvedFlags = stringToSymlinkType(resolvedType);\n        const destination = preprocessSymlinkDestination(target,\n                                                         resolvedType,\n                                                         path);\n\n        const req = new FSReqCallback();\n        req.oncomplete = callback;\n        binding.symlink(destination,\n                        pathModule.toNamespacedPath(path), resolvedFlags, req);\n      });\n      return;\n    }\n  }\n\n  const destination = preprocessSymlinkDestination(target, type, path);\n\n  const flags = stringToSymlinkType(type);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.symlink(destination, pathModule.toNamespacedPath(path), flags, req);\n}\n\nfunction symlinkSync(target, path, type) {\n  type = (typeof type === 'string' ? type : null);\n  if (isWindows && type === null) {\n    try {\n      const absoluteTarget = pathModule.resolve(path, '..', target);\n      if (statSync(absoluteTarget).isDirectory()) {\n        type = 'dir';\n      }\n    } catch { }\n  }\n  target = getValidatedPath(target, 'target');\n  path = getValidatedPath(path);\n  const flags = stringToSymlinkType(type);\n\n  const ctx = { path: target, dest: path };\n  binding.symlink(preprocessSymlinkDestination(target, type, path),\n                  pathModule.toNamespacedPath(path), flags, undefined, ctx);\n\n  handleErrorFromBinding(ctx);\n}\n\nfunction link(existingPath, newPath, callback) {\n  callback = makeCallback(callback);\n\n  existingPath = getValidatedPath(existingPath, 'existingPath');\n  newPath = getValidatedPath(newPath, 'newPath');\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n\n  binding.link(pathModule.toNamespacedPath(existingPath),\n               pathModule.toNamespacedPath(newPath),\n               req);\n}\n\nfunction linkSync(existingPath, newPath) {\n  existingPath = getValidatedPath(existingPath, 'existingPath');\n  newPath = getValidatedPath(newPath, 'newPath');\n\n  const ctx = { path: existingPath, dest: newPath };\n  const result = binding.link(pathModule.toNamespacedPath(existingPath),\n                              pathModule.toNamespacedPath(newPath),\n                              undefined, ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\nfunction unlink(path, callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.unlink(pathModule.toNamespacedPath(path), req);\n}\n\nfunction unlinkSync(path) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  binding.unlink(pathModule.toNamespacedPath(path), undefined, ctx);\n  handleErrorFromBinding(ctx);\n}\n\nfunction fchmod(fd, mode, callback) {\n  validateInt32(fd, 'fd', 0);\n  mode = parseFileMode(mode, 'mode');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.fchmod(fd, mode, req);\n}\n\nfunction fchmodSync(fd, mode) {\n  validateInt32(fd, 'fd', 0);\n  mode = parseFileMode(mode, 'mode');\n  const ctx = {};\n  binding.fchmod(fd, mode, undefined, ctx);\n  handleErrorFromBinding(ctx);\n}\n\nfunction lchmod(path, mode, callback) {\n  callback = maybeCallback(callback);\n  fs.open(path, O_WRONLY | O_SYMLINK, (err, fd) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n    // Prefer to return the chmod error, if one occurs,\n    // but still try to close, and report closing errors if they occur.\n    fs.fchmod(fd, mode, (err) => {\n      fs.close(fd, (err2) => {\n        callback(err || err2);\n      });\n    });\n  });\n}\n\nfunction lchmodSync(path, mode) {\n  const fd = fs.openSync(path, O_WRONLY | O_SYMLINK);\n\n  // Prefer to return the chmod error, if one occurs,\n  // but still try to close, and report closing errors if they occur.\n  let ret;\n  try {\n    ret = fs.fchmodSync(fd, mode);\n  } finally {\n    fs.closeSync(fd);\n  }\n  return ret;\n}\n\n\nfunction chmod(path, mode, callback) {\n  path = getValidatedPath(path);\n  mode = parseFileMode(mode, 'mode');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.chmod(pathModule.toNamespacedPath(path), mode, req);\n}\n\nfunction chmodSync(path, mode) {\n  path = getValidatedPath(path);\n  mode = parseFileMode(mode, 'mode');\n\n  const ctx = { path };\n  binding.chmod(pathModule.toNamespacedPath(path), mode, undefined, ctx);\n  handleErrorFromBinding(ctx);\n}\n\nfunction lchown(path, uid, gid, callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  validateInteger(uid, 'uid', -1, kMaxUserId);\n  validateInteger(gid, 'gid', -1, kMaxUserId);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.lchown(pathModule.toNamespacedPath(path), uid, gid, req);\n}\n\nfunction lchownSync(path, uid, gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid, 'uid', -1, kMaxUserId);\n  validateInteger(gid, 'gid', -1, kMaxUserId);\n  const ctx = { path };\n  binding.lchown(pathModule.toNamespacedPath(path), uid, gid, undefined, ctx);\n  handleErrorFromBinding(ctx);\n}\n\nfunction fchown(fd, uid, gid, callback) {\n  validateInt32(fd, 'fd', 0);\n  validateInteger(uid, 'uid', -1, kMaxUserId);\n  validateInteger(gid, 'gid', -1, kMaxUserId);\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.fchown(fd, uid, gid, req);\n}\n\nfunction fchownSync(fd, uid, gid) {\n  validateInt32(fd, 'fd', 0);\n  validateInteger(uid, 'uid', -1, kMaxUserId);\n  validateInteger(gid, 'gid', -1, kMaxUserId);\n\n  const ctx = {};\n  binding.fchown(fd, uid, gid, undefined, ctx);\n  handleErrorFromBinding(ctx);\n}\n\nfunction chown(path, uid, gid, callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  validateInteger(uid, 'uid', -1, kMaxUserId);\n  validateInteger(gid, 'gid', -1, kMaxUserId);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.chown(pathModule.toNamespacedPath(path), uid, gid, req);\n}\n\nfunction chownSync(path, uid, gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid, 'uid', -1, kMaxUserId);\n  validateInteger(gid, 'gid', -1, kMaxUserId);\n  const ctx = { path };\n  binding.chown(pathModule.toNamespacedPath(path), uid, gid, undefined, ctx);\n  handleErrorFromBinding(ctx);\n}\n\nfunction utimes(path, atime, mtime, callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.utimes(pathModule.toNamespacedPath(path),\n                 toUnixTimestamp(atime),\n                 toUnixTimestamp(mtime),\n                 req);\n}\n\nfunction utimesSync(path, atime, mtime) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  binding.utimes(pathModule.toNamespacedPath(path),\n                 toUnixTimestamp(atime), toUnixTimestamp(mtime),\n                 undefined, ctx);\n  handleErrorFromBinding(ctx);\n}\n\nfunction futimes(fd, atime, mtime, callback) {\n  validateInt32(fd, 'fd', 0);\n  atime = toUnixTimestamp(atime, 'atime');\n  mtime = toUnixTimestamp(mtime, 'mtime');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.futimes(fd, atime, mtime, req);\n}\n\nfunction futimesSync(fd, atime, mtime) {\n  validateInt32(fd, 'fd', 0);\n  atime = toUnixTimestamp(atime, 'atime');\n  mtime = toUnixTimestamp(mtime, 'mtime');\n  const ctx = {};\n  binding.futimes(fd, atime, mtime, undefined, ctx);\n  handleErrorFromBinding(ctx);\n}\n\nfunction lutimes(path, atime, mtime, callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.lutimes(pathModule.toNamespacedPath(path),\n                  toUnixTimestamp(atime),\n                  toUnixTimestamp(mtime),\n                  req);\n}\n\nfunction lutimesSync(path, atime, mtime) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  binding.lutimes(pathModule.toNamespacedPath(path),\n                  toUnixTimestamp(atime),\n                  toUnixTimestamp(mtime),\n                  undefined, ctx);\n  handleErrorFromBinding(ctx);\n}\n\nfunction writeAll(fd, isUserFd, buffer, offset, length, callback) {\n  // write(fd, buffer, offset, length, position, callback)\n  fs.write(fd, buffer, offset, length, null, (writeErr, written) => {\n    if (writeErr) {\n      if (isUserFd) {\n        callback(writeErr);\n      } else {\n        fs.close(fd, function close() {\n          callback(writeErr);\n        });\n      }\n    } else if (written === length) {\n      if (isUserFd) {\n        callback(null);\n      } else {\n        fs.close(fd, callback);\n      }\n    } else {\n      offset += written;\n      length -= written;\n      writeAll(fd, isUserFd, buffer, offset, length, callback);\n    }\n  });\n}\n\nfunction writeFile(path, data, options, callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'w' });\n  const flag = options.flag || 'w';\n\n  if (!isArrayBufferView(data)) {\n    validateStringAfterArrayBufferView(data, 'data');\n    data = Buffer.from(String(data), options.encoding || 'utf8');\n  }\n\n  if (isFd(path)) {\n    const isUserFd = true;\n    writeAll(path, isUserFd, data, 0, data.byteLength, callback);\n    return;\n  }\n\n  fs.open(path, flag, options.mode, (openErr, fd) => {\n    if (openErr) {\n      callback(openErr);\n    } else {\n      const isUserFd = false;\n      writeAll(fd, isUserFd, data, 0, data.byteLength, callback);\n    }\n  });\n}\n\nfunction writeFileSync(path, data, options) {\n  options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'w' });\n\n  if (!isArrayBufferView(data)) {\n    validateStringAfterArrayBufferView(data, 'data');\n    data = Buffer.from(String(data), options.encoding || 'utf8');\n  }\n\n  const flag = options.flag || 'w';\n\n  const isUserFd = isFd(path); // File descriptor ownership\n  const fd = isUserFd ? path : fs.openSync(path, flag, options.mode);\n\n  let offset = 0;\n  let length = data.byteLength;\n  try {\n    while (length > 0) {\n      const written = fs.writeSync(fd, data, offset, length);\n      offset += written;\n      length -= written;\n    }\n  } finally {\n    if (!isUserFd) fs.closeSync(fd);\n  }\n}\n\nfunction appendFile(path, data, options, callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'a' });\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  // Force append behavior when using a supplied file descriptor\n  if (!options.flag || isFd(path))\n    options.flag = 'a';\n\n  fs.writeFile(path, data, options, callback);\n}\n\nfunction appendFileSync(path, data, options) {\n  options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'a' });\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  // Force append behavior when using a supplied file descriptor\n  if (!options.flag || isFd(path))\n    options.flag = 'a';\n\n  fs.writeFileSync(path, data, options);\n}\n\nfunction watch(filename, options, listener) {\n  if (typeof options === 'function') {\n    listener = options;\n  }\n  options = getOptions(options, {});\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  if (options.persistent === undefined) options.persistent = true;\n  if (options.recursive === undefined) options.recursive = false;\n  if (options.recursive && !(isOSX || isWindows))\n    throw new ERR_FEATURE_UNAVAILABLE_ON_PLATFORM('watch recursively');\n  if (!watchers)\n    watchers = require('internal/fs/watchers');\n  const watcher = new watchers.FSWatcher();\n  watcher[watchers.kFSWatchStart](filename,\n                                  options.persistent,\n                                  options.recursive,\n                                  options.encoding);\n\n  if (listener) {\n    watcher.addListener('change', listener);\n  }\n\n  return watcher;\n}\n\n\nconst statWatchers = new Map();\n\nfunction watchFile(filename, options, listener) {\n  filename = getValidatedPath(filename);\n  filename = pathModule.resolve(filename);\n  let stat;\n\n  if (options === null || typeof options !== 'object') {\n    listener = options;\n    options = null;\n  }\n\n  options = {\n    // Poll interval in milliseconds. 5007 is what libev used to use. It's\n    // a little on the slow side but let's stick with it for now to keep\n    // behavioral changes to a minimum.\n    interval: 5007,\n    persistent: true,\n    ...options\n  };\n\n  if (typeof listener !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('listener', 'Function', listener);\n  }\n\n  stat = statWatchers.get(filename);\n\n  if (stat === undefined) {\n    if (!watchers)\n      watchers = require('internal/fs/watchers');\n    stat = new watchers.StatWatcher(options.bigint);\n    stat[watchers.kFSStatWatcherStart](filename,\n                                       options.persistent, options.interval);\n    statWatchers.set(filename, stat);\n  } else {\n    stat[watchers.kFSStatWatcherAddOrCleanRef]('add');\n  }\n\n  stat.addListener('change', listener);\n  return stat;\n}\n\nfunction unwatchFile(filename, listener) {\n  filename = getValidatedPath(filename);\n  filename = pathModule.resolve(filename);\n  const stat = statWatchers.get(filename);\n\n  if (stat === undefined) return;\n\n  if (typeof listener === 'function') {\n    const beforeListenerCount = stat.listenerCount('change');\n    stat.removeListener('change', listener);\n    if (stat.listenerCount('change') < beforeListenerCount)\n      stat[watchers.kFSStatWatcherAddOrCleanRef]('clean');\n  } else {\n    stat.removeAllListeners('change');\n    stat[watchers.kFSStatWatcherAddOrCleanRef]('cleanAll');\n  }\n\n  if (stat.listenerCount('change') === 0) {\n    stat.stop();\n    statWatchers.delete(filename);\n  }\n}\n\n\nlet splitRoot;\nif (isWindows) {\n  // Regex to find the device root on Windows (e.g. 'c:\\\\'), including trailing\n  // slash.\n  const splitRootRe = /^(?:[a-zA-Z]:|[\\\\/]{2}[^\\\\/]+[\\\\/][^\\\\/]+)?[\\\\/]*/;\n  splitRoot = function splitRoot(str) {\n    return splitRootRe.exec(str)[0];\n  };\n} else {\n  splitRoot = function splitRoot(str) {\n    for (let i = 0; i < str.length; ++i) {\n      if (str.charCodeAt(i) !== CHAR_FORWARD_SLASH)\n        return str.slice(0, i);\n    }\n    return str;\n  };\n}\n\nfunction encodeRealpathResult(result, options) {\n  if (!options || !options.encoding || options.encoding === 'utf8')\n    return result;\n  const asBuffer = Buffer.from(result);\n  if (options.encoding === 'buffer') {\n    return asBuffer;\n  }\n  return asBuffer.toString(options.encoding);\n}\n\n// Finds the next portion of a (partial) path, up to the next path delimiter\nlet nextPart;\nif (isWindows) {\n  nextPart = function nextPart(p, i) {\n    for (; i < p.length; ++i) {\n      const ch = p.charCodeAt(i);\n\n      // Check for a separator character\n      if (ch === CHAR_BACKWARD_SLASH || ch === CHAR_FORWARD_SLASH)\n        return i;\n    }\n    return -1;\n  };\n} else {\n  nextPart = function nextPart(p, i) { return p.indexOf('/', i); };\n}\n\nconst emptyObj = ObjectCreate(null);\nfunction realpathSync(p, options) {\n  options = getOptions(options, emptyObj);\n  p = toPathIfFileURL(p);\n  if (typeof p !== 'string') {\n    p += '';\n  }\n  validatePath(p);\n  p = pathModule.resolve(p);\n\n  const cache = options[realpathCacheKey];\n  const maybeCachedResult = cache && cache.get(p);\n  if (maybeCachedResult) {\n    return maybeCachedResult;\n  }\n\n  const seenLinks = ObjectCreate(null);\n  const knownHard = ObjectCreate(null);\n  const original = p;\n\n  // Current character position in p\n  let pos;\n  // The partial path so far, including a trailing slash if any\n  let current;\n  // The partial path without a trailing slash (except when pointing at a root)\n  let base;\n  // The partial path scanned in the previous round, with slash\n  let previous;\n\n  // Skip over roots\n  current = base = splitRoot(p);\n  pos = current.length;\n\n  // On windows, check that the root exists. On unix there is no need.\n  if (isWindows) {\n    const ctx = { path: base };\n    binding.lstat(pathModule.toNamespacedPath(base), false, undefined, ctx);\n    handleErrorFromBinding(ctx);\n    knownHard[base] = true;\n  }\n\n  // Walk down the path, swapping out linked path parts for their real\n  // values\n  // NB: p.length changes.\n  while (pos < p.length) {\n    // find the next part\n    const result = nextPart(p, pos);\n    previous = current;\n    if (result === -1) {\n      const last = p.slice(pos);\n      current += last;\n      base = previous + last;\n      pos = p.length;\n    } else {\n      current += p.slice(pos, result + 1);\n      base = previous + p.slice(pos, result);\n      pos = result + 1;\n    }\n\n    // Continue if not a symlink, break if a pipe/socket\n    if (knownHard[base] || (cache && cache.get(base) === base)) {\n      if (isFileType(statValues, S_IFIFO) ||\n          isFileType(statValues, S_IFSOCK)) {\n        break;\n      }\n      continue;\n    }\n\n    let resolvedLink;\n    const maybeCachedResolved = cache && cache.get(base);\n    if (maybeCachedResolved) {\n      resolvedLink = maybeCachedResolved;\n    } else {\n      // Use stats array directly to avoid creating an fs.Stats instance just\n      // for our internal use.\n\n      const baseLong = pathModule.toNamespacedPath(base);\n      const ctx = { path: base };\n      const stats = binding.lstat(baseLong, true, undefined, ctx);\n      handleErrorFromBinding(ctx);\n\n      if (!isFileType(stats, S_IFLNK)) {\n        knownHard[base] = true;\n        if (cache) cache.set(base, base);\n        continue;\n      }\n\n      // Read the link if it wasn't read before\n      // dev/ino always return 0 on windows, so skip the check.\n      let linkTarget = null;\n      let id;\n      if (!isWindows) {\n        const dev = stats[0].toString(32);\n        const ino = stats[7].toString(32);\n        id = `${dev}:${ino}`;\n        if (seenLinks[id]) {\n          linkTarget = seenLinks[id];\n        }\n      }\n      if (linkTarget === null) {\n        const ctx = { path: base };\n        binding.stat(baseLong, false, undefined, ctx);\n        handleErrorFromBinding(ctx);\n        linkTarget = binding.readlink(baseLong, undefined, undefined, ctx);\n        handleErrorFromBinding(ctx);\n      }\n      resolvedLink = pathModule.resolve(previous, linkTarget);\n\n      if (cache) cache.set(base, resolvedLink);\n      if (!isWindows) seenLinks[id] = linkTarget;\n    }\n\n    // Resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n\n    // Skip over roots\n    current = base = splitRoot(p);\n    pos = current.length;\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      const ctx = { path: base };\n      binding.lstat(pathModule.toNamespacedPath(base), false, undefined, ctx);\n      handleErrorFromBinding(ctx);\n      knownHard[base] = true;\n    }\n  }\n\n  if (cache) cache.set(original, p);\n  return encodeRealpathResult(p, options);\n}\n\n\nrealpathSync.native = (path, options) => {\n  options = getOptions(options, {});\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const result = binding.realpath(path, options.encoding, undefined, ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n};\n\n\nfunction realpath(p, options, callback) {\n  callback = typeof options === 'function' ? options : maybeCallback(callback);\n  options = getOptions(options, {});\n  p = toPathIfFileURL(p);\n\n  if (typeof p !== 'string') {\n    p += '';\n  }\n  validatePath(p);\n  p = pathModule.resolve(p);\n\n  const seenLinks = ObjectCreate(null);\n  const knownHard = ObjectCreate(null);\n\n  // Current character position in p\n  let pos;\n  // The partial path so far, including a trailing slash if any\n  let current;\n  // The partial path without a trailing slash (except when pointing at a root)\n  let base;\n  // The partial path scanned in the previous round, with slash\n  let previous;\n\n  current = base = splitRoot(p);\n  pos = current.length;\n\n  // On windows, check that the root exists. On unix there is no need.\n  if (isWindows && !knownHard[base]) {\n    fs.lstat(base, (err, stats) => {\n      if (err) return callback(err);\n      knownHard[base] = true;\n      LOOP();\n    });\n  } else {\n    process.nextTick(LOOP);\n  }\n\n  // Walk down the path, swapping out linked path parts for their real\n  // values\n  function LOOP() {\n    // Stop if scanned past end of path\n    if (pos >= p.length) {\n      return callback(null, encodeRealpathResult(p, options));\n    }\n\n    // find the next part\n    const result = nextPart(p, pos);\n    previous = current;\n    if (result === -1) {\n      const last = p.slice(pos);\n      current += last;\n      base = previous + last;\n      pos = p.length;\n    } else {\n      current += p.slice(pos, result + 1);\n      base = previous + p.slice(pos, result);\n      pos = result + 1;\n    }\n\n    // Continue if not a symlink, break if a pipe/socket\n    if (knownHard[base]) {\n      if (isFileType(statValues, S_IFIFO) ||\n          isFileType(statValues, S_IFSOCK)) {\n        return callback(null, encodeRealpathResult(p, options));\n      }\n      return process.nextTick(LOOP);\n    }\n\n    return fs.lstat(base, { bigint: true }, gotStat);\n  }\n\n  function gotStat(err, stats) {\n    if (err) return callback(err);\n\n    // If not a symlink, skip to the next path part\n    if (!stats.isSymbolicLink()) {\n      knownHard[base] = true;\n      return process.nextTick(LOOP);\n    }\n\n    // Stat & read the link if not read before.\n    // Call `gotTarget()` as soon as the link target is known.\n    // `dev`/`ino` always return 0 on windows, so skip the check.\n    let id;\n    if (!isWindows) {\n      const dev = stats.dev.toString(32);\n      const ino = stats.ino.toString(32);\n      id = `${dev}:${ino}`;\n      if (seenLinks[id]) {\n        return gotTarget(null, seenLinks[id]);\n      }\n    }\n    fs.stat(base, (err) => {\n      if (err) return callback(err);\n\n      fs.readlink(base, (err, target) => {\n        if (!isWindows) seenLinks[id] = target;\n        gotTarget(err, target);\n      });\n    });\n  }\n\n  function gotTarget(err, target) {\n    if (err) return callback(err);\n\n    gotResolvedLink(pathModule.resolve(previous, target));\n  }\n\n  function gotResolvedLink(resolvedLink) {\n    // Resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    current = base = splitRoot(p);\n    pos = current.length;\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstat(base, (err) => {\n        if (err) return callback(err);\n        knownHard[base] = true;\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  }\n}\n\n\nrealpath.native = (path, options, callback) => {\n  callback = makeCallback(callback || options);\n  options = getOptions(options, {});\n  path = getValidatedPath(path);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  return binding.realpath(path, options.encoding, req);\n};\n\nfunction mkdtemp(prefix, options, callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options, {});\n  if (!prefix || typeof prefix !== 'string') {\n    throw new ERR_INVALID_ARG_TYPE('prefix', 'string', prefix);\n  }\n  nullCheck(prefix, 'prefix');\n  warnOnNonPortableTemplate(prefix);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.mkdtemp(`${prefix}XXXXXX`, options.encoding, req);\n}\n\n\nfunction mkdtempSync(prefix, options) {\n  options = getOptions(options, {});\n  if (!prefix || typeof prefix !== 'string') {\n    throw new ERR_INVALID_ARG_TYPE('prefix', 'string', prefix);\n  }\n  nullCheck(prefix, 'prefix');\n  warnOnNonPortableTemplate(prefix);\n  const path = `${prefix}XXXXXX`;\n  const ctx = { path };\n  const result = binding.mkdtemp(path, options.encoding,\n                                 undefined, ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n\nfunction copyFile(src, dest, mode, callback) {\n  if (typeof mode === 'function') {\n    callback = mode;\n    mode = 0;\n  } else if (typeof callback !== 'function') {\n    throw new ERR_INVALID_CALLBACK(callback);\n  }\n\n  src = getValidatedPath(src, 'src');\n  dest = getValidatedPath(dest, 'dest');\n\n  src = pathModule._makeLong(src);\n  dest = pathModule._makeLong(dest);\n  mode = getValidMode(mode, 'copyFile');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.copyFile(src, dest, mode, req);\n}\n\n\nfunction copyFileSync(src, dest, mode) {\n  src = getValidatedPath(src, 'src');\n  dest = getValidatedPath(dest, 'dest');\n\n  const ctx = { path: src, dest };  // non-prefixed\n\n  src = pathModule._makeLong(src);\n  dest = pathModule._makeLong(dest);\n  mode = getValidMode(mode, 'copyFile');\n  binding.copyFile(src, dest, mode, undefined, ctx);\n  handleErrorFromBinding(ctx);\n}\n\nfunction lazyLoadStreams() {\n  if (!ReadStream) {\n    ({ ReadStream, WriteStream } = require('internal/fs/streams'));\n    [ FileReadStream, FileWriteStream ] = [ ReadStream, WriteStream ];\n  }\n}\n\nfunction createReadStream(path, options) {\n  lazyLoadStreams();\n  return new ReadStream(path, options);\n}\n\nfunction createWriteStream(path, options) {\n  lazyLoadStreams();\n  return new WriteStream(path, options);\n}\n\nmodule.exports = fs = {\n  appendFile,\n  appendFileSync,\n  access,\n  accessSync,\n  chown,\n  chownSync,\n  chmod,\n  chmodSync,\n  close,\n  closeSync,\n  copyFile,\n  copyFileSync,\n  createReadStream,\n  createWriteStream,\n  exists,\n  existsSync,\n  fchown,\n  fchownSync,\n  fchmod,\n  fchmodSync,\n  fdatasync,\n  fdatasyncSync,\n  fstat,\n  fstatSync,\n  fsync,\n  fsyncSync,\n  ftruncate,\n  ftruncateSync,\n  futimes,\n  futimesSync,\n  lchown,\n  lchownSync,\n  lchmod: constants.O_SYMLINK !== undefined ? lchmod : undefined,\n  lchmodSync: constants.O_SYMLINK !== undefined ? lchmodSync : undefined,\n  link,\n  linkSync,\n  lstat,\n  lstatSync,\n  lutimes,\n  lutimesSync,\n  mkdir,\n  mkdirSync,\n  mkdtemp,\n  mkdtempSync,\n  open,\n  openSync,\n  opendir,\n  opendirSync,\n  readdir,\n  readdirSync,\n  read,\n  readSync,\n  readv,\n  readvSync,\n  readFile,\n  readFileSync,\n  readlink,\n  readlinkSync,\n  realpath,\n  realpathSync,\n  rename,\n  renameSync,\n  rm,\n  rmSync,\n  rmdir,\n  rmdirSync,\n  stat,\n  statSync,\n  symlink,\n  symlinkSync,\n  truncate,\n  truncateSync,\n  unwatchFile,\n  unlink,\n  unlinkSync,\n  utimes,\n  utimesSync,\n  watch,\n  watchFile,\n  writeFile,\n  writeFileSync,\n  write,\n  writeSync,\n  writev,\n  writevSync,\n  Dir,\n  Dirent,\n  Stats,\n\n  get ReadStream() {\n    lazyLoadStreams();\n    return ReadStream;\n  },\n\n  set ReadStream(val) {\n    ReadStream = val;\n  },\n\n  get WriteStream() {\n    lazyLoadStreams();\n    return WriteStream;\n  },\n\n  set WriteStream(val) {\n    WriteStream = val;\n  },\n\n  // Legacy names... these have to be separate because of how graceful-fs\n  // (and possibly other) modules monkey patch the values.\n  get FileReadStream() {\n    lazyLoadStreams();\n    return FileReadStream;\n  },\n\n  set FileReadStream(val) {\n    FileReadStream = val;\n  },\n\n  get FileWriteStream() {\n    lazyLoadStreams();\n    return FileWriteStream;\n  },\n\n  set FileWriteStream(val) {\n    FileWriteStream = val;\n  },\n\n  // For tests\n  _toUnixTimestamp: toUnixTimestamp\n};\n\nObjectDefineProperties(fs, {\n  F_OK: { enumerable: true, value: F_OK || 0 },\n  R_OK: { enumerable: true, value: R_OK || 0 },\n  W_OK: { enumerable: true, value: W_OK || 0 },\n  X_OK: { enumerable: true, value: X_OK || 0 },\n  constants: {\n    configurable: false,\n    enumerable: true,\n    value: constants\n  },\n  promises: {\n    configurable: true,\n    enumerable: true,\n    get() {\n      if (promises === null)\n        promises = require('internal/fs/promises').exports;\n      return promises;\n    }\n  }\n});\n"
  },
  {
    "url": "internal/assert.js",
    "ranges": [
      {
        "start": 0,
        "end": 26
      },
      {
        "start": 155,
        "end": 309
      },
      {
        "start": 426,
        "end": 474
      }
    ],
    "text": "'use strict';\n\nlet error;\nfunction lazyError() {\n  if (!error) {\n    error = require('internal/errors').codes.ERR_INTERNAL_ASSERTION;\n  }\n  return error;\n}\n\nfunction assert(value, message) {\n  if (!value) {\n    const ERR_INTERNAL_ASSERTION = lazyError();\n    throw new ERR_INTERNAL_ASSERTION(message);\n  }\n}\n\nfunction fail(message) {\n  const ERR_INTERNAL_ASSERTION = lazyError();\n  throw new ERR_INTERNAL_ASSERTION(message);\n}\n\nassert.fail = fail;\n\nmodule.exports = assert;\n"
  },
  {
    "url": "internal/async_hooks.js",
    "ranges": [
      {
        "start": 0,
        "end": 5221
      },
      {
        "start": 5275,
        "end": 5277
      },
      {
        "start": 5870,
        "end": 5946
      },
      {
        "start": 6444,
        "end": 6505
      },
      {
        "start": 6880,
        "end": 6882
      },
      {
        "start": 7231,
        "end": 7422
      },
      {
        "start": 8515,
        "end": 8616
      },
      {
        "start": 9566,
        "end": 9857
      },
      {
        "start": 10347,
        "end": 10350
      },
      {
        "start": 10650,
        "end": 10652
      },
      {
        "start": 10917,
        "end": 11032
      },
      {
        "start": 11237,
        "end": 11239
      },
      {
        "start": 11596,
        "end": 11598
      },
      {
        "start": 12734,
        "end": 12765
      },
      {
        "start": 12825,
        "end": 12853
      },
      {
        "start": 13144,
        "end": 13146
      },
      {
        "start": 13421,
        "end": 13423
      },
      {
        "start": 13549,
        "end": 13750
      },
      {
        "start": 13820,
        "end": 13822
      },
      {
        "start": 14012,
        "end": 14195
      },
      {
        "start": 14485,
        "end": 14488
      },
      {
        "start": 14577,
        "end": 14580
      },
      {
        "start": 15055,
        "end": 15057
      },
      {
        "start": 15120,
        "end": 15122
      },
      {
        "start": 15181,
        "end": 15183
      },
      {
        "start": 15238,
        "end": 15240
      },
      {
        "start": 15297,
        "end": 15299
      },
      {
        "start": 15360,
        "end": 15363
      },
      {
        "start": 15771,
        "end": 15774
      },
      {
        "start": 15950,
        "end": 15953
      },
      {
        "start": 16073,
        "end": 16076
      },
      {
        "start": 16286,
        "end": 16289
      },
      {
        "start": 16352,
        "end": 16418
      },
      {
        "start": 16988,
        "end": 17053
      },
      {
        "start": 17677,
        "end": 17680
      },
      {
        "start": 17756,
        "end": 17758
      },
      {
        "start": 17830,
        "end": 18879
      }
    ],
    "text": "'use strict';\n\nconst {\n  ArrayPrototypePop,\n  ArrayPrototypeSlice,\n  ArrayPrototypeUnshift,\n  ErrorCaptureStackTrace,\n  FunctionPrototypeBind,\n  ObjectPrototypeHasOwnProperty,\n  ObjectDefineProperty,\n  Promise,\n  ReflectApply,\n  Symbol,\n} = primordials;\n\nconst async_wrap = internalBinding('async_wrap');\nconst { setCallbackTrampoline } = async_wrap;\n/* async_hook_fields is a Uint32Array wrapping the uint32_t array of\n * Environment::AsyncHooks::fields_[]. Each index tracks the number of active\n * hooks for each type.\n *\n * async_id_fields is a Float64Array wrapping the double array of\n * Environment::AsyncHooks::async_id_fields_[]. Each index contains the ids for\n * the various asynchronous states of the application. These are:\n *  kExecutionAsyncId: The async_id assigned to the resource responsible for the\n *    current execution stack.\n *  kTriggerAsyncId: The async_id of the resource that caused (or 'triggered')\n *    the resource corresponding to the current execution stack.\n *  kAsyncIdCounter: Incremental counter tracking the next assigned async_id.\n *  kDefaultTriggerAsyncId: Written immediately before a resource's constructor\n *    that sets the value of the init()'s triggerAsyncId. The precedence order\n *    of retrieving the triggerAsyncId value is:\n *    1. the value passed directly to the constructor\n *    2. value set in kDefaultTriggerAsyncId\n *    3. executionAsyncId of the current resource.\n *\n * async_ids_stack is a Float64Array that contains part of the async ID\n * stack. Each pushAsyncContext() call adds two doubles to it, and each\n * popAsyncContext() call removes two doubles from it.\n * It has a fixed size, so if that is exceeded, calls to the native\n * side are used instead in pushAsyncContext() and popAsyncContext().\n */\nconst {\n  async_hook_fields,\n  async_id_fields,\n  execution_async_resources\n} = async_wrap;\n// Store the pair executionAsyncId and triggerAsyncId in a AliasedFloat64Array\n// in Environment::AsyncHooks::async_ids_stack_ which tracks the resource\n// responsible for the current execution stack. This is unwound as each resource\n// exits. In the case of a fatal exception this stack is emptied after calling\n// each hook's after() callback.\nconst {\n  pushAsyncContext: pushAsyncContext_,\n  popAsyncContext: popAsyncContext_,\n  executionAsyncResource: executionAsyncResource_,\n  clearAsyncIdStack,\n} = async_wrap;\n// For performance reasons, only track Promises when a hook is enabled.\nconst { enablePromiseHook, disablePromiseHook } = async_wrap;\n// Properties in active_hooks are used to keep track of the set of hooks being\n// executed in case another hook is enabled/disabled. The new set of hooks is\n// then restored once the active set of hooks is finished executing.\nconst active_hooks = {\n  // Array of all AsyncHooks that will be iterated whenever an async event\n  // fires. Using var instead of (preferably const) in order to assign\n  // active_hooks.tmp_array if a hook is enabled/disabled during hook\n  // execution.\n  array: [],\n  // Use a counter to track nested calls of async hook callbacks and make sure\n  // the active_hooks.array isn't altered mid execution.\n  call_depth: 0,\n  // Use to temporarily store and updated active_hooks.array if the user\n  // enables or disables a hook while hooks are being processed. If a hook is\n  // enabled() or disabled() during hook execution then the current set of\n  // active hooks is duplicated and set equal to active_hooks.tmp_array. Any\n  // subsequent changes are on the duplicated array. When all hooks have\n  // completed executing active_hooks.tmp_array is assigned to\n  // active_hooks.array.\n  tmp_array: null,\n  // Keep track of the field counts held in active_hooks.tmp_array. Because the\n  // async_hook_fields can't be reassigned, store each uint32 in an array that\n  // is written back to async_hook_fields when active_hooks.array is restored.\n  tmp_fields: null\n};\n\nconst { registerDestroyHook } = async_wrap;\nconst { enqueueMicrotask } = internalBinding('task_queue');\nconst { resource_symbol, owner_symbol } = internalBinding('symbols');\n\n// Each constant tracks how many callbacks there are for any given step of\n// async execution. These are tracked so if the user didn't include callbacks\n// for a given step, that step can bail out early.\nconst { kInit, kBefore, kAfter, kDestroy, kTotals, kPromiseResolve,\n        kCheck, kExecutionAsyncId, kAsyncIdCounter, kTriggerAsyncId,\n        kDefaultTriggerAsyncId, kStackLength, kUsesExecutionAsyncResource\n} = async_wrap.constants;\n\nconst { async_id_symbol,\n        trigger_async_id_symbol } = internalBinding('symbols');\n\n// Used in AsyncHook and AsyncResource.\nconst init_symbol = Symbol('init');\nconst before_symbol = Symbol('before');\nconst after_symbol = Symbol('after');\nconst destroy_symbol = Symbol('destroy');\nconst promise_resolve_symbol = Symbol('promiseResolve');\nconst emitBeforeNative = emitHookFactory(before_symbol, 'emitBeforeNative');\nconst emitAfterNative = emitHookFactory(after_symbol, 'emitAfterNative');\nconst emitDestroyNative = emitHookFactory(destroy_symbol, 'emitDestroyNative');\nconst emitPromiseResolveNative =\n    emitHookFactory(promise_resolve_symbol, 'emitPromiseResolveNative');\n\nlet domain_cb;\nfunction useDomainTrampoline(fn) {\n  domain_cb = fn;\n}\n\nfunction callbackTrampoline(asyncId, resource, cb, ...args) {\n  const index = async_hook_fields[kStackLength] - 1;\n  execution_async_resources[index] = resource;\n\n  if (asyncId !== 0 && hasHooks(kBefore))\n    emitBeforeNative(asyncId);\n\n  let result;\n  if (asyncId === 0 && typeof domain_cb === 'function') {\n    ArrayPrototypeUnshift(args, cb);\n    result = ReflectApply(domain_cb, this, args);\n  } else {\n    result = ReflectApply(cb, this, args);\n  }\n\n  if (asyncId !== 0 && hasHooks(kAfter))\n    emitAfterNative(asyncId);\n\n  ArrayPrototypePop(execution_async_resources);\n  return result;\n}\n\nsetCallbackTrampoline(callbackTrampoline);\n\nconst topLevelResource = {};\n\nfunction executionAsyncResource() {\n  // Indicate to the native layer that this function is likely to be used,\n  // in which case it will inform JS about the current async resource via\n  // the trampoline above.\n  async_hook_fields[kUsesExecutionAsyncResource] = 1;\n\n  const index = async_hook_fields[kStackLength] - 1;\n  if (index === -1) return topLevelResource;\n  const resource = execution_async_resources[index] ||\n    executionAsyncResource_(index);\n  return lookupPublicResource(resource);\n}\n\n// Used to fatally abort the process if a callback throws.\nfunction fatalError(e) {\n  if (typeof e.stack === 'string') {\n    process._rawDebug(e.stack);\n  } else {\n    const o = { message: e };\n    ErrorCaptureStackTrace(o, fatalError);\n    process._rawDebug(o.stack);\n  }\n\n  const { getOptionValue } = require('internal/options');\n  if (getOptionValue('--abort-on-uncaught-exception')) {\n    process.abort();\n  }\n  process.exit(1);\n}\n\nfunction lookupPublicResource(resource) {\n  if (typeof resource !== 'object' || resource === null) return resource;\n  // TODO(addaleax): Merge this with owner_symbol and use it across all\n  // AsyncWrap instances.\n  const publicResource = resource[resource_symbol];\n  if (publicResource !== undefined)\n    return publicResource;\n  return resource;\n}\n\n// Emit From Native //\n\n// Used by C++ to call all init() callbacks. Because some state can be setup\n// from C++ there's no need to perform all the same operations as in\n// emitInitScript.\nfunction emitInitNative(asyncId, type, triggerAsyncId, resource) {\n  active_hooks.call_depth += 1;\n  resource = lookupPublicResource(resource);\n  // Use a single try/catch for all hooks to avoid setting up one per iteration.\n  try {\n    // Using var here instead of let because \"for (var ...)\" is faster than let.\n    // Refs: https://github.com/nodejs/node/pull/30380#issuecomment-552948364\n    for (var i = 0; i < active_hooks.array.length; i++) {\n      if (typeof active_hooks.array[i][init_symbol] === 'function') {\n        active_hooks.array[i][init_symbol](\n          asyncId, type, triggerAsyncId,\n          resource\n        );\n      }\n    }\n  } catch (e) {\n    fatalError(e);\n  } finally {\n    active_hooks.call_depth -= 1;\n  }\n\n  // Hooks can only be restored if there have been no recursive hook calls.\n  // Also the active hooks do not need to be restored if enable()/disable()\n  // weren't called during hook execution, in which case active_hooks.tmp_array\n  // will be null.\n  if (active_hooks.call_depth === 0 && active_hooks.tmp_array !== null) {\n    restoreActiveHooks();\n  }\n}\n\n// Called from native. The asyncId stack handling is taken care of there\n// before this is called.\nfunction emitHook(symbol, asyncId) {\n  active_hooks.call_depth += 1;\n  // Use a single try/catch for all hook to avoid setting up one per\n  // iteration.\n  try {\n    // Using var here instead of let because \"for (var ...)\" is faster than let.\n    // Refs: https://github.com/nodejs/node/pull/30380#issuecomment-552948364\n    for (var i = 0; i < active_hooks.array.length; i++) {\n      if (typeof active_hooks.array[i][symbol] === 'function') {\n        active_hooks.array[i][symbol](asyncId);\n      }\n    }\n  } catch (e) {\n    fatalError(e);\n  } finally {\n    active_hooks.call_depth -= 1;\n  }\n\n  // Hooks can only be restored if there have been no recursive hook calls.\n  // Also the active hooks do not need to be restored if enable()/disable()\n  // weren't called during hook execution, in which case\n  // active_hooks.tmp_array will be null.\n  if (active_hooks.call_depth === 0 && active_hooks.tmp_array !== null) {\n    restoreActiveHooks();\n  }\n}\n\nfunction emitHookFactory(symbol, name) {\n  const fn = FunctionPrototypeBind(emitHook, undefined, symbol);\n\n  // Set the name property of the function as it looks good in the stack trace.\n  ObjectDefineProperty(fn, 'name', {\n    value: name\n  });\n  return fn;\n}\n\n// Manage Active Hooks //\n\nfunction getHookArrays() {\n  if (active_hooks.call_depth === 0)\n    return [active_hooks.array, async_hook_fields];\n  // If this hook is being enabled while in the middle of processing the array\n  // of currently active hooks then duplicate the current set of active hooks\n  // and store this there. This shouldn't fire until the next time hooks are\n  // processed.\n  if (active_hooks.tmp_array === null)\n    storeActiveHooks();\n  return [active_hooks.tmp_array, active_hooks.tmp_fields];\n}\n\n\nfunction storeActiveHooks() {\n  active_hooks.tmp_array = ArrayPrototypeSlice(active_hooks.array);\n  // Don't want to make the assumption that kInit to kDestroy are indexes 0 to\n  // 4. So do this the long way.\n  active_hooks.tmp_fields = [];\n  copyHooks(active_hooks.tmp_fields, async_hook_fields);\n}\n\nfunction copyHooks(destination, source) {\n  destination[kInit] = source[kInit];\n  destination[kBefore] = source[kBefore];\n  destination[kAfter] = source[kAfter];\n  destination[kDestroy] = source[kDestroy];\n  destination[kPromiseResolve] = source[kPromiseResolve];\n}\n\n\n// Then restore the correct hooks array in case any hooks were added/removed\n// during hook callback execution.\nfunction restoreActiveHooks() {\n  active_hooks.array = active_hooks.tmp_array;\n  copyHooks(async_hook_fields, active_hooks.tmp_fields);\n\n  active_hooks.tmp_array = null;\n  active_hooks.tmp_fields = null;\n}\n\nfunction trackPromise(promise, parent, silent) {\n  const asyncId = getOrSetAsyncId(promise);\n\n  promise[trigger_async_id_symbol] = parent ? getOrSetAsyncId(parent) :\n    getDefaultTriggerAsyncId();\n\n  if (!silent && initHooksExist()) {\n    const triggerId = promise[trigger_async_id_symbol];\n    emitInitScript(asyncId, 'PROMISE', triggerId, promise);\n  }\n}\n\nfunction fastPromiseHook(type, promise, parent) {\n  if (type === kInit || !promise[async_id_symbol]) {\n    const silent = type !== kInit;\n    if (parent instanceof Promise) {\n      trackPromise(promise, parent, silent);\n    } else {\n      trackPromise(promise, null, silent);\n    }\n\n    if (!silent) return;\n  }\n\n  const asyncId = promise[async_id_symbol];\n  switch (type) {\n    case kBefore:\n      const triggerId = promise[trigger_async_id_symbol];\n      emitBeforeScript(asyncId, triggerId, promise);\n      break;\n    case kAfter:\n      if (hasHooks(kAfter)) {\n        emitAfterNative(asyncId);\n      }\n      if (asyncId === executionAsyncId()) {\n        // This condition might not be true if async_hooks was enabled during\n        // the promise callback execution.\n        // Popping it off the stack can be skipped in that case, because it is\n        // known that it would correspond to exactly one call with\n        // PromiseHookType::kBefore that was not witnessed by the PromiseHook.\n        popAsyncContext(asyncId);\n      }\n      break;\n    case kPromiseResolve:\n      emitPromiseResolveNative(asyncId);\n      break;\n  }\n}\n\nlet wantPromiseHook = false;\nfunction enableHooks() {\n  async_hook_fields[kCheck] += 1;\n}\n\nlet promiseHookMode = -1;\nfunction updatePromiseHookMode() {\n  wantPromiseHook = true;\n  if (destroyHooksExist()) {\n    if (promiseHookMode !== 1) {\n      promiseHookMode = 1;\n      enablePromiseHook();\n    }\n  } else if (promiseHookMode !== 0) {\n    promiseHookMode = 0;\n    enablePromiseHook(fastPromiseHook);\n  }\n}\n\nfunction disableHooks() {\n  async_hook_fields[kCheck] -= 1;\n\n  wantPromiseHook = false;\n\n  // Delay the call to `disablePromiseHook()` because we might currently be\n  // between the `before` and `after` calls of a Promise.\n  enqueueMicrotask(disablePromiseHookIfNecessary);\n}\n\nfunction disablePromiseHookIfNecessary() {\n  if (!wantPromiseHook) {\n    promiseHookMode = -1;\n    disablePromiseHook();\n  }\n}\n\n// Internal Embedder API //\n\n// Increment the internal id counter and return the value. Important that the\n// counter increment first. Since it's done the same way in\n// Environment::new_async_uid()\nfunction newAsyncId() {\n  return ++async_id_fields[kAsyncIdCounter];\n}\n\nfunction getOrSetAsyncId(object) {\n  if (ObjectPrototypeHasOwnProperty(object, async_id_symbol)) {\n    return object[async_id_symbol];\n  }\n\n  return object[async_id_symbol] = newAsyncId();\n}\n\n\n// Return the triggerAsyncId meant for the constructor calling it. It's up to\n// the user to safeguard this call and make sure it's zero'd out when the\n// constructor is complete.\nfunction getDefaultTriggerAsyncId() {\n  const defaultTriggerAsyncId = async_id_fields[kDefaultTriggerAsyncId];\n  // If defaultTriggerAsyncId isn't set, use the executionAsyncId\n  if (defaultTriggerAsyncId < 0)\n    return async_id_fields[kExecutionAsyncId];\n  return defaultTriggerAsyncId;\n}\n\n\nfunction clearDefaultTriggerAsyncId() {\n  async_id_fields[kDefaultTriggerAsyncId] = -1;\n}\n\n\nfunction defaultTriggerAsyncIdScope(triggerAsyncId, block, ...args) {\n  if (triggerAsyncId === undefined)\n    return block(...args);\n  // CHECK(NumberIsSafeInteger(triggerAsyncId))\n  // CHECK(triggerAsyncId > 0)\n  const oldDefaultTriggerAsyncId = async_id_fields[kDefaultTriggerAsyncId];\n  async_id_fields[kDefaultTriggerAsyncId] = triggerAsyncId;\n\n  try {\n    return block(...args);\n  } finally {\n    async_id_fields[kDefaultTriggerAsyncId] = oldDefaultTriggerAsyncId;\n  }\n}\n\nfunction hasHooks(key) {\n  return async_hook_fields[key] > 0;\n}\n\nfunction enabledHooksExist() {\n  return hasHooks(kCheck);\n}\n\nfunction initHooksExist() {\n  return hasHooks(kInit);\n}\n\nfunction afterHooksExist() {\n  return hasHooks(kAfter);\n}\n\nfunction destroyHooksExist() {\n  return hasHooks(kDestroy);\n}\n\n\nfunction emitInitScript(asyncId, type, triggerAsyncId, resource) {\n  // Short circuit all checks for the common case. Which is that no hooks have\n  // been set. Do this to remove performance impact for embedders (and core).\n  if (!hasHooks(kInit))\n    return;\n\n  if (triggerAsyncId === null) {\n    triggerAsyncId = getDefaultTriggerAsyncId();\n  }\n\n  emitInitNative(asyncId, type, triggerAsyncId, resource);\n}\n\n\nfunction emitBeforeScript(asyncId, triggerAsyncId, resource) {\n  pushAsyncContext(asyncId, triggerAsyncId, resource);\n\n  if (hasHooks(kBefore))\n    emitBeforeNative(asyncId);\n}\n\n\nfunction emitAfterScript(asyncId) {\n  if (hasHooks(kAfter))\n    emitAfterNative(asyncId);\n\n  popAsyncContext(asyncId);\n}\n\n\nfunction emitDestroyScript(asyncId) {\n  // Return early if there are no destroy callbacks, or invalid asyncId.\n  if (!hasHooks(kDestroy) || asyncId <= 0)\n    return;\n  async_wrap.queueDestroyAsyncId(asyncId);\n}\n\n\nfunction hasAsyncIdStack() {\n  return hasHooks(kStackLength);\n}\n\n\n// This is the equivalent of the native push_async_ids() call.\nfunction pushAsyncContext(asyncId, triggerAsyncId, resource) {\n  const offset = async_hook_fields[kStackLength];\n  execution_async_resources[offset] = resource;\n  if (offset * 2 >= async_wrap.async_ids_stack.length)\n    return pushAsyncContext_(asyncId, triggerAsyncId);\n  async_wrap.async_ids_stack[offset * 2] = async_id_fields[kExecutionAsyncId];\n  async_wrap.async_ids_stack[offset * 2 + 1] = async_id_fields[kTriggerAsyncId];\n  async_hook_fields[kStackLength]++;\n  async_id_fields[kExecutionAsyncId] = asyncId;\n  async_id_fields[kTriggerAsyncId] = triggerAsyncId;\n}\n\n\n// This is the equivalent of the native pop_async_ids() call.\nfunction popAsyncContext(asyncId) {\n  const stackLength = async_hook_fields[kStackLength];\n  if (stackLength === 0) return false;\n\n  if (enabledHooksExist() && async_id_fields[kExecutionAsyncId] !== asyncId) {\n    // Do the same thing as the native code (i.e. crash hard).\n    return popAsyncContext_(asyncId);\n  }\n\n  const offset = stackLength - 1;\n  async_id_fields[kExecutionAsyncId] = async_wrap.async_ids_stack[2 * offset];\n  async_id_fields[kTriggerAsyncId] = async_wrap.async_ids_stack[2 * offset + 1];\n  ArrayPrototypePop(execution_async_resources);\n  async_hook_fields[kStackLength] = offset;\n  return offset > 0;\n}\n\n\nfunction executionAsyncId() {\n  return async_id_fields[kExecutionAsyncId];\n}\n\nfunction triggerAsyncId() {\n  return async_id_fields[kTriggerAsyncId];\n}\n\n\nmodule.exports = {\n  executionAsyncId,\n  triggerAsyncId,\n  // Private API\n  getHookArrays,\n  symbols: {\n    async_id_symbol, trigger_async_id_symbol,\n    init_symbol, before_symbol, after_symbol, destroy_symbol,\n    promise_resolve_symbol, owner_symbol\n  },\n  constants: {\n    kInit, kBefore, kAfter, kDestroy, kTotals, kPromiseResolve\n  },\n  enableHooks,\n  disableHooks,\n  updatePromiseHookMode,\n  clearDefaultTriggerAsyncId,\n  clearAsyncIdStack,\n  hasAsyncIdStack,\n  executionAsyncResource,\n  // Internal Embedder API\n  newAsyncId,\n  getOrSetAsyncId,\n  getDefaultTriggerAsyncId,\n  defaultTriggerAsyncIdScope,\n  enabledHooksExist,\n  initHooksExist,\n  afterHooksExist,\n  destroyHooksExist,\n  emitInit: emitInitScript,\n  emitBefore: emitBeforeScript,\n  emitAfter: emitAfterScript,\n  emitDestroy: emitDestroyScript,\n  registerDestroyHook,\n  useDomainTrampoline,\n  nativeHooks: {\n    init: emitInitNative,\n    before: emitBeforeNative,\n    after: emitAfterNative,\n    destroy: emitDestroyNative,\n    promise_resolve: emitPromiseResolveNative\n  }\n};\n"
  },
  {
    "url": "internal/bootstrap/loaders.js",
    "ranges": [
      {
        "start": 0,
        "end": 3655
      },
      {
        "start": 4052,
        "end": 4877
      },
      {
        "start": 5031,
        "end": 6403
      },
      {
        "start": 6629,
        "end": 6640
      },
      {
        "start": 6693,
        "end": 10055
      },
      {
        "start": 10227,
        "end": 10314
      }
    ],
    "text": "// This file creates the internal module & binding loaders used by built-in\n// modules. In contrast, user land modules are loaded using\n// lib/internal/modules/cjs/loader.js (CommonJS Modules) or\n// lib/internal/modules/esm/* (ES Modules).\n//\n// This file is compiled and run by node.cc before bootstrap/node.js\n// was called, therefore the loaders are bootstraped before we start to\n// actually bootstrap Node.js. It creates the following objects:\n//\n// C++ binding loaders:\n// - process.binding(): the legacy C++ binding loader, accessible from user land\n//   because it is an object attached to the global process object.\n//   These C++ bindings are created using NODE_BUILTIN_MODULE_CONTEXT_AWARE()\n//   and have their nm_flags set to NM_F_BUILTIN. We do not make any guarantees\n//   about the stability of these bindings, but still have to take care of\n//   compatibility issues caused by them from time to time.\n// - process._linkedBinding(): intended to be used by embedders to add\n//   additional C++ bindings in their applications. These C++ bindings\n//   can be created using NODE_MODULE_CONTEXT_AWARE_CPP() with the flag\n//   NM_F_LINKED.\n// - internalBinding(): the private internal C++ binding loader, inaccessible\n//   from user land unless through `require('internal/test/binding')`.\n//   These C++ bindings are created using NODE_MODULE_CONTEXT_AWARE_INTERNAL()\n//   and have their nm_flags set to NM_F_INTERNAL.\n//\n// Internal JavaScript module loader:\n// - NativeModule: a minimal module system used to load the JavaScript core\n//   modules found in lib/**/*.js and deps/**/*.js. All core modules are\n//   compiled into the node binary via node_javascript.cc generated by js2c.py,\n//   so they can be loaded faster without the cost of I/O. This class makes the\n//   lib/internal/*, deps/internal/* modules and internalBinding() available by\n//   default to core modules, and lets the core modules require itself via\n//   require('internal/bootstrap/loaders') even when this file is not written in\n//   CommonJS style.\n//\n// Other objects:\n// - process.moduleLoadList: an array recording the bindings and the modules\n//   loaded in the process and the order in which they are loaded.\n\n'use strict';\n\n// This file is compiled as if it's wrapped in a function with arguments\n// passed by node::RunBootstrapping()\n/* global process, getLinkedBinding, getInternalBinding, primordials */\n\nconst {\n  ArrayPrototypeMap,\n  ArrayPrototypePush,\n  Error,\n  ObjectCreate,\n  ObjectDefineProperty,\n  ObjectKeys,\n  ObjectPrototypeHasOwnProperty,\n  ReflectGet,\n  SafeMap,\n  SafeSet,\n  String,\n  StringPrototypeStartsWith,\n  TypeError,\n} = primordials;\n\n// Set up process.moduleLoadList.\nconst moduleLoadList = [];\nObjectDefineProperty(process, 'moduleLoadList', {\n  value: moduleLoadList,\n  configurable: true,\n  enumerable: true,\n  writable: false\n});\n\n\n// internalBindingWhitelist contains the name of internalBinding modules\n// that are whitelisted for access via process.binding()... This is used\n// to provide a transition path for modules that are being moved over to\n// internalBinding.\nconst internalBindingWhitelist = new SafeSet([\n  'async_wrap',\n  'buffer',\n  'cares_wrap',\n  'config',\n  'constants',\n  'contextify',\n  'crypto',\n  'fs',\n  'fs_event_wrap',\n  'http_parser',\n  'icu',\n  'inspector',\n  'js_stream',\n  'natives',\n  'os',\n  'pipe_wrap',\n  'process_wrap',\n  'signal_wrap',\n  'spawn_sync',\n  'stream_wrap',\n  'tcp_wrap',\n  'tls_wrap',\n  'tty_wrap',\n  'udp_wrap',\n  'url',\n  'util',\n  'uv',\n  'v8',\n  'zlib'\n]);\n\n// Set up process.binding() and process._linkedBinding().\n{\n  const bindingObj = ObjectCreate(null);\n\n  process.binding = function binding(module) {\n    module = String(module);\n    // Deprecated specific process.binding() modules, but not all, allow\n    // selective fallback to internalBinding for the deprecated ones.\n    if (internalBindingWhitelist.has(module)) {\n      return internalBinding(module);\n    }\n    // eslint-disable-next-line no-restricted-syntax\n    throw new Error(`No such module: ${module}`);\n  };\n\n  process._linkedBinding = function _linkedBinding(module) {\n    module = String(module);\n    let mod = bindingObj[module];\n    if (typeof mod !== 'object')\n      mod = bindingObj[module] = getLinkedBinding(module);\n    return mod;\n  };\n}\n\n// Set up internalBinding() in the closure.\nlet internalBinding;\n{\n  const bindingObj = ObjectCreate(null);\n  // eslint-disable-next-line no-global-assign\n  internalBinding = function internalBinding(module) {\n    let mod = bindingObj[module];\n    if (typeof mod !== 'object') {\n      mod = bindingObj[module] = getInternalBinding(module);\n      ArrayPrototypePush(moduleLoadList, `Internal Binding ${module}`);\n    }\n    return mod;\n  };\n}\n\nconst loaderId = 'internal/bootstrap/loaders';\nconst {\n  moduleIds,\n  compileFunction\n} = internalBinding('native_module');\n\nconst getOwn = (target, property, receiver) => {\n  return ObjectPrototypeHasOwnProperty(target, property) ?\n    ReflectGet(target, property, receiver) :\n    undefined;\n};\n\n/**\n * An internal abstraction for the built-in JavaScript modules of Node.js.\n * Be careful not to expose this to user land unless --expose-internals is\n * used, in which case there is no compatibility guarantee about this class.\n */\nclass NativeModule {\n  /**\n   * A map from the module IDs to the module instances.\n   * @type {Map<string, NativeModule>}\n  */\n  static map = new SafeMap(\n    ArrayPrototypeMap(moduleIds, (id) => [id, new NativeModule(id)])\n  );\n\n  constructor(id) {\n    this.filename = `${id}.js`;\n    this.id = id;\n    this.canBeRequiredByUsers = !StringPrototypeStartsWith(id, 'internal/');\n\n    // The CJS exports object of the module.\n    this.exports = {};\n    // States used to work around circular dependencies.\n    this.loaded = false;\n    this.loading = false;\n\n    // The following properties are used by the ESM implementation and only\n    // initialized when the native module is loaded by users.\n    /**\n     * The C++ ModuleWrap binding used to interface with the ESM implementation.\n     * @type {ModuleWrap|undefined}\n     */\n    this.module = undefined;\n    /**\n     * Exported names for the ESM imports.\n     * @type {string[]|undefined}\n     */\n    this.exportKeys = undefined;\n  }\n\n  // To be called during pre-execution when --expose-internals is on.\n  // Enables the user-land module loader to access internal modules.\n  static exposeInternals() {\n    for (const [id, mod] of NativeModule.map) {\n      // Do not expose this to user land even with --expose-internals.\n      if (id !== loaderId) {\n        mod.canBeRequiredByUsers = true;\n      }\n    }\n  }\n\n  static exists(id) {\n    return NativeModule.map.has(id);\n  }\n\n  static canBeRequiredByUsers(id) {\n    const mod = NativeModule.map.get(id);\n    return mod && mod.canBeRequiredByUsers;\n  }\n\n  // Used by user-land module loaders to compile and load builtins.\n  compileForPublicLoader() {\n    if (!this.canBeRequiredByUsers) {\n      // No code because this is an assertion against bugs\n      // eslint-disable-next-line no-restricted-syntax\n      throw new Error(`Should not compile ${this.id} for public use`);\n    }\n    this.compileForInternalLoader();\n    if (!this.exportKeys) {\n      // When using --expose-internals, we do not want to reflect the named\n      // exports from core modules as this can trigger unnecessary getters.\n      const internal = StringPrototypeStartsWith(this.id, 'internal/');\n      this.exportKeys = internal ? [] : ObjectKeys(this.exports);\n    }\n    this.getESMFacade();\n    this.syncExports();\n    return this.exports;\n  }\n\n  getESMFacade() {\n    if (this.module) return this.module;\n    const { ModuleWrap } = internalBinding('module_wrap');\n    const url = `node:${this.id}`;\n    const nativeModule = this;\n    this.module = new ModuleWrap(\n      url, undefined, [...this.exportKeys, 'default'],\n      function() {\n        nativeModule.syncExports();\n        this.setExport('default', nativeModule.exports);\n      });\n    // Ensure immediate sync execution to capture exports now\n    this.module.instantiate();\n    this.module.evaluate(-1, false);\n    return this.module;\n  }\n\n  // Provide named exports for all builtin libraries so that the libraries\n  // may be imported in a nicer way for ESM users. The default export is left\n  // as the entire namespace (module.exports) and updates when this function is\n  // called so that APMs and other behavior are supported.\n  syncExports() {\n    const names = this.exportKeys;\n    if (this.module) {\n      for (let i = 0; i < names.length; i++) {\n        const exportName = names[i];\n        if (exportName === 'default') continue;\n        this.module.setExport(exportName,\n                              getOwn(this.exports, exportName, this.exports));\n      }\n    }\n  }\n\n  compileForInternalLoader() {\n    if (this.loaded || this.loading) {\n      return this.exports;\n    }\n\n    const id = this.id;\n    this.loading = true;\n\n    try {\n      const requireFn = StringPrototypeStartsWith(this.id, 'internal/deps/') ?\n        requireWithFallbackInDeps : nativeModuleRequire;\n\n      const fn = compileFunction(id);\n      fn(this.exports, requireFn, this, process, internalBinding, primordials);\n\n      this.loaded = true;\n    } finally {\n      this.loading = false;\n    }\n\n    ArrayPrototypePush(moduleLoadList, `NativeModule ${id}`);\n    return this.exports;\n  }\n}\n\n// Think of this as module.exports in this file even though it is not\n// written in CommonJS style.\nconst loaderExports = {\n  internalBinding,\n  NativeModule,\n  require: nativeModuleRequire\n};\n\nfunction nativeModuleRequire(id) {\n  if (id === loaderId) {\n    return loaderExports;\n  }\n\n  const mod = NativeModule.map.get(id);\n  // Can't load the internal errors module from here, have to use a raw error.\n  // eslint-disable-next-line no-restricted-syntax\n  if (!mod) throw new TypeError(`Missing internal module '${id}'`);\n  return mod.compileForInternalLoader();\n}\n\n// Allow internal modules from dependencies to require\n// other modules from dependencies by providing fallbacks.\nfunction requireWithFallbackInDeps(request) {\n  if (!NativeModule.map.has(request)) {\n    request = `internal/deps/${request}`;\n  }\n  return nativeModuleRequire(request);\n}\n\n// Pass the exports back to C++ land for C++ internals to use.\nreturn loaderExports;\n"
  },
  {
    "url": "internal/bootstrap/node.js",
    "ranges": [
      {
        "start": 0,
        "end": 3561
      },
      {
        "start": 3631,
        "end": 6323
      },
      {
        "start": 6485,
        "end": 6587
      },
      {
        "start": 6759,
        "end": 11358
      },
      {
        "start": 12039,
        "end": 12091
      },
      {
        "start": 12289,
        "end": 12341
      },
      {
        "start": 12539,
        "end": 12599
      },
      {
        "start": 12778,
        "end": 12779
      }
    ],
    "text": "// Hello, and welcome to hacking node.js!\n//\n// This file is invoked by `node::RunBootstrapping()` in `src/node.cc`, and is\n// responsible for setting up node.js core before executing main scripts\n// under `lib/internal/main/`.\n//\n// This file is expected not to perform any asynchronous operations itself\n// when being executed - those should be done in either\n// `lib/internal/bootstrap/pre_execution.js` or in main scripts. The majority\n// of the code here focuses on setting up the global proxy and the process\n// object in a synchronous manner.\n// As special caution is given to the performance of the startup process,\n// many dependencies are invoked lazily.\n//\n// Scripts run before this file:\n// - `lib/internal/per_context/primordials.js`: to save copies of JavaScript\n//   builtins that won't be affected by user land monkey-patching for internal\n//   modules to use.\n// - `lib/internal/bootstrap/loaders.js`: to setup internal binding and\n//   module loaders, including `process.binding()`, `process._linkedBinding()`,\n//   `internalBinding()` and `NativeModule`.\n//\n// This file is run to bootstrap both the main thread and the worker threads.\n// After this file is run, certain properties are setup according to the\n// configuration of the Node.js instance using the files in\n// `lib/internal/bootstrap/switches/`.\n//\n// Then, depending on how the Node.js instance is launched, one of the main\n// scripts in `lib/internal/main` will be selected by C++ to start the actual\n// execution. They may run additional setups exported by\n// `lib/internal/bootstrap/pre_execution.js` depending on the runtime states.\n\n'use strict';\n\n// This file is compiled as if it's wrapped in a function with arguments\n// passed by node::RunBootstrapping()\n/* global process, require, internalBinding, primordials */\n\nsetupPrepareStackTrace();\n\nconst {\n  FunctionPrototypeCall,\n  JSONParse,\n  ObjectDefineProperty,\n  ObjectGetPrototypeOf,\n  ObjectSetPrototypeOf,\n  SymbolToStringTag,\n} = primordials;\nconst config = internalBinding('config');\nconst { deprecate } = require('internal/util');\n\nsetupProcessObject();\n\nsetupGlobalProxy();\nsetupBuffer();\n\nprocess.domain = null;\nprocess._exiting = false;\n\n// NOTE: Electron deletes this references before user code runs so that\n// internalBinding is not leaked to user code\nprocess.internalBinding = internalBinding;\n\n// process.config is serialized config.gypi\nprocess.config = JSONParse(internalBinding('native_module').config);\nrequire('internal/worker/js_transferable').setup();\n\n// Bootstrappers for all threads, including worker threads and main thread\nconst perThreadSetup = require('internal/process/per_thread');\nconst rawMethods = internalBinding('process_methods');\n\n// Set up methods on the process object for all threads\n{\n  process.dlopen = rawMethods.dlopen;\n  process.uptime = rawMethods.uptime;\n\n  // TODO(joyeecheung): either remove them or make them public\n  process._getActiveRequests = rawMethods._getActiveRequests;\n  process._getActiveHandles = rawMethods._getActiveHandles;\n\n  // TODO(joyeecheung): remove these\n  process.reallyExit = rawMethods.reallyExit;\n  process._kill = rawMethods._kill;\n\n  const wrapped = perThreadSetup.wrapProcessMethods(rawMethods);\n  process._rawDebug = wrapped._rawDebug;\n  process.hrtime = wrapped.hrtime;\n  process.hrtime.bigint = wrapped.hrtimeBigInt;\n  process.cpuUsage = wrapped.cpuUsage;\n  process.resourceUsage = wrapped.resourceUsage;\n  process.memoryUsage = wrapped.memoryUsage;\n  process.kill = wrapped.kill;\n  process.exit = wrapped.exit;\n\n  process.openStdin = function() {\n    process.stdin.resume();\n    return process.stdin;\n  };\n}\n\nconst credentials = internalBinding('credentials');\nif (credentials.implementsPosixCredentials) {\n  process.getuid = credentials.getuid;\n  process.geteuid = credentials.geteuid;\n  process.getgid = credentials.getgid;\n  process.getegid = credentials.getegid;\n  process.getgroups = credentials.getgroups;\n}\n\n// Setup the callbacks that node::AsyncWrap will call when there are hooks to\n// process. They use the same functions as the JS embedder API. These callbacks\n// are setup immediately to prevent async_wrap.setupHooks() from being hijacked\n// and the cost of doing so is negligible.\nconst { nativeHooks } = require('internal/async_hooks');\ninternalBinding('async_wrap').setupHooks(nativeHooks);\n\nconst {\n  setupTaskQueue,\n  queueMicrotask\n} = require('internal/process/task_queues');\n\nif (!global._noBrowserGlobals) {\n  // Override global console from the one provided by the VM\n  // to the one implemented by Node.js\n  // https://console.spec.whatwg.org/#console-namespace\n  exposeNamespace(global, 'console', createGlobalConsole(global.console));\n\n  const { URL, URLSearchParams } = require('internal/url');\n  // https://url.spec.whatwg.org/#url\n  exposeInterface(global, 'URL', URL);\n  // https://url.spec.whatwg.org/#urlsearchparams\n  exposeInterface(global, 'URLSearchParams', URLSearchParams);\n\n  const {\n    TextEncoder, TextDecoder\n  } = require('internal/encoding');\n  // https://encoding.spec.whatwg.org/#textencoder\n  exposeInterface(global, 'TextEncoder', TextEncoder);\n  // https://encoding.spec.whatwg.org/#textdecoder\n  exposeInterface(global, 'TextDecoder', TextDecoder);\n\n  // https://html.spec.whatwg.org/multipage/webappapis.html#windoworworkerglobalscope\n  const timers = require('timers');\n  defineOperation(global, 'clearInterval', timers.clearInterval);\n  defineOperation(global, 'clearTimeout', timers.clearTimeout);\n  defineOperation(global, 'setInterval', timers.setInterval);\n  defineOperation(global, 'setTimeout', timers.setTimeout);\n\n  defineOperation(global, 'queueMicrotask', queueMicrotask);\n\n  // Non-standard extensions:\n  defineOperation(global, 'clearImmediate', timers.clearImmediate);\n  defineOperation(global, 'setImmediate', timers.setImmediate);\n}\n\n// Set the per-Environment callback that will be called\n// when the TrackingTraceStateObserver updates trace state.\n// Note that when NODE_USE_V8_PLATFORM is true, the observer is\n// attached to the per-process TracingController.\nconst { setTraceCategoryStateUpdateHandler } = internalBinding('trace_events');\nsetTraceCategoryStateUpdateHandler(perThreadSetup.toggleTraceCategoryState);\n\n// process.allowedNodeEnvironmentFlags\nObjectDefineProperty(process, 'allowedNodeEnvironmentFlags', {\n  get() {\n    const flags = perThreadSetup.buildAllowedFlags();\n    process.allowedNodeEnvironmentFlags = flags;\n    return process.allowedNodeEnvironmentFlags;\n  },\n  // If the user tries to set this to another value, override\n  // this completely to that value.\n  set(value) {\n    ObjectDefineProperty(this, 'allowedNodeEnvironmentFlags', {\n      value,\n      configurable: true,\n      enumerable: true,\n      writable: true\n    });\n  },\n  enumerable: true,\n  configurable: true\n});\n\n// process.assert\nprocess.assert = deprecate(\n  perThreadSetup.assert,\n  'process.assert() is deprecated. Please use the `assert` module instead.',\n  'DEP0100');\n\n// TODO(joyeecheung): this property has not been well-maintained, should we\n// deprecate it in favor of a better API?\nconst { isDebugBuild, hasOpenSSL, hasInspector } = config;\nObjectDefineProperty(process, 'features', {\n  enumerable: true,\n  writable: false,\n  configurable: false,\n  value: {\n    inspector: hasInspector,\n    debug: isDebugBuild,\n    uv: true,\n    ipv6: true,  // TODO(bnoordhuis) ping libuv\n    tls_alpn: hasOpenSSL,\n    tls_sni: hasOpenSSL,\n    tls_ocsp: hasOpenSSL,\n    tls: hasOpenSSL,\n    cached_builtins: config.hasCachedBuiltins,\n  }\n});\n\n{\n  const {\n    onGlobalUncaughtException,\n    setUncaughtExceptionCaptureCallback,\n    hasUncaughtExceptionCaptureCallback\n  } = require('internal/process/execution');\n\n  // For legacy reasons this is still called `_fatalException`, even\n  // though it is now a global uncaught exception handler.\n  // The C++ land node::errors::TriggerUncaughtException grabs it\n  // from the process object because it has been monkey-patchable.\n  // TODO(joyeecheung): investigate whether process._fatalException\n  // can be deprecated.\n  process._fatalException = onGlobalUncaughtException;\n  process.setUncaughtExceptionCaptureCallback =\n    setUncaughtExceptionCaptureCallback;\n  process.hasUncaughtExceptionCaptureCallback =\n    hasUncaughtExceptionCaptureCallback;\n}\n\nconst { emitWarning } = require('internal/process/warning');\nprocess.emitWarning = emitWarning;\n\n// We initialize the tick callbacks and the timer callbacks last during\n// bootstrap to make sure that any operation done before this are synchronous.\n// If any ticks or timers are scheduled before this they are unlikely to work.\n{\n  const { nextTick, runNextTicks } = setupTaskQueue();\n  process.nextTick = nextTick;\n  // Used to emulate a tick manually in the JS land.\n  // A better name for this function would be `runNextTicks` but\n  // it has been exposed to the process object so we keep this legacy name\n  // TODO(joyeecheung): either remove it or make it public\n  process._tickCallback = runNextTicks;\n\n  const { getTimerCallbacks } = require('internal/timers');\n  const { setupTimers } = internalBinding('timers');\n  const { processImmediate, processTimers } = getTimerCallbacks(runNextTicks);\n  // Sets two per-Environment callbacks that will be run from libuv:\n  // - processImmediate will be run in the callback of the per-Environment\n  //   check handle.\n  // - processTimers will be run in the callback of the per-Environment timer.\n  setupTimers(processImmediate, processTimers);\n  // Note: only after this point are the timers effective\n}\n\nfunction setupPrepareStackTrace() {\n  const {\n    setEnhanceStackForFatalException,\n    setPrepareStackTraceCallback\n  } = internalBinding('errors');\n  const {\n    prepareStackTrace,\n    fatalExceptionStackEnhancers: {\n      beforeInspector,\n      afterInspector\n    }\n  } = require('internal/errors');\n  // Tell our PrepareStackTraceCallback passed to the V8 API\n  // to call prepareStackTrace().\n  setPrepareStackTraceCallback(prepareStackTrace);\n  // Set the function used to enhance the error stack for printing\n  setEnhanceStackForFatalException(beforeInspector, afterInspector);\n}\n\nfunction setupProcessObject() {\n  const EventEmitter = require('events');\n  const origProcProto = ObjectGetPrototypeOf(process);\n  ObjectSetPrototypeOf(origProcProto, EventEmitter.prototype);\n  FunctionPrototypeCall(EventEmitter, process);\n  ObjectDefineProperty(process, SymbolToStringTag, {\n    enumerable: false,\n    writable: true,\n    configurable: false,\n    value: 'process'\n  });\n  // Make process globally available to users by putting it on the global proxy\n  ObjectDefineProperty(global, 'process', {\n    value: process,\n    enumerable: false,\n    writable: true,\n    configurable: true\n  });\n}\n\nfunction setupGlobalProxy() {\n  ObjectDefineProperty(global, SymbolToStringTag, {\n    value: 'global',\n    writable: false,\n    enumerable: false,\n    configurable: true\n  });\n}\n\nfunction setupBuffer() {\n  const { Buffer } = require('buffer');\n  const bufferBinding = internalBinding('buffer');\n\n  // Only after this point can C++ use Buffer::New()\n  bufferBinding.setBufferPrototype(Buffer.prototype);\n  delete bufferBinding.setBufferPrototype;\n  delete bufferBinding.zeroFill;\n\n  ObjectDefineProperty(global, 'Buffer', {\n    value: Buffer,\n    enumerable: false,\n    writable: true,\n    configurable: true\n  });\n}\n\nfunction createGlobalConsole(consoleFromVM) {\n  const consoleFromNode =\n    require('internal/console/global');\n  if (config.hasInspector) {\n    const inspector = require('internal/util/inspector');\n    // This will be exposed by `require('inspector').console` later.\n    inspector.consoleFromVM = consoleFromVM;\n    // TODO(joyeecheung): postpone this until the first time inspector\n    // is activated.\n    inspector.wrapConsole(consoleFromNode, consoleFromVM);\n    const { setConsoleExtensionInstaller } = internalBinding('inspector');\n    // Setup inspector command line API.\n    setConsoleExtensionInstaller(inspector.installConsoleExtensions);\n  }\n  return consoleFromNode;\n}\n\n// https://heycam.github.io/webidl/#es-namespaces\nfunction exposeNamespace(target, name, namespaceObject) {\n  ObjectDefineProperty(target, name, {\n    writable: true,\n    enumerable: false,\n    configurable: true,\n    value: namespaceObject\n  });\n}\n\n// https://heycam.github.io/webidl/#es-interfaces\nfunction exposeInterface(target, name, interfaceObject) {\n  ObjectDefineProperty(target, name, {\n    writable: true,\n    enumerable: false,\n    configurable: true,\n    value: interfaceObject\n  });\n}\n\n// https://heycam.github.io/webidl/#define-the-operations\nfunction defineOperation(target, name, method) {\n  ObjectDefineProperty(target, name, {\n    writable: true,\n    enumerable: true,\n    configurable: true,\n    value: method\n  });\n}\n"
  },
  {
    "url": "internal/bootstrap/pre_execution.js",
    "ranges": [
      {
        "start": 0,
        "end": 4804
      },
      {
        "start": 5481,
        "end": 5892
      },
      {
        "start": 5926,
        "end": 6634
      },
      {
        "start": 6670,
        "end": 9929
      },
      {
        "start": 9971,
        "end": 10138
      },
      {
        "start": 10179,
        "end": 15153
      }
    ],
    "text": "'use strict';\n\nconst {\n  NumberParseInt,\n  ObjectDefineProperty,\n  SafeMap,\n  SafeWeakMap,\n  StringPrototypeStartsWith,\n} = primordials;\n\nconst {\n  getOptionValue,\n  shouldNotRegisterESMLoader\n} = require('internal/options');\nconst { Buffer } = require('buffer');\nconst { ERR_MANIFEST_ASSERT_INTEGRITY } = require('internal/errors').codes;\nconst assert = require('internal/assert');\n\nfunction prepareMainThreadExecution(expandArgv1 = false) {\n  // Patch the process object with legacy properties and normalizations\n  patchProcessObject(expandArgv1);\n  setupTraceCategoryState();\n  setupInspectorHooks();\n  setupWarningHandler();\n\n  // Resolve the coverage directory to an absolute path, and\n  // overwrite process.env so that the original path gets passed\n  // to child processes even when they switch cwd.\n  if (process.env.NODE_V8_COVERAGE) {\n    process.env.NODE_V8_COVERAGE =\n      setupCoverageHooks(process.env.NODE_V8_COVERAGE);\n  }\n\n  // If source-map support has been enabled, we substitute in a new\n  // prepareStackTrace method, replacing the default in errors.js.\n  if (getOptionValue('--enable-source-maps')) {\n    const { prepareStackTrace } =\n      require('internal/source_map/prepare_stack_trace');\n    const { setPrepareStackTraceCallback } = internalBinding('errors');\n    setPrepareStackTraceCallback(prepareStackTrace);\n  }\n\n  setupDebugEnv();\n\n  // Print stack trace on `SIGINT` if option `--trace-sigint` presents.\n  setupStacktracePrinterOnSigint();\n\n  // Process initial diagnostic reporting configuration, if present.\n  initializeReport();\n  initializeReportSignalHandlers();  // Main-thread-only.\n\n  initializeHeapSnapshotSignalHandlers();\n\n  // If the process is spawned with env NODE_CHANNEL_FD, it's probably\n  // spawned by our child_process module, then initialize IPC.\n  // This attaches some internal event listeners and creates:\n  // process.send(), process.channel, process.connected,\n  // process.disconnect().\n  setupChildProcessIpcChannel();\n\n  // Load policy from disk and parse it.\n  initializePolicy();\n\n  // If this is a worker in cluster mode, start up the communication\n  // channel. This needs to be done before any user code gets executed\n  // (including preload modules).\n  initializeClusterIPC();\n\n  initializeDeprecations();\n  initializeWASI();\n  initializeCJSLoader();\n  initializeESMLoader();\n\n  const CJSLoader = require('internal/modules/cjs/loader');\n  assert(!CJSLoader.hasLoadedAnyUserCJSModule);\n  loadPreloadModules();\n  initializeFrozenIntrinsics();\n  setupAsarSupport();\n}\n\nfunction patchProcessObject(expandArgv1) {\n  const {\n    patchProcessObject: patchProcessObjectNative\n  } = internalBinding('process_methods');\n\n  patchProcessObjectNative(process);\n\n  ObjectDefineProperty(process, 'argv0', {\n    enumerable: true,\n    configurable: false,\n    value: process.argv[0]\n  });\n  process.argv[0] = process.execPath;\n\n  if (expandArgv1 && process.argv[1] &&\n      !StringPrototypeStartsWith(process.argv[1], '-')) {\n    // Expand process.argv[1] into a full path.\n    if (!process.argv[1] || !process.argv[1].startsWith('electron/js2c')) {\n      const path = require('path');\n      try {\n        process.argv[1] = path.resolve(process.argv[1]);\n      } catch {}\n    }\n  }\n\n  // TODO(joyeecheung): most of these should be deprecated and removed,\n  // except some that we need to be able to mutate during run time.\n  addReadOnlyProcessAlias('_eval', '--eval');\n  addReadOnlyProcessAlias('_print_eval', '--print');\n  addReadOnlyProcessAlias('_syntax_check_only', '--check');\n  addReadOnlyProcessAlias('_forceRepl', '--interactive');\n  addReadOnlyProcessAlias('_preload_modules', '--require');\n  addReadOnlyProcessAlias('noDeprecation', '--no-deprecation');\n  addReadOnlyProcessAlias('noProcessWarnings', '--no-warnings');\n  addReadOnlyProcessAlias('traceProcessWarnings', '--trace-warnings');\n  addReadOnlyProcessAlias('throwDeprecation', '--throw-deprecation');\n  addReadOnlyProcessAlias('profProcess', '--prof-process');\n  addReadOnlyProcessAlias('traceDeprecation', '--trace-deprecation');\n  addReadOnlyProcessAlias('_breakFirstLine', '--inspect-brk', false);\n  addReadOnlyProcessAlias('_breakNodeFirstLine', '--inspect-brk-node', false);\n}\n\nfunction addReadOnlyProcessAlias(name, option, enumerable = true) {\n  const value = getOptionValue(option);\n  if (value) {\n    ObjectDefineProperty(process, name, {\n      writable: false,\n      configurable: true,\n      enumerable,\n      value\n    });\n  }\n}\n\nfunction setupWarningHandler() {\n  const {\n    onWarning\n  } = require('internal/process/warning');\n  if (!getOptionValue('--no-warnings') &&\n    process.env.NODE_NO_WARNINGS !== '1') {\n    process.on('warning', onWarning);\n  }\n}\n\n// Setup User-facing NODE_V8_COVERAGE environment variable that writes\n// ScriptCoverage to a specified file.\nfunction setupCoverageHooks(dir) {\n  const cwd = require('internal/process/execution').tryGetCwd();\n  const { resolve } = require('path');\n  const coverageDirectory = resolve(cwd, dir);\n  const { sourceMapCacheToObject } =\n    require('internal/source_map/source_map_cache');\n\n  if (process.features.inspector) {\n    internalBinding('profiler').setCoverageDirectory(coverageDirectory);\n    internalBinding('profiler').setSourceMapCacheGetter(sourceMapCacheToObject);\n  } else {\n    process.emitWarning('The inspector is disabled, ' +\n                        'coverage could not be collected',\n                        'Warning');\n    return '';\n  }\n  return coverageDirectory;\n}\n\nfunction setupStacktracePrinterOnSigint() {\n  if (!getOptionValue('--trace-sigint')) {\n    return;\n  }\n  const { SigintWatchdog } = require('internal/watchdog');\n\n  const watchdog = new SigintWatchdog();\n  watchdog.start();\n}\n\nfunction initializeReport() {\n  const { report } = require('internal/process/report');\n  ObjectDefineProperty(process, 'report', {\n    enumerable: false,\n    configurable: true,\n    get() {\n      return report;\n    }\n  });\n}\n\nfunction setupDebugEnv() {\n  require('internal/util/debuglog').initializeDebugEnv(process.env.NODE_DEBUG);\n  if (getOptionValue('--expose-internals')) {\n    require('internal/bootstrap/loaders').NativeModule.exposeInternals();\n  }\n}\n\n// This has to be called after initializeReport() is called\nfunction initializeReportSignalHandlers() {\n  const { addSignalHandler } = require('internal/process/report');\n\n  addSignalHandler();\n}\n\nfunction initializeHeapSnapshotSignalHandlers() {\n  const signal = getOptionValue('--heapsnapshot-signal');\n\n  if (!signal)\n    return;\n\n  require('internal/validators').validateSignalName(signal);\n  const { writeHeapSnapshot } = require('v8');\n\n  process.on(signal, () => {\n    writeHeapSnapshot();\n  });\n}\n\nfunction setupTraceCategoryState() {\n  const { isTraceCategoryEnabled } = internalBinding('trace_events');\n  const { toggleTraceCategoryState } = require('internal/process/per_thread');\n  toggleTraceCategoryState(isTraceCategoryEnabled('node.async_hooks'));\n}\n\nfunction setupInspectorHooks() {\n  // If Debugger.setAsyncCallStackDepth is sent during bootstrap,\n  // we cannot immediately call into JS to enable the hooks, which could\n  // interrupt the JS execution of bootstrap. So instead we save the\n  // notification in the inspector agent if it's sent in the middle of\n  // bootstrap, and process the notification later here.\n  if (internalBinding('config').hasInspector) {\n    const {\n      enable,\n      disable\n    } = require('internal/inspector_async_hook');\n    internalBinding('inspector').registerAsyncHook(enable, disable);\n  }\n}\n\n// In general deprecations are intialized wherever the APIs are implemented,\n// this is used to deprecate APIs implemented in C++ where the deprecation\n// utitlities are not easily accessible.\nfunction initializeDeprecations() {\n  const { deprecate } = require('internal/util');\n  const pendingDeprecation = getOptionValue('--pending-deprecation');\n\n  // DEP0103: access to `process.binding('util').isX` type checkers\n  // TODO(addaleax): Turn into a full runtime deprecation.\n  const utilBinding = internalBinding('util');\n  const types = require('internal/util/types');\n  for (const name of [\n    'isArrayBuffer',\n    'isArrayBufferView',\n    'isAsyncFunction',\n    'isDataView',\n    'isDate',\n    'isExternal',\n    'isMap',\n    'isMapIterator',\n    'isNativeError',\n    'isPromise',\n    'isRegExp',\n    'isSet',\n    'isSetIterator',\n    'isTypedArray',\n    'isUint8Array',\n    'isAnyArrayBuffer'\n  ]) {\n    utilBinding[name] = pendingDeprecation ?\n      deprecate(types[name],\n                'Accessing native typechecking bindings of Node ' +\n                'directly is deprecated. ' +\n                `Please use \\`util.types.${name}\\` instead.`,\n                'DEP0103') :\n      types[name];\n  }\n\n  // TODO(joyeecheung): this is a legacy property exposed to process.\n  // Now that we use the config binding to carry this information, remove\n  // it from the process. We may consider exposing it properly in\n  // process.features.\n  const { noBrowserGlobals } = internalBinding('config');\n  if (noBrowserGlobals) {\n    ObjectDefineProperty(process, '_noBrowserGlobals', {\n      writable: false,\n      enumerable: true,\n      configurable: true,\n      value: noBrowserGlobals\n    });\n  }\n\n  if (pendingDeprecation) {\n    process.binding = deprecate(process.binding,\n                                'process.binding() is deprecated. ' +\n                                'Please use public APIs instead.', 'DEP0111');\n\n    process._tickCallback = deprecate(process._tickCallback,\n                                      'process._tickCallback() is deprecated',\n                                      'DEP0134');\n  }\n\n  // Create global.process and global.Buffer as getters so that we have a\n  // deprecation path for these in ES Modules.\n  // See https://github.com/nodejs/node/pull/26334.\n  let _process = process;\n  ObjectDefineProperty(global, 'process', {\n    get() {\n      return _process;\n    },\n    set(value) {\n      _process = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  let _Buffer = Buffer;\n  ObjectDefineProperty(global, 'Buffer', {\n    get() {\n      return _Buffer;\n    },\n    set(value) {\n      _Buffer = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n}\n\nfunction setupChildProcessIpcChannel() {\n  if (process.env.NODE_CHANNEL_FD) {\n    const assert = require('internal/assert');\n\n    const fd = NumberParseInt(process.env.NODE_CHANNEL_FD, 10);\n    assert(fd >= 0);\n\n    // Make sure it's not accidentally inherited by child processes.\n    delete process.env.NODE_CHANNEL_FD;\n\n    const serializationMode =\n      process.env.NODE_CHANNEL_SERIALIZATION_MODE || 'json';\n    delete process.env.NODE_CHANNEL_SERIALIZATION_MODE;\n\n    require('child_process')._forkChild(fd, serializationMode);\n    assert(process.send);\n  }\n}\n\nfunction initializeClusterIPC() {\n  if (process.argv[1] && process.env.NODE_UNIQUE_ID) {\n    const cluster = require('cluster');\n    cluster._setupWorker();\n    // Make sure it's not accidentally inherited by child processes.\n    delete process.env.NODE_UNIQUE_ID;\n  }\n}\n\nfunction initializePolicy() {\n  const experimentalPolicy = getOptionValue('--experimental-policy');\n  if (experimentalPolicy) {\n    process.emitWarning('Policies are experimental.',\n                        'ExperimentalWarning');\n    const { pathToFileURL, URL } = require('internal/url');\n    // URL here as it is slightly different parsing\n    // no bare specifiers for now\n    let manifestURL;\n    if (require('path').isAbsolute(experimentalPolicy)) {\n      manifestURL = new URL(`file:///${experimentalPolicy}`);\n    } else {\n      const cwdURL = pathToFileURL(process.cwd());\n      cwdURL.pathname += '/';\n      manifestURL = new URL(experimentalPolicy, cwdURL);\n    }\n    const fs = require('fs');\n    const src = fs.readFileSync(manifestURL, 'utf8');\n    const experimentalPolicyIntegrity = getOptionValue('--policy-integrity');\n    if (experimentalPolicyIntegrity) {\n      const SRI = require('internal/policy/sri');\n      const { createHash, timingSafeEqual } = require('crypto');\n      const realIntegrities = new SafeMap();\n      const integrityEntries = SRI.parse(experimentalPolicyIntegrity);\n      let foundMatch = false;\n      for (let i = 0; i < integrityEntries.length; i++) {\n        const {\n          algorithm,\n          value: expected\n        } = integrityEntries[i];\n        const hash = createHash(algorithm);\n        hash.update(src);\n        const digest = hash.digest();\n        if (digest.length === expected.length &&\n          timingSafeEqual(digest, expected)) {\n          foundMatch = true;\n          break;\n        }\n        realIntegrities.set(algorithm, digest.toString('base64'));\n      }\n      if (!foundMatch) {\n        throw new ERR_MANIFEST_ASSERT_INTEGRITY(manifestURL, realIntegrities);\n      }\n    }\n    require('internal/process/policy')\n      .setup(src, manifestURL.href);\n  }\n}\n\nfunction initializeWASI() {\n  const { NativeModule } = require('internal/bootstrap/loaders');\n  const mod = NativeModule.map.get('wasi');\n  mod.canBeRequiredByUsers =\n    getOptionValue('--experimental-wasi-unstable-preview1');\n}\n\nfunction initializeCJSLoader() {\n  const CJSLoader = require('internal/modules/cjs/loader');\n  CJSLoader.Module._initPaths();\n  // TODO(joyeecheung): deprecate this in favor of a proper hook?\n  CJSLoader.Module.runMain =\n    require('internal/modules/run_main').executeUserEntryPoint;\n}\n\nfunction initializeESMLoader() {\n  // Create this WeakMap in js-land because V8 has no C++ API for WeakMap.\n  internalBinding('module_wrap').callbackMap = new SafeWeakMap();\n\n  if (shouldNotRegisterESMLoader) return;\n\n  const {\n    setImportModuleDynamicallyCallback,\n    setInitializeImportMetaObjectCallback\n  } = internalBinding('module_wrap');\n  const esm = require('internal/process/esm_loader');\n  // Setup per-isolate callbacks that locate data or callbacks that we keep\n  // track of for different ESM modules.\n  setInitializeImportMetaObjectCallback(esm.initializeImportMetaObject);\n  setImportModuleDynamicallyCallback(esm.importModuleDynamicallyCallback);\n}\n\nfunction initializeFrozenIntrinsics() {\n  if (getOptionValue('--frozen-intrinsics')) {\n    process.emitWarning('The --frozen-intrinsics flag is experimental',\n                        'ExperimentalWarning');\n    require('internal/freeze_intrinsics')();\n  }\n}\n\nfunction loadPreloadModules() {\n  // For user code, we preload modules if `-r` is passed\n  const preloadModules = getOptionValue('--require');\n  if (preloadModules && preloadModules.length > 0) {\n    const {\n      Module: {\n        _preloadModules\n      },\n    } = require('internal/modules/cjs/loader');\n    _preloadModules(preloadModules);\n  }\n}\n\nfunction setupAsarSupport() {\n  process._linkedBinding('electron_common_asar').initAsarSupport(require);\n}\n\nmodule.exports = {\n  patchProcessObject,\n  setupCoverageHooks,\n  setupWarningHandler,\n  setupDebugEnv,\n  prepareMainThreadExecution,\n  initializeDeprecations,\n  initializeESMLoader,\n  initializeFrozenIntrinsics,\n  loadPreloadModules,\n  setupTraceCategoryState,\n  setupInspectorHooks,\n  initializeReport,\n  initializeCJSLoader,\n  initializeWASI\n};\n"
  },
  {
    "url": "internal/bootstrap/switches/does_own_process_state.js",
    "ranges": [
      {
        "start": 0,
        "end": 1278
      },
      {
        "start": 1695,
        "end": 1699
      },
      {
        "start": 2179,
        "end": 2232
      },
      {
        "start": 2460,
        "end": 2469
      },
      {
        "start": 2687,
        "end": 3065
      },
      {
        "start": 3236,
        "end": 3238
      },
      {
        "start": 3374,
        "end": 3480
      }
    ],
    "text": "'use strict';\n\nconst credentials = internalBinding('credentials');\nconst rawMethods = internalBinding('process_methods');\n\nprocess.abort = rawMethods.abort;\nprocess.umask = wrappedUmask;\nprocess.chdir = wrappedChdir;\nprocess.cwd = wrappedCwd;\n\nif (credentials.implementsPosixCredentials) {\n  const wrapped = wrapPosixCredentialSetters(credentials);\n\n  process.initgroups = wrapped.initgroups;\n  process.setgroups = wrapped.setgroups;\n  process.setegid = wrapped.setegid;\n  process.seteuid = wrapped.seteuid;\n  process.setgid = wrapped.setgid;\n  process.setuid = wrapped.setuid;\n}\n\n// ---- keep the attachment of the wrappers above so that it's easier to ----\n// ----              compare the setups side-by-side                    -----\n\nconst {\n  parseFileMode,\n  validateString\n} = require('internal/validators');\n\nfunction wrapPosixCredentialSetters(credentials) {\n  const {\n    ArrayIsArray,\n  } = primordials;\n  const {\n    codes: {\n      ERR_INVALID_ARG_TYPE,\n      ERR_UNKNOWN_CREDENTIAL\n    }\n  } = require('internal/errors');\n  const {\n    validateUint32\n  } = require('internal/validators');\n\n  const {\n    initgroups: _initgroups,\n    setgroups: _setgroups,\n    setegid: _setegid,\n    seteuid: _seteuid,\n    setgid: _setgid,\n    setuid: _setuid\n  } = credentials;\n\n  function initgroups(user, extraGroup) {\n    validateId(user, 'user');\n    validateId(extraGroup, 'extraGroup');\n    // Result is 0 on success, 1 if user is unknown, 2 if group is unknown.\n    const result = _initgroups(user, extraGroup);\n    if (result === 1) {\n      throw new ERR_UNKNOWN_CREDENTIAL('User', user);\n    } else if (result === 2) {\n      throw new ERR_UNKNOWN_CREDENTIAL('Group', extraGroup);\n    }\n  }\n\n  function setgroups(groups) {\n    if (!ArrayIsArray(groups)) {\n      throw new ERR_INVALID_ARG_TYPE('groups', 'Array', groups);\n    }\n    for (let i = 0; i < groups.length; i++) {\n      validateId(groups[i], `groups[${i}]`);\n    }\n    // Result is 0 on success. A positive integer indicates that the\n    // corresponding group was not found.\n    const result = _setgroups(groups);\n    if (result > 0) {\n      throw new ERR_UNKNOWN_CREDENTIAL('Group', groups[result - 1]);\n    }\n  }\n\n  function wrapIdSetter(type, method) {\n    return function(id) {\n      validateId(id, 'id');\n      // Result is 0 on success, 1 if credential is unknown.\n      const result = method(id);\n      if (result === 1) {\n        throw new ERR_UNKNOWN_CREDENTIAL(type, id);\n      }\n    };\n  }\n\n  function validateId(id, name) {\n    if (typeof id === 'number') {\n      validateUint32(id, name);\n    } else if (typeof id !== 'string') {\n      throw new ERR_INVALID_ARG_TYPE(name, ['number', 'string'], id);\n    }\n  }\n\n  return {\n    initgroups,\n    setgroups,\n    setegid: wrapIdSetter('Group', _setegid),\n    seteuid: wrapIdSetter('User', _seteuid),\n    setgid: wrapIdSetter('Group', _setgid),\n    setuid: wrapIdSetter('User', _setuid)\n  };\n}\n\n// Cache the working directory to prevent lots of lookups. If the working\n// directory is changed by `chdir`, it'll be updated.\nlet cachedCwd = '';\n\nfunction wrappedChdir(directory) {\n  validateString(directory, 'directory');\n  rawMethods.chdir(directory);\n  // Mark cache that it requires an update.\n  cachedCwd = '';\n}\n\nfunction wrappedUmask(mask) {\n  if (mask !== undefined) {\n    mask = parseFileMode(mask, 'mask');\n  }\n  return rawMethods.umask(mask);\n}\n\nfunction wrappedCwd() {\n  if (cachedCwd === '')\n    cachedCwd = rawMethods.cwd();\n  return cachedCwd;\n}\n"
  },
  {
    "url": "internal/bootstrap/switches/is_main_thread.js",
    "ranges": [
      {
        "start": 0,
        "end": 513
      },
      {
        "start": 521,
        "end": 559
      },
      {
        "start": 567,
        "end": 1278
      },
      {
        "start": 2845,
        "end": 2847
      },
      {
        "start": 3230,
        "end": 3268
      },
      {
        "start": 3599,
        "end": 3601
      },
      {
        "start": 3932,
        "end": 3934
      },
      {
        "start": 6253,
        "end": 6316
      },
      {
        "start": 6395,
        "end": 6397
      }
    ],
    "text": "'use strict';\n\nconst { ObjectDefineProperty } = primordials;\nconst rawMethods = internalBinding('process_methods');\n\n// TODO(joyeecheung): deprecate and remove these underscore methods\nprocess._debugProcess = rawMethods._debugProcess;\nprocess._debugEnd = rawMethods._debugEnd;\n\n// See the discussion in https://github.com/nodejs/node/issues/19009 and\n// https://github.com/nodejs/node/pull/34010 for why these are no-ops.\n// Five word summary: they were broken beyond repair.\nprocess._startProfilerIdleNotifier = () => {};\nprocess._stopProfilerIdleNotifier = () => {};\n\nfunction defineStream(name, getter) {\n  ObjectDefineProperty(process, name, {\n    configurable: true,\n    enumerable: true,\n    get: getter\n  });\n}\n\ndefineStream('stdout', getStdout);\ndefineStream('stdin', getStdin);\ndefineStream('stderr', getStderr);\n\n// Worker threads don't receive signals.\nconst {\n  startListeningIfSignal,\n  stopListeningIfSignal\n} = require('internal/process/signal');\nprocess.on('newListener', startListeningIfSignal);\nprocess.on('removeListener', stopListeningIfSignal);\n\n// ---- keep the attachment of the wrappers above so that it's easier to ----\n// ----              compare the setups side-by-side                    -----\n\nconst { guessHandleType } = internalBinding('util');\n\nfunction createWritableStdioStream(fd) {\n  let stream;\n  // Note stream._type is used for test-module-load-list.js\n  switch (guessHandleType(fd)) {\n    case 'TTY':\n      const tty = require('tty');\n      stream = new tty.WriteStream(fd);\n      stream._type = 'tty';\n      break;\n\n    case 'FILE':\n      const SyncWriteStream = require('internal/fs/sync_write_stream');\n      stream = new SyncWriteStream(fd, { autoClose: false });\n      stream._type = 'fs';\n      break;\n\n    case 'PIPE':\n    case 'TCP':\n      const net = require('net');\n\n      // If fd is already being used for the IPC channel, libuv will return\n      // an error when trying to use it again. In that case, create the socket\n      // using the existing handle instead of the fd.\n      if (process.channel && process.channel.fd === fd) {\n        const { kChannelHandle } = require('internal/child_process');\n        stream = new net.Socket({\n          handle: process[kChannelHandle],\n          readable: false,\n          writable: true\n        });\n      } else {\n        stream = new net.Socket({\n          fd,\n          readable: false,\n          writable: true\n        });\n      }\n\n      stream._type = 'pipe';\n      break;\n\n    default:\n      // Provide a dummy black-hole output for e.g. non-console\n      // Windows applications.\n      const { Writable } = require('stream');\n      stream = new Writable({\n        write(buf, enc, cb) {\n          cb();\n        }\n      });\n  }\n\n  // For supporting legacy API we put the FD here.\n  stream.fd = fd;\n\n  stream._isStdio = true;\n\n  return stream;\n}\n\nfunction dummyDestroy(err, cb) {\n  cb(err);\n\n  // We need to emit 'close' anyway so that the closing\n  // of the stream is observable. We just make sure we\n  // are not going to do it twice.\n  // The 'close' event is needed so that finished and\n  // pipeline work correctly.\n  if (!this._writableState.emitClose) {\n    process.nextTick(() => {\n      this.emit('close');\n    });\n  }\n}\n\nlet stdin;\nlet stdout;\nlet stderr;\n\nfunction getStdout() {\n  if (stdout) return stdout;\n  stdout = createWritableStdioStream(1);\n  stdout.destroySoon = stdout.destroy;\n  // Override _destroy so that the fd is never actually closed.\n  stdout._destroy = dummyDestroy;\n  if (stdout.isTTY) {\n    process.on('SIGWINCH', () => stdout._refreshSize());\n  }\n  return stdout;\n}\n\nfunction getStderr() {\n  if (stderr) return stderr;\n  stderr = createWritableStdioStream(2);\n  stderr.destroySoon = stderr.destroy;\n  // Override _destroy so that the fd is never actually closed.\n  stderr._destroy = dummyDestroy;\n  if (stderr.isTTY) {\n    process.on('SIGWINCH', () => stderr._refreshSize());\n  }\n  return stderr;\n}\n\nfunction getStdin() {\n  if (stdin) return stdin;\n  const fd = 0;\n\n  switch (guessHandleType(fd)) {\n    case 'TTY':\n      const tty = require('tty');\n      stdin = new tty.ReadStream(fd, {\n        highWaterMark: 0,\n        readable: true,\n        writable: false\n      });\n      break;\n\n    case 'FILE':\n      const fs = require('fs');\n      stdin = new fs.ReadStream(null, { fd: fd, autoClose: false });\n      break;\n\n    case 'PIPE':\n    case 'TCP':\n      const net = require('net');\n\n      // It could be that process has been started with an IPC channel\n      // sitting on fd=0, in such case the pipe for this fd is already\n      // present and creating a new one will lead to the assertion failure\n      // in libuv.\n      if (process.channel && process.channel.fd === fd) {\n        stdin = new net.Socket({\n          handle: process.channel,\n          readable: true,\n          writable: false,\n          manualStart: true\n        });\n      } else {\n        stdin = new net.Socket({\n          fd: fd,\n          readable: true,\n          writable: false,\n          manualStart: true\n        });\n      }\n      // Make sure the stdin can't be `.end()`-ed\n      stdin._writableState.ended = true;\n      break;\n\n    default:\n      // Provide a dummy contentless input for e.g. non-console\n      // Windows applications.\n      const { Readable } = require('stream');\n      stdin = new Readable({ read() {} });\n      stdin.push(null);\n  }\n\n  // For supporting legacy API we put the FD here.\n  stdin.fd = fd;\n\n  // `stdin` starts out life in a paused state, but node doesn't\n  // know yet. Explicitly to readStop() it to put it in the\n  // not-reading state.\n  if (stdin._handle && stdin._handle.readStop) {\n    stdin._handle.reading = false;\n    stdin._readableState.reading = false;\n    stdin._handle.readStop();\n  }\n\n  // If the user calls stdin.pause(), then we need to stop reading\n  // once the stream implementation does so (one nextTick later),\n  // so that the process can close down.\n  stdin.on('pause', () => {\n    process.nextTick(onpause);\n  });\n\n  function onpause() {\n    if (!stdin._handle)\n      return;\n    if (stdin._handle.reading && !stdin.readableFlowing) {\n      stdin._readableState.reading = false;\n      stdin._handle.reading = false;\n      stdin._handle.readStop();\n    }\n  }\n\n  return stdin;\n}\n\n// Used by internal tests.\nrawMethods.resetStdioForTesting = function() {\n  stdin = undefined;\n  stdout = undefined;\n  stderr = undefined;\n};\n"
  },
  {
    "url": "internal/buffer.js",
    "ranges": [
      {
        "start": 0,
        "end": 1107
      },
      {
        "start": 1323,
        "end": 1325
      },
      {
        "start": 1943,
        "end": 1945
      },
      {
        "start": 2348,
        "end": 2368
      },
      {
        "start": 2867,
        "end": 2869
      },
      {
        "start": 3368,
        "end": 3370
      },
      {
        "start": 3871,
        "end": 3873
      },
      {
        "start": 4368,
        "end": 4370
      },
      {
        "start": 4922,
        "end": 4924
      },
      {
        "start": 5307,
        "end": 5309
      },
      {
        "start": 5665,
        "end": 5667
      },
      {
        "start": 5993,
        "end": 5995
      },
      {
        "start": 6283,
        "end": 6285
      },
      {
        "start": 6545,
        "end": 6547
      },
      {
        "start": 6727,
        "end": 6729
      },
      {
        "start": 7281,
        "end": 7283
      },
      {
        "start": 7666,
        "end": 7668
      },
      {
        "start": 8024,
        "end": 8026
      },
      {
        "start": 8352,
        "end": 8354
      },
      {
        "start": 8642,
        "end": 8644
      },
      {
        "start": 8904,
        "end": 8906
      },
      {
        "start": 9451,
        "end": 9453
      },
      {
        "start": 9884,
        "end": 9886
      },
      {
        "start": 10273,
        "end": 10275
      },
      {
        "start": 10610,
        "end": 10612
      },
      {
        "start": 10944,
        "end": 10946
      },
      {
        "start": 11252,
        "end": 11254
      },
      {
        "start": 11462,
        "end": 11464
      },
      {
        "start": 12009,
        "end": 12011
      },
      {
        "start": 12440,
        "end": 12442
      },
      {
        "start": 12830,
        "end": 12832
      },
      {
        "start": 13167,
        "end": 13169
      },
      {
        "start": 13501,
        "end": 13503
      },
      {
        "start": 13809,
        "end": 13826
      },
      {
        "start": 14231,
        "end": 14233
      },
      {
        "start": 14637,
        "end": 14639
      },
      {
        "start": 15209,
        "end": 15211
      },
      {
        "start": 15780,
        "end": 15801
      },
      {
        "start": 16283,
        "end": 16285
      },
      {
        "start": 16407,
        "end": 16409
      },
      {
        "start": 16907,
        "end": 16909
      },
      {
        "start": 17031,
        "end": 17033
      },
      {
        "start": 17177,
        "end": 17179
      },
      {
        "start": 17323,
        "end": 17325
      },
      {
        "start": 17934,
        "end": 17936
      },
      {
        "start": 18349,
        "end": 18351
      },
      {
        "start": 18730,
        "end": 18732
      },
      {
        "start": 19039,
        "end": 19041
      },
      {
        "start": 19147,
        "end": 19149
      },
      {
        "start": 19408,
        "end": 19410
      },
      {
        "start": 19606,
        "end": 19608
      },
      {
        "start": 19710,
        "end": 19712
      },
      {
        "start": 20124,
        "end": 20126
      },
      {
        "start": 20220,
        "end": 20222
      },
      {
        "start": 20831,
        "end": 20833
      },
      {
        "start": 21254,
        "end": 21256
      },
      {
        "start": 21618,
        "end": 21620
      },
      {
        "start": 21935,
        "end": 21937
      },
      {
        "start": 22043,
        "end": 22045
      },
      {
        "start": 22310,
        "end": 22312
      },
      {
        "start": 22508,
        "end": 22510
      },
      {
        "start": 22612,
        "end": 22614
      },
      {
        "start": 23276,
        "end": 23278
      },
      {
        "start": 23393,
        "end": 23395
      },
      {
        "start": 23502,
        "end": 23504
      },
      {
        "start": 23601,
        "end": 23603
      },
      {
        "start": 24265,
        "end": 24267
      },
      {
        "start": 24382,
        "end": 24384
      },
      {
        "start": 24491,
        "end": 24510
      },
      {
        "start": 24976,
        "end": 24978
      },
      {
        "start": 25445,
        "end": 25447
      },
      {
        "start": 25748,
        "end": 25750
      },
      {
        "start": 26052,
        "end": 29662
      }
    ],
    "text": "'use strict';\n\nconst {\n  BigInt,\n  Float32Array,\n  Float64Array,\n  MathFloor,\n  Number,\n  Uint8Array,\n} = primordials;\n\nconst {\n  ERR_BUFFER_OUT_OF_BOUNDS,\n  ERR_INVALID_ARG_TYPE,\n  ERR_OUT_OF_RANGE\n} = require('internal/errors').codes;\nconst { validateNumber } = require('internal/validators');\nconst {\n  asciiSlice,\n  base64Slice,\n  latin1Slice,\n  hexSlice,\n  ucs2Slice,\n  utf8Slice,\n  asciiWrite,\n  base64Write,\n  latin1Write,\n  hexWrite,\n  ucs2Write,\n  utf8Write\n} = internalBinding('buffer');\nconst {\n  untransferable_object_private_symbol,\n  setHiddenValue,\n} = internalBinding('util');\n\n// Temporary buffers to convert numbers.\nconst float32Array = new Float32Array(1);\nconst uInt8Float32Array = new Uint8Array(float32Array.buffer);\nconst float64Array = new Float64Array(1);\nconst uInt8Float64Array = new Uint8Array(float64Array.buffer);\n\n// Check endianness.\nfloat32Array[0] = -1; // 0xBF800000\n// Either it is [0, 0, 128, 191] or [191, 128, 0, 0]. It is not possible to\n// check this with `os.endianness()` because that is determined at compile time.\nconst bigEndian = uInt8Float32Array[3] === 0;\n\nfunction checkBounds(buf, offset, byteLength) {\n  validateNumber(offset, 'offset');\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined)\n    boundsError(offset, buf.length - (byteLength + 1));\n}\n\nfunction checkInt(value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : '';\n    let range;\n    if (byteLength > 3) {\n      if (min === 0 || min === 0n) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`;\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`;\n    }\n    throw new ERR_OUT_OF_RANGE('value', range, value);\n  }\n  checkBounds(buf, offset, byteLength);\n}\n\nfunction boundsError(value, length, type) {\n  if (MathFloor(value) !== value) {\n    validateNumber(value, type);\n    throw new ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);\n  }\n\n  if (length < 0)\n    throw new ERR_BUFFER_OUT_OF_BOUNDS();\n\n  throw new ERR_OUT_OF_RANGE(type || 'offset',\n                             `>= ${type ? 1 : 0} and <= ${length}`,\n                             value);\n}\n\n// Read integers.\nfunction readBigUInt64LE(offset = 0) {\n  validateNumber(offset, 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset, this.length - 8);\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24;\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24;\n\n  return BigInt(lo) + (BigInt(hi) << 32n);\n}\n\nfunction readBigUInt64BE(offset = 0) {\n  validateNumber(offset, 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset, this.length - 8);\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset];\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last;\n\n  return (BigInt(hi) << 32n) + BigInt(lo);\n}\n\nfunction readBigInt64LE(offset = 0) {\n  validateNumber(offset, 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset, this.length - 8);\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24); // Overflow\n  return (BigInt(val) << 32n) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24);\n}\n\nfunction readBigInt64BE(offset = 0) {\n  validateNumber(offset, 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset, this.length - 8);\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset];\n  return (BigInt(val) << 32n) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last);\n}\n\nfunction readUIntLE(offset, byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset', 'number', offset);\n  if (byteLength === 6)\n    return readUInt48LE(this, offset);\n  if (byteLength === 5)\n    return readUInt40LE(this, offset);\n  if (byteLength === 3)\n    return readUInt24LE(this, offset);\n  if (byteLength === 4)\n    return this.readUInt32LE(offset);\n  if (byteLength === 2)\n    return this.readUInt16LE(offset);\n  if (byteLength === 1)\n    return this.readUInt8(offset);\n\n  boundsError(byteLength, 6, 'byteLength');\n}\n\nfunction readUInt48LE(buf, offset = 0) {\n  validateNumber(offset, 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset, buf.length - 6);\n\n  return first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24 +\n    (buf[++offset] + last * 2 ** 8) * 2 ** 32;\n}\n\nfunction readUInt40LE(buf, offset = 0) {\n  validateNumber(offset, 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset, buf.length - 5);\n\n  return first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24 +\n    last * 2 ** 32;\n}\n\nfunction readUInt32LE(offset = 0) {\n  validateNumber(offset, 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset, this.length - 4);\n\n  return first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24;\n}\n\nfunction readUInt24LE(buf, offset = 0) {\n  validateNumber(offset, 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset, buf.length - 3);\n\n  return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;\n}\n\nfunction readUInt16LE(offset = 0) {\n  validateNumber(offset, 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset, this.length - 2);\n\n  return first + last * 2 ** 8;\n}\n\nfunction readUInt8(offset = 0) {\n  validateNumber(offset, 'offset');\n  const val = this[offset];\n  if (val === undefined)\n    boundsError(offset, this.length - 1);\n\n  return val;\n}\n\nfunction readUIntBE(offset, byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset', 'number', offset);\n  if (byteLength === 6)\n    return readUInt48BE(this, offset);\n  if (byteLength === 5)\n    return readUInt40BE(this, offset);\n  if (byteLength === 3)\n    return readUInt24BE(this, offset);\n  if (byteLength === 4)\n    return this.readUInt32BE(offset);\n  if (byteLength === 2)\n    return this.readUInt16BE(offset);\n  if (byteLength === 1)\n    return this.readUInt8(offset);\n\n  boundsError(byteLength, 6, 'byteLength');\n}\n\nfunction readUInt48BE(buf, offset = 0) {\n  validateNumber(offset, 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset, buf.length - 6);\n\n  return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readUInt40BE(buf, offset = 0) {\n  validateNumber(offset, 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset, buf.length - 5);\n\n  return first * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readUInt32BE(offset = 0) {\n  validateNumber(offset, 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset, this.length - 4);\n\n  return first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readUInt24BE(buf, offset = 0) {\n  validateNumber(offset, 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset, buf.length - 3);\n\n  return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;\n}\n\nfunction readUInt16BE(offset = 0) {\n  validateNumber(offset, 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset, this.length - 2);\n\n  return first * 2 ** 8 + last;\n}\n\nfunction readIntLE(offset, byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset', 'number', offset);\n  if (byteLength === 6)\n    return readInt48LE(this, offset);\n  if (byteLength === 5)\n    return readInt40LE(this, offset);\n  if (byteLength === 3)\n    return readInt24LE(this, offset);\n  if (byteLength === 4)\n    return this.readInt32LE(offset);\n  if (byteLength === 2)\n    return this.readInt16LE(offset);\n  if (byteLength === 1)\n    return this.readInt8(offset);\n\n  boundsError(byteLength, 6, 'byteLength');\n}\n\nfunction readInt48LE(buf, offset = 0) {\n  validateNumber(offset, 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset, buf.length - 6);\n\n  const val = buf[offset + 4] + last * 2 ** 8;\n  return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 +\n    first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24;\n}\n\nfunction readInt40LE(buf, offset = 0) {\n  validateNumber(offset, 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset, buf.length - 5);\n\n  return (last | (last & 2 ** 7) * 0x1fffffe) * 2 ** 32 +\n    first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24;\n}\n\nfunction readInt32LE(offset = 0) {\n  validateNumber(offset, 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset, this.length - 4);\n\n  return first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    (last << 24); // Overflow\n}\n\nfunction readInt24LE(buf, offset = 0) {\n  validateNumber(offset, 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset, buf.length - 3);\n\n  const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;\n  return val | (val & 2 ** 23) * 0x1fe;\n}\n\nfunction readInt16LE(offset = 0) {\n  validateNumber(offset, 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset, this.length - 2);\n\n  const val = first + last * 2 ** 8;\n  return val | (val & 2 ** 15) * 0x1fffe;\n}\n\nfunction readInt8(offset = 0) {\n  validateNumber(offset, 'offset');\n  const val = this[offset];\n  if (val === undefined)\n    boundsError(offset, this.length - 1);\n\n  return val | (val & 2 ** 7) * 0x1fffffe;\n}\n\nfunction readIntBE(offset, byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset', 'number', offset);\n  if (byteLength === 6)\n    return readInt48BE(this, offset);\n  if (byteLength === 5)\n    return readInt40BE(this, offset);\n  if (byteLength === 3)\n    return readInt24BE(this, offset);\n  if (byteLength === 4)\n    return this.readInt32BE(offset);\n  if (byteLength === 2)\n    return this.readInt16BE(offset);\n  if (byteLength === 1)\n    return this.readInt8(offset);\n\n  boundsError(byteLength, 6, 'byteLength');\n}\n\nfunction readInt48BE(buf, offset = 0) {\n  validateNumber(offset, 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset, buf.length - 6);\n\n  const val = buf[++offset] + first * 2 ** 8;\n  return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readInt40BE(buf, offset = 0) {\n  validateNumber(offset, 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset, buf.length - 5);\n\n  return (first | (first & 2 ** 7) * 0x1fffffe) * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readInt32BE(offset = 0) {\n  validateNumber(offset, 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset, this.length - 4);\n\n  return (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readInt24BE(buf, offset = 0) {\n  validateNumber(offset, 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset, buf.length - 3);\n\n  const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;\n  return val | (val & 2 ** 23) * 0x1fe;\n}\n\nfunction readInt16BE(offset = 0) {\n  validateNumber(offset, 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset, this.length - 2);\n\n  const val = first * 2 ** 8 + last;\n  return val | (val & 2 ** 15) * 0x1fffe;\n}\n\n// Read floats\nfunction readFloatBackwards(offset = 0) {\n  validateNumber(offset, 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset, this.length - 4);\n\n  uInt8Float32Array[3] = first;\n  uInt8Float32Array[2] = this[++offset];\n  uInt8Float32Array[1] = this[++offset];\n  uInt8Float32Array[0] = last;\n  return float32Array[0];\n}\n\nfunction readFloatForwards(offset = 0) {\n  validateNumber(offset, 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset, this.length - 4);\n\n  uInt8Float32Array[0] = first;\n  uInt8Float32Array[1] = this[++offset];\n  uInt8Float32Array[2] = this[++offset];\n  uInt8Float32Array[3] = last;\n  return float32Array[0];\n}\n\nfunction readDoubleBackwards(offset = 0) {\n  validateNumber(offset, 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset, this.length - 8);\n\n  uInt8Float64Array[7] = first;\n  uInt8Float64Array[6] = this[++offset];\n  uInt8Float64Array[5] = this[++offset];\n  uInt8Float64Array[4] = this[++offset];\n  uInt8Float64Array[3] = this[++offset];\n  uInt8Float64Array[2] = this[++offset];\n  uInt8Float64Array[1] = this[++offset];\n  uInt8Float64Array[0] = last;\n  return float64Array[0];\n}\n\nfunction readDoubleForwards(offset = 0) {\n  validateNumber(offset, 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset, this.length - 8);\n\n  uInt8Float64Array[0] = first;\n  uInt8Float64Array[1] = this[++offset];\n  uInt8Float64Array[2] = this[++offset];\n  uInt8Float64Array[3] = this[++offset];\n  uInt8Float64Array[4] = this[++offset];\n  uInt8Float64Array[5] = this[++offset];\n  uInt8Float64Array[6] = this[++offset];\n  uInt8Float64Array[7] = last;\n  return float64Array[0];\n}\n\n// Write integers.\nfunction writeBigU_Int64LE(buf, value, offset, min, max) {\n  checkInt(value, min, max, buf, offset, 7);\n\n  let lo = Number(value & 0xffffffffn);\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  let hi = Number(value >> 32n & 0xffffffffn);\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  return offset;\n}\n\nfunction writeBigUInt64LE(value, offset = 0) {\n  return writeBigU_Int64LE(this, value, offset, 0n, 0xffffffffffffffffn);\n}\n\nfunction writeBigU_Int64BE(buf, value, offset, min, max) {\n  checkInt(value, min, max, buf, offset, 7);\n\n  let lo = Number(value & 0xffffffffn);\n  buf[offset + 7] = lo;\n  lo = lo >> 8;\n  buf[offset + 6] = lo;\n  lo = lo >> 8;\n  buf[offset + 5] = lo;\n  lo = lo >> 8;\n  buf[offset + 4] = lo;\n  let hi = Number(value >> 32n & 0xffffffffn);\n  buf[offset + 3] = hi;\n  hi = hi >> 8;\n  buf[offset + 2] = hi;\n  hi = hi >> 8;\n  buf[offset + 1] = hi;\n  hi = hi >> 8;\n  buf[offset] = hi;\n  return offset + 8;\n}\n\nfunction writeBigUInt64BE(value, offset = 0) {\n  return writeBigU_Int64BE(this, value, offset, 0n, 0xffffffffffffffffn);\n}\n\nfunction writeBigInt64LE(value, offset = 0) {\n  return writeBigU_Int64LE(\n    this, value, offset, -0x8000000000000000n, 0x7fffffffffffffffn);\n}\n\nfunction writeBigInt64BE(value, offset = 0) {\n  return writeBigU_Int64BE(\n    this, value, offset, -0x8000000000000000n, 0x7fffffffffffffffn);\n}\n\nfunction writeUIntLE(value, offset, byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48LE(this, value, offset, 0, 0xffffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40LE(this, value, offset, 0, 0xffffffffff);\n  if (byteLength === 3)\n    return writeU_Int24LE(this, value, offset, 0, 0xffffff);\n  if (byteLength === 4)\n    return writeU_Int32LE(this, value, offset, 0, 0xffffffff);\n  if (byteLength === 2)\n    return writeU_Int16LE(this, value, offset, 0, 0xffff);\n  if (byteLength === 1)\n    return writeU_Int8(this, value, offset, 0, 0xff);\n\n  boundsError(byteLength, 6, 'byteLength');\n}\n\nfunction writeU_Int48LE(buf, value, offset, min, max) {\n  value = +value;\n  checkInt(value, min, max, buf, offset, 5);\n\n  const newVal = MathFloor(value * 2 ** -32);\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  buf[offset++] = newVal;\n  buf[offset++] = (newVal >>> 8);\n  return offset;\n}\n\nfunction writeU_Int40LE(buf, value, offset, min, max) {\n  value = +value;\n  checkInt(value, min, max, buf, offset, 4);\n\n  const newVal = value;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  buf[offset++] = MathFloor(newVal * 2 ** -32);\n  return offset;\n}\n\nfunction writeU_Int32LE(buf, value, offset, min, max) {\n  value = +value;\n  checkInt(value, min, max, buf, offset, 3);\n\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  return offset;\n}\n\nfunction writeUInt32LE(value, offset = 0) {\n  return writeU_Int32LE(this, value, offset, 0, 0xffffffff);\n}\n\nfunction writeU_Int24LE(buf, value, offset, min, max) {\n  value = +value;\n  checkInt(value, min, max, buf, offset, 2);\n\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  return offset;\n}\n\nfunction writeU_Int16LE(buf, value, offset, min, max) {\n  value = +value;\n  checkInt(value, min, max, buf, offset, 1);\n\n  buf[offset++] = value;\n  buf[offset++] = (value >>> 8);\n  return offset;\n}\n\nfunction writeUInt16LE(value, offset = 0) {\n  return writeU_Int16LE(this, value, offset, 0, 0xffff);\n}\n\nfunction writeU_Int8(buf, value, offset, min, max) {\n  value = +value;\n  // `checkInt()` can not be used here because it checks two entries.\n  validateNumber(offset, 'offset');\n  if (value > max || value < min) {\n    throw new ERR_OUT_OF_RANGE('value', `>= ${min} and <= ${max}`, value);\n  }\n  if (buf[offset] === undefined)\n    boundsError(offset, buf.length - 1);\n\n  buf[offset] = value;\n  return offset + 1;\n}\n\nfunction writeUInt8(value, offset = 0) {\n  return writeU_Int8(this, value, offset, 0, 0xff);\n}\n\nfunction writeUIntBE(value, offset, byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48BE(this, value, offset, 0, 0xffffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40BE(this, value, offset, 0, 0xffffffffff);\n  if (byteLength === 3)\n    return writeU_Int24BE(this, value, offset, 0, 0xffffff);\n  if (byteLength === 4)\n    return writeU_Int32BE(this, value, offset, 0, 0xffffffff);\n  if (byteLength === 2)\n    return writeU_Int16BE(this, value, offset, 0, 0xffff);\n  if (byteLength === 1)\n    return writeU_Int8(this, value, offset, 0, 0xff);\n\n  boundsError(byteLength, 6, 'byteLength');\n}\n\nfunction writeU_Int48BE(buf, value, offset, min, max) {\n  value = +value;\n  checkInt(value, min, max, buf, offset, 5);\n\n  const newVal = MathFloor(value * 2 ** -32);\n  buf[offset++] = (newVal >>> 8);\n  buf[offset++] = newVal;\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\n\nfunction writeU_Int40BE(buf, value, offset, min, max) {\n  value = +value;\n  checkInt(value, min, max, buf, offset, 4);\n\n  buf[offset++] = MathFloor(value * 2 ** -32);\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\n\nfunction writeU_Int32BE(buf, value, offset, min, max) {\n  value = +value;\n  checkInt(value, min, max, buf, offset, 3);\n\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\n\nfunction writeUInt32BE(value, offset = 0) {\n  return writeU_Int32BE(this, value, offset, 0, 0xffffffff);\n}\n\nfunction writeU_Int24BE(buf, value, offset, min, max) {\n  value = +value;\n  checkInt(value, min, max, buf, offset, 2);\n\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 3;\n}\n\nfunction writeU_Int16BE(buf, value, offset, min, max) {\n  value = +value;\n  checkInt(value, min, max, buf, offset, 1);\n\n  buf[offset++] = (value >>> 8);\n  buf[offset++] = value;\n  return offset;\n}\n\nfunction writeUInt16BE(value, offset = 0) {\n  return writeU_Int16BE(this, value, offset, 0, 0xffff);\n}\n\nfunction writeIntLE(value, offset, byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48LE(this, value, offset, -0x800000000000, 0x7fffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40LE(this, value, offset, -0x8000000000, 0x7fffffffff);\n  if (byteLength === 3)\n    return writeU_Int24LE(this, value, offset, -0x800000, 0x7fffff);\n  if (byteLength === 4)\n    return writeU_Int32LE(this, value, offset, -0x80000000, 0x7fffffff);\n  if (byteLength === 2)\n    return writeU_Int16LE(this, value, offset, -0x8000, 0x7fff);\n  if (byteLength === 1)\n    return writeU_Int8(this, value, offset, -0x80, 0x7f);\n\n  boundsError(byteLength, 6, 'byteLength');\n}\n\nfunction writeInt32LE(value, offset = 0) {\n  return writeU_Int32LE(this, value, offset, -0x80000000, 0x7fffffff);\n}\n\nfunction writeInt16LE(value, offset = 0) {\n  return writeU_Int16LE(this, value, offset, -0x8000, 0x7fff);\n}\n\nfunction writeInt8(value, offset = 0) {\n  return writeU_Int8(this, value, offset, -0x80, 0x7f);\n}\n\nfunction writeIntBE(value, offset, byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48BE(this, value, offset, -0x800000000000, 0x7fffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40BE(this, value, offset, -0x8000000000, 0x7fffffffff);\n  if (byteLength === 3)\n    return writeU_Int24BE(this, value, offset, -0x800000, 0x7fffff);\n  if (byteLength === 4)\n    return writeU_Int32BE(this, value, offset, -0x80000000, 0x7fffffff);\n  if (byteLength === 2)\n    return writeU_Int16BE(this, value, offset, -0x8000, 0x7fff);\n  if (byteLength === 1)\n    return writeU_Int8(this, value, offset, -0x80, 0x7f);\n\n  boundsError(byteLength, 6, 'byteLength');\n}\n\nfunction writeInt32BE(value, offset = 0) {\n  return writeU_Int32BE(this, value, offset, -0x80000000, 0x7fffffff);\n}\n\nfunction writeInt16BE(value, offset = 0) {\n  return writeU_Int16BE(this, value, offset, -0x8000, 0x7fff);\n}\n\n// Write floats.\nfunction writeDoubleForwards(val, offset = 0) {\n  val = +val;\n  checkBounds(this, offset, 7);\n\n  float64Array[0] = val;\n  this[offset++] = uInt8Float64Array[0];\n  this[offset++] = uInt8Float64Array[1];\n  this[offset++] = uInt8Float64Array[2];\n  this[offset++] = uInt8Float64Array[3];\n  this[offset++] = uInt8Float64Array[4];\n  this[offset++] = uInt8Float64Array[5];\n  this[offset++] = uInt8Float64Array[6];\n  this[offset++] = uInt8Float64Array[7];\n  return offset;\n}\n\nfunction writeDoubleBackwards(val, offset = 0) {\n  val = +val;\n  checkBounds(this, offset, 7);\n\n  float64Array[0] = val;\n  this[offset++] = uInt8Float64Array[7];\n  this[offset++] = uInt8Float64Array[6];\n  this[offset++] = uInt8Float64Array[5];\n  this[offset++] = uInt8Float64Array[4];\n  this[offset++] = uInt8Float64Array[3];\n  this[offset++] = uInt8Float64Array[2];\n  this[offset++] = uInt8Float64Array[1];\n  this[offset++] = uInt8Float64Array[0];\n  return offset;\n}\n\nfunction writeFloatForwards(val, offset = 0) {\n  val = +val;\n  checkBounds(this, offset, 3);\n\n  float32Array[0] = val;\n  this[offset++] = uInt8Float32Array[0];\n  this[offset++] = uInt8Float32Array[1];\n  this[offset++] = uInt8Float32Array[2];\n  this[offset++] = uInt8Float32Array[3];\n  return offset;\n}\n\nfunction writeFloatBackwards(val, offset = 0) {\n  val = +val;\n  checkBounds(this, offset, 3);\n\n  float32Array[0] = val;\n  this[offset++] = uInt8Float32Array[3];\n  this[offset++] = uInt8Float32Array[2];\n  this[offset++] = uInt8Float32Array[1];\n  this[offset++] = uInt8Float32Array[0];\n  return offset;\n}\n\nclass FastBuffer extends Uint8Array {}\n\nfunction addBufferPrototypeMethods(proto) {\n  proto.readBigUInt64LE = readBigUInt64LE,\n  proto.readBigUInt64BE = readBigUInt64BE,\n  proto.readBigUint64LE = readBigUInt64LE,\n  proto.readBigUint64BE = readBigUInt64BE,\n  proto.readBigInt64LE = readBigInt64LE,\n  proto.readBigInt64BE = readBigInt64BE,\n  proto.writeBigUInt64LE = writeBigUInt64LE,\n  proto.writeBigUInt64BE = writeBigUInt64BE,\n  proto.writeBigUint64LE = writeBigUInt64LE,\n  proto.writeBigUint64BE = writeBigUInt64BE,\n  proto.writeBigInt64LE = writeBigInt64LE,\n  proto.writeBigInt64BE = writeBigInt64BE,\n\n  proto.readUIntLE = readUIntLE;\n  proto.readUInt32LE = readUInt32LE;\n  proto.readUInt16LE = readUInt16LE;\n  proto.readUInt8 = readUInt8;\n  proto.readUIntBE = readUIntBE;\n  proto.readUInt32BE = readUInt32BE;\n  proto.readUInt16BE = readUInt16BE;\n  proto.readUintLE = readUIntLE;\n  proto.readUint32LE = readUInt32LE;\n  proto.readUint16LE = readUInt16LE;\n  proto.readUint8 = readUInt8;\n  proto.readUintBE = readUIntBE;\n  proto.readUint32BE = readUInt32BE;\n  proto.readUint16BE = readUInt16BE;\n  proto.readIntLE = readIntLE;\n  proto.readInt32LE = readInt32LE;\n  proto.readInt16LE = readInt16LE;\n  proto.readInt8 = readInt8;\n  proto.readIntBE = readIntBE;\n  proto.readInt32BE = readInt32BE;\n  proto.readInt16BE = readInt16BE;\n\n  proto.writeUIntLE = writeUIntLE;\n  proto.writeUInt32LE = writeUInt32LE;\n  proto.writeUInt16LE = writeUInt16LE;\n  proto.writeUInt8 = writeUInt8;\n  proto.writeUIntBE = writeUIntBE;\n  proto.writeUInt32BE = writeUInt32BE;\n  proto.writeUInt16BE = writeUInt16BE;\n  proto.writeUintLE = writeUIntLE;\n  proto.writeUint32LE = writeUInt32LE;\n  proto.writeUint16LE = writeUInt16LE;\n  proto.writeUint8 = writeUInt8;\n  proto.writeUintBE = writeUIntBE;\n  proto.writeUint32BE = writeUInt32BE;\n  proto.writeUint16BE = writeUInt16BE;\n  proto.writeIntLE = writeIntLE;\n  proto.writeInt32LE = writeInt32LE;\n  proto.writeInt16LE = writeInt16LE;\n  proto.writeInt8 = writeInt8;\n  proto.writeIntBE = writeIntBE;\n  proto.writeInt32BE = writeInt32BE;\n  proto.writeInt16BE = writeInt16BE;\n\n  proto.readFloatLE = bigEndian ? readFloatBackwards : readFloatForwards;\n  proto.readFloatBE = bigEndian ? readFloatForwards : readFloatBackwards;\n  proto.readDoubleLE = bigEndian ? readDoubleBackwards : readDoubleForwards;\n  proto.readDoubleBE = bigEndian ? readDoubleForwards : readDoubleBackwards;\n  proto.writeFloatLE = bigEndian ? writeFloatBackwards : writeFloatForwards;\n  proto.writeFloatBE = bigEndian ? writeFloatForwards : writeFloatBackwards;\n  proto.writeDoubleLE = bigEndian ? writeDoubleBackwards : writeDoubleForwards;\n  proto.writeDoubleBE = bigEndian ? writeDoubleForwards : writeDoubleBackwards;\n\n  proto.asciiSlice = asciiSlice;\n  proto.base64Slice = base64Slice;\n  proto.latin1Slice = latin1Slice;\n  proto.hexSlice = hexSlice;\n  proto.ucs2Slice = ucs2Slice;\n  proto.utf8Slice = utf8Slice;\n  proto.asciiWrite = asciiWrite;\n  proto.base64Write = base64Write;\n  proto.latin1Write = latin1Write;\n  proto.hexWrite = hexWrite;\n  proto.ucs2Write = ucs2Write;\n  proto.utf8Write = utf8Write;\n}\n\n// This would better be placed in internal/worker/io.js, but that doesn't work\n// because Buffer needs this and that would introduce a cyclic dependency.\nfunction markAsUntransferable(obj) {\n  if ((typeof obj !== 'object' && typeof obj !== 'function') || obj === null)\n    return;  // This object is a primitive and therefore already untransferable.\n  setHiddenValue(obj, untransferable_object_private_symbol, true);\n}\n\nmodule.exports = {\n  FastBuffer,\n  addBufferPrototypeMethods,\n  markAsUntransferable,\n};\n"
  },
  {
    "url": "internal/constants.js",
    "ranges": [
      {
        "start": 0,
        "end": 1582
      }
    ],
    "text": "'use strict';\n\nconst isWindows = process.platform === 'win32';\n\nmodule.exports = {\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 65, /* A */\n  CHAR_LOWERCASE_A: 97, /* a */\n  CHAR_UPPERCASE_Z: 90, /* Z */\n  CHAR_LOWERCASE_Z: 122, /* z */\n  CHAR_UPPERCASE_C: 67, /* C */\n  CHAR_LOWERCASE_B: 98, /* b */\n  CHAR_LOWERCASE_E: 101, /* e */\n  CHAR_LOWERCASE_N: 110, /* n */\n\n  // Non-alphabetic chars.\n  CHAR_DOT: 46, /* . */\n  CHAR_FORWARD_SLASH: 47, /* / */\n  CHAR_BACKWARD_SLASH: 92, /* \\ */\n  CHAR_VERTICAL_LINE: 124, /* | */\n  CHAR_COLON: 58, /* : */\n  CHAR_QUESTION_MARK: 63, /* ? */\n  CHAR_UNDERSCORE: 95, /* _ */\n  CHAR_LINE_FEED: 10, /* \\n */\n  CHAR_CARRIAGE_RETURN: 13, /* \\r */\n  CHAR_TAB: 9, /* \\t */\n  CHAR_FORM_FEED: 12, /* \\f */\n  CHAR_EXCLAMATION_MARK: 33, /* ! */\n  CHAR_HASH: 35, /* # */\n  CHAR_SPACE: 32, /*   */\n  CHAR_NO_BREAK_SPACE: 160, /* \\u00A0 */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \\uFEFF */\n  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */\n  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */\n  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */\n  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */\n  CHAR_LEFT_CURLY_BRACKET: 123, /* { */\n  CHAR_RIGHT_CURLY_BRACKET: 125, /* } */\n  CHAR_HYPHEN_MINUS: 45, /* - */\n  CHAR_PLUS: 43, /* + */\n  CHAR_DOUBLE_QUOTE: 34, /* \" */\n  CHAR_SINGLE_QUOTE: 39, /* ' */\n  CHAR_PERCENT: 37, /* % */\n  CHAR_SEMICOLON: 59, /* ; */\n  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */\n  CHAR_GRAVE_ACCENT: 96, /* ` */\n  CHAR_AT: 64, /* @ */\n  CHAR_AMPERSAND: 38, /* & */\n  CHAR_EQUAL: 61, /* = */\n\n  // Digits\n  CHAR_0: 48, /* 0 */\n  CHAR_9: 57, /* 9 */\n\n  EOL: isWindows ? '\\r\\n' : '\\n'\n};\n"
  },
  {
    "url": "internal/encoding.js",
    "ranges": [
      {
        "start": 0,
        "end": 958
      },
      {
        "start": 1067,
        "end": 1069
      },
      {
        "start": 1194,
        "end": 1196
      },
      {
        "start": 1321,
        "end": 1323
      },
      {
        "start": 1490,
        "end": 8231
      },
      {
        "start": 8713,
        "end": 8715
      },
      {
        "start": 8894,
        "end": 8965
      },
      {
        "start": 9011,
        "end": 9015
      },
      {
        "start": 9082,
        "end": 9086
      },
      {
        "start": 9178,
        "end": 9182
      },
      {
        "start": 9492,
        "end": 9496
      },
      {
        "start": 9891,
        "end": 10400
      },
      {
        "start": 11127,
        "end": 11134
      },
      {
        "start": 11894,
        "end": 11925
      },
      {
        "start": 14466,
        "end": 14591
      },
      {
        "start": 14672,
        "end": 14679
      },
      {
        "start": 14806,
        "end": 14813
      },
      {
        "start": 14968,
        "end": 14975
      },
      {
        "start": 15589,
        "end": 15873
      }
    ],
    "text": "'use strict';\n\n// An implementation of the WHATWG Encoding Standard\n// https://encoding.spec.whatwg.org\n\nconst {\n  Map,\n  ObjectCreate,\n  ObjectDefineProperties,\n  ObjectGetOwnPropertyDescriptors,\n  Symbol,\n  SymbolToStringTag,\n  Uint32Array,\n  Uint8Array,\n} = primordials;\n\nconst {\n  ERR_ENCODING_INVALID_ENCODED_DATA,\n  ERR_ENCODING_NOT_SUPPORTED,\n  ERR_INVALID_ARG_TYPE,\n  ERR_INVALID_THIS,\n  ERR_NO_ICU\n} = require('internal/errors').codes;\nconst kHandle = Symbol('handle');\nconst kFlags = Symbol('flags');\nconst kEncoding = Symbol('encoding');\nconst kDecoder = Symbol('decoder');\nconst kEncoder = Symbol('encoder');\n\nconst {\n  getConstructorOf,\n  customInspectSymbol: inspect\n} = require('internal/util');\n\nconst {\n  isAnyArrayBuffer,\n  isArrayBufferView,\n  isUint8Array\n} = require('internal/util/types');\n\nconst { validateString } = require('internal/validators');\n\nconst {\n  encodeInto,\n  encodeUtf8String\n} = internalBinding('buffer');\n\nlet Buffer;\nfunction lazyBuffer() {\n  if (Buffer === undefined)\n    Buffer = require('buffer').Buffer;\n  return Buffer;\n}\n\nfunction validateEncoder(obj) {\n  if (obj == null || obj[kEncoder] !== true)\n    throw new ERR_INVALID_THIS('TextEncoder');\n}\n\nfunction validateDecoder(obj) {\n  if (obj == null || obj[kDecoder] !== true)\n    throw new ERR_INVALID_THIS('TextDecoder');\n}\n\nfunction validateArgument(prop, expected, propName, expectedName) {\n  if (typeof prop !== expected)\n    throw new ERR_INVALID_ARG_TYPE(propName, expectedName, prop);\n}\n\nconst CONVERTER_FLAGS_FLUSH = 0x1;\nconst CONVERTER_FLAGS_FATAL = 0x2;\nconst CONVERTER_FLAGS_IGNORE_BOM = 0x4;\n\nconst empty = new Uint8Array(0);\n\nconst encodings = new Map([\n  ['unicode-1-1-utf-8', 'utf-8'],\n  ['utf8', 'utf-8'],\n  ['utf-8', 'utf-8'],\n  ['866', 'ibm866'],\n  ['cp866', 'ibm866'],\n  ['csibm866', 'ibm866'],\n  ['ibm866', 'ibm866'],\n  ['csisolatin2', 'iso-8859-2'],\n  ['iso-8859-2', 'iso-8859-2'],\n  ['iso-ir-101', 'iso-8859-2'],\n  ['iso8859-2', 'iso-8859-2'],\n  ['iso88592', 'iso-8859-2'],\n  ['iso_8859-2', 'iso-8859-2'],\n  ['iso_8859-2:1987', 'iso-8859-2'],\n  ['l2', 'iso-8859-2'],\n  ['latin2', 'iso-8859-2'],\n  ['csisolatin3', 'iso-8859-3'],\n  ['iso-8859-3', 'iso-8859-3'],\n  ['iso-ir-109', 'iso-8859-3'],\n  ['iso8859-3', 'iso-8859-3'],\n  ['iso88593', 'iso-8859-3'],\n  ['iso_8859-3', 'iso-8859-3'],\n  ['iso_8859-3:1988', 'iso-8859-3'],\n  ['l3', 'iso-8859-3'],\n  ['latin3', 'iso-8859-3'],\n  ['csisolatin4', 'iso-8859-4'],\n  ['iso-8859-4', 'iso-8859-4'],\n  ['iso-ir-110', 'iso-8859-4'],\n  ['iso8859-4', 'iso-8859-4'],\n  ['iso88594', 'iso-8859-4'],\n  ['iso_8859-4', 'iso-8859-4'],\n  ['iso_8859-4:1988', 'iso-8859-4'],\n  ['l4', 'iso-8859-4'],\n  ['latin4', 'iso-8859-4'],\n  ['csisolatincyrillic', 'iso-8859-5'],\n  ['cyrillic', 'iso-8859-5'],\n  ['iso-8859-5', 'iso-8859-5'],\n  ['iso-ir-144', 'iso-8859-5'],\n  ['iso8859-5', 'iso-8859-5'],\n  ['iso88595', 'iso-8859-5'],\n  ['iso_8859-5', 'iso-8859-5'],\n  ['iso_8859-5:1988', 'iso-8859-5'],\n  ['arabic', 'iso-8859-6'],\n  ['asmo-708', 'iso-8859-6'],\n  ['csiso88596e', 'iso-8859-6'],\n  ['csiso88596i', 'iso-8859-6'],\n  ['csisolatinarabic', 'iso-8859-6'],\n  ['ecma-114', 'iso-8859-6'],\n  ['iso-8859-6', 'iso-8859-6'],\n  ['iso-8859-6-e', 'iso-8859-6'],\n  ['iso-8859-6-i', 'iso-8859-6'],\n  ['iso-ir-127', 'iso-8859-6'],\n  ['iso8859-6', 'iso-8859-6'],\n  ['iso88596', 'iso-8859-6'],\n  ['iso_8859-6', 'iso-8859-6'],\n  ['iso_8859-6:1987', 'iso-8859-6'],\n  ['csisolatingreek', 'iso-8859-7'],\n  ['ecma-118', 'iso-8859-7'],\n  ['elot_928', 'iso-8859-7'],\n  ['greek', 'iso-8859-7'],\n  ['greek8', 'iso-8859-7'],\n  ['iso-8859-7', 'iso-8859-7'],\n  ['iso-ir-126', 'iso-8859-7'],\n  ['iso8859-7', 'iso-8859-7'],\n  ['iso88597', 'iso-8859-7'],\n  ['iso_8859-7', 'iso-8859-7'],\n  ['iso_8859-7:1987', 'iso-8859-7'],\n  ['sun_eu_greek', 'iso-8859-7'],\n  ['csiso88598e', 'iso-8859-8'],\n  ['csisolatinhebrew', 'iso-8859-8'],\n  ['hebrew', 'iso-8859-8'],\n  ['iso-8859-8', 'iso-8859-8'],\n  ['iso-8859-8-e', 'iso-8859-8'],\n  ['iso-ir-138', 'iso-8859-8'],\n  ['iso8859-8', 'iso-8859-8'],\n  ['iso88598', 'iso-8859-8'],\n  ['iso_8859-8', 'iso-8859-8'],\n  ['iso_8859-8:1988', 'iso-8859-8'],\n  ['visual', 'iso-8859-8'],\n  ['csiso88598i', 'iso-8859-8-i'],\n  ['iso-8859-8-i', 'iso-8859-8-i'],\n  ['logical', 'iso-8859-8-i'],\n  ['csisolatin6', 'iso-8859-10'],\n  ['iso-8859-10', 'iso-8859-10'],\n  ['iso-ir-157', 'iso-8859-10'],\n  ['iso8859-10', 'iso-8859-10'],\n  ['iso885910', 'iso-8859-10'],\n  ['l6', 'iso-8859-10'],\n  ['latin6', 'iso-8859-10'],\n  ['iso-8859-13', 'iso-8859-13'],\n  ['iso8859-13', 'iso-8859-13'],\n  ['iso885913', 'iso-8859-13'],\n  ['iso-8859-14', 'iso-8859-14'],\n  ['iso8859-14', 'iso-8859-14'],\n  ['iso885914', 'iso-8859-14'],\n  ['csisolatin9', 'iso-8859-15'],\n  ['iso-8859-15', 'iso-8859-15'],\n  ['iso8859-15', 'iso-8859-15'],\n  ['iso885915', 'iso-8859-15'],\n  ['iso_8859-15', 'iso-8859-15'],\n  ['l9', 'iso-8859-15'],\n  ['cskoi8r', 'koi8-r'],\n  ['koi', 'koi8-r'],\n  ['koi8', 'koi8-r'],\n  ['koi8-r', 'koi8-r'],\n  ['koi8_r', 'koi8-r'],\n  ['koi8-ru', 'koi8-u'],\n  ['koi8-u', 'koi8-u'],\n  ['csmacintosh', 'macintosh'],\n  ['mac', 'macintosh'],\n  ['macintosh', 'macintosh'],\n  ['x-mac-roman', 'macintosh'],\n  ['dos-874', 'windows-874'],\n  ['iso-8859-11', 'windows-874'],\n  ['iso8859-11', 'windows-874'],\n  ['iso885911', 'windows-874'],\n  ['tis-620', 'windows-874'],\n  ['windows-874', 'windows-874'],\n  ['cp1250', 'windows-1250'],\n  ['windows-1250', 'windows-1250'],\n  ['x-cp1250', 'windows-1250'],\n  ['cp1251', 'windows-1251'],\n  ['windows-1251', 'windows-1251'],\n  ['x-cp1251', 'windows-1251'],\n  ['ansi_x3.4-1968', 'windows-1252'],\n  ['ascii', 'windows-1252'],\n  ['cp1252', 'windows-1252'],\n  ['cp819', 'windows-1252'],\n  ['csisolatin1', 'windows-1252'],\n  ['ibm819', 'windows-1252'],\n  ['iso-8859-1', 'windows-1252'],\n  ['iso-ir-100', 'windows-1252'],\n  ['iso8859-1', 'windows-1252'],\n  ['iso88591', 'windows-1252'],\n  ['iso_8859-1', 'windows-1252'],\n  ['iso_8859-1:1987', 'windows-1252'],\n  ['l1', 'windows-1252'],\n  ['latin1', 'windows-1252'],\n  ['us-ascii', 'windows-1252'],\n  ['windows-1252', 'windows-1252'],\n  ['x-cp1252', 'windows-1252'],\n  ['cp1253', 'windows-1253'],\n  ['windows-1253', 'windows-1253'],\n  ['x-cp1253', 'windows-1253'],\n  ['cp1254', 'windows-1254'],\n  ['csisolatin5', 'windows-1254'],\n  ['iso-8859-9', 'windows-1254'],\n  ['iso-ir-148', 'windows-1254'],\n  ['iso8859-9', 'windows-1254'],\n  ['iso88599', 'windows-1254'],\n  ['iso_8859-9', 'windows-1254'],\n  ['iso_8859-9:1989', 'windows-1254'],\n  ['l5', 'windows-1254'],\n  ['latin5', 'windows-1254'],\n  ['windows-1254', 'windows-1254'],\n  ['x-cp1254', 'windows-1254'],\n  ['cp1255', 'windows-1255'],\n  ['windows-1255', 'windows-1255'],\n  ['x-cp1255', 'windows-1255'],\n  ['cp1256', 'windows-1256'],\n  ['windows-1256', 'windows-1256'],\n  ['x-cp1256', 'windows-1256'],\n  ['cp1257', 'windows-1257'],\n  ['windows-1257', 'windows-1257'],\n  ['x-cp1257', 'windows-1257'],\n  ['cp1258', 'windows-1258'],\n  ['windows-1258', 'windows-1258'],\n  ['x-cp1258', 'windows-1258'],\n  ['x-mac-cyrillic', 'x-mac-cyrillic'],\n  ['x-mac-ukrainian', 'x-mac-cyrillic'],\n  ['chinese', 'gbk'],\n  ['csgb2312', 'gbk'],\n  ['csiso58gb231280', 'gbk'],\n  ['gb2312', 'gbk'],\n  ['gb_2312', 'gbk'],\n  ['gb_2312-80', 'gbk'],\n  ['gbk', 'gbk'],\n  ['iso-ir-58', 'gbk'],\n  ['x-gbk', 'gbk'],\n  ['gb18030', 'gb18030'],\n  ['big5', 'big5'],\n  ['big5-hkscs', 'big5'],\n  ['cn-big5', 'big5'],\n  ['csbig5', 'big5'],\n  ['x-x-big5', 'big5'],\n  ['cseucpkdfmtjapanese', 'euc-jp'],\n  ['euc-jp', 'euc-jp'],\n  ['x-euc-jp', 'euc-jp'],\n  ['csiso2022jp', 'iso-2022-jp'],\n  ['iso-2022-jp', 'iso-2022-jp'],\n  ['csshiftjis', 'shift_jis'],\n  ['ms932', 'shift_jis'],\n  ['ms_kanji', 'shift_jis'],\n  ['shift-jis', 'shift_jis'],\n  ['shift_jis', 'shift_jis'],\n  ['sjis', 'shift_jis'],\n  ['windows-31j', 'shift_jis'],\n  ['x-sjis', 'shift_jis'],\n  ['cseuckr', 'euc-kr'],\n  ['csksc56011987', 'euc-kr'],\n  ['euc-kr', 'euc-kr'],\n  ['iso-ir-149', 'euc-kr'],\n  ['korean', 'euc-kr'],\n  ['ks_c_5601-1987', 'euc-kr'],\n  ['ks_c_5601-1989', 'euc-kr'],\n  ['ksc5601', 'euc-kr'],\n  ['ksc_5601', 'euc-kr'],\n  ['windows-949', 'euc-kr'],\n  ['utf-16be', 'utf-16be'],\n  ['utf-16le', 'utf-16le'],\n  ['utf-16', 'utf-16le']\n]);\n\n// Unfortunately, String.prototype.trim also removes non-ascii whitespace,\n// so we have to do this manually\nfunction trimAsciiWhitespace(label) {\n  let s = 0;\n  let e = label.length;\n  while (s < e && (\n    label[s] === '\\u0009' ||\n    label[s] === '\\u000a' ||\n    label[s] === '\\u000c' ||\n    label[s] === '\\u000d' ||\n    label[s] === '\\u0020')) {\n    s++;\n  }\n  while (e > s && (\n    label[e - 1] === '\\u0009' ||\n    label[e - 1] === '\\u000a' ||\n    label[e - 1] === '\\u000c' ||\n    label[e - 1] === '\\u000d' ||\n    label[e - 1] === '\\u0020')) {\n    e--;\n  }\n  return label.slice(s, e);\n}\n\nfunction getEncodingFromLabel(label) {\n  const enc = encodings.get(label);\n  if (enc !== undefined) return enc;\n  return encodings.get(trimAsciiWhitespace(label.toLowerCase()));\n}\n\nconst encodeIntoResults = new Uint32Array(2);\n\nclass TextEncoder {\n  constructor() {\n    this[kEncoder] = true;\n  }\n\n  get encoding() {\n    validateEncoder(this);\n    return 'utf-8';\n  }\n\n  encode(input = '') {\n    validateEncoder(this);\n    return encodeUtf8String(`${input}`);\n  }\n\n  encodeInto(src, dest) {\n    validateEncoder(this);\n    validateString(src, 'src');\n    if (!dest || !isUint8Array(dest))\n      throw new ERR_INVALID_ARG_TYPE('dest', 'Uint8Array', dest);\n    encodeInto(src, dest, encodeIntoResults);\n    return { read: encodeIntoResults[0], written: encodeIntoResults[1] };\n  }\n\n  [inspect](depth, opts) {\n    validateEncoder(this);\n    if (typeof depth === 'number' && depth < 0)\n      return this;\n    const ctor = getConstructorOf(this);\n    const obj = ObjectCreate({\n      constructor: ctor === null ? TextEncoder : ctor\n    });\n    obj.encoding = this.encoding;\n    // Lazy to avoid circular dependency\n    return require('internal/util/inspect').inspect(obj, opts);\n  }\n}\n\nObjectDefineProperties(\n  TextEncoder.prototype, {\n    'encode': { enumerable: true },\n    'encodeInto': { enumerable: true },\n    'encoding': { enumerable: true },\n    [SymbolToStringTag]: {\n      configurable: true,\n      value: 'TextEncoder'\n    } });\n\nconst TextDecoder =\n  internalBinding('config').hasIntl ?\n    makeTextDecoderICU() :\n    makeTextDecoderJS();\n\nfunction makeTextDecoderICU() {\n  const {\n    decode: _decode,\n    getConverter,\n  } = internalBinding('icu');\n\n  class TextDecoder {\n    constructor(encoding = 'utf-8', options = {}) {\n      encoding = `${encoding}`;\n      validateArgument(options, 'object', 'options', 'Object');\n\n      const enc = getEncodingFromLabel(encoding);\n      if (enc === undefined)\n        throw new ERR_ENCODING_NOT_SUPPORTED(encoding);\n\n      let flags = 0;\n      if (options !== null) {\n        flags |= options.fatal ? CONVERTER_FLAGS_FATAL : 0;\n        flags |= options.ignoreBOM ? CONVERTER_FLAGS_IGNORE_BOM : 0;\n      }\n\n      const handle = getConverter(enc, flags);\n      if (handle === undefined)\n        throw new ERR_ENCODING_NOT_SUPPORTED(encoding);\n\n      this[kDecoder] = true;\n      this[kHandle] = handle;\n      this[kFlags] = flags;\n      this[kEncoding] = enc;\n    }\n\n\n    decode(input = empty, options = {}) {\n      validateDecoder(this);\n      if (isAnyArrayBuffer(input)) {\n        input = lazyBuffer().from(input);\n      } else if (!isArrayBufferView(input)) {\n        throw new ERR_INVALID_ARG_TYPE('input',\n                                       ['ArrayBuffer', 'ArrayBufferView'],\n                                       input);\n      }\n      validateArgument(options, 'object', 'options', 'Object');\n\n      let flags = 0;\n      if (options !== null)\n        flags |= options.stream ? 0 : CONVERTER_FLAGS_FLUSH;\n\n      const ret = _decode(this[kHandle], input, flags);\n      if (typeof ret === 'number') {\n        throw new ERR_ENCODING_INVALID_ENCODED_DATA(this.encoding, ret);\n      }\n      return ret.toString('ucs2');\n    }\n  }\n\n  return TextDecoder;\n}\n\nfunction makeTextDecoderJS() {\n  let StringDecoder;\n  function lazyStringDecoder() {\n    if (StringDecoder === undefined)\n      ({ StringDecoder } = require('string_decoder'));\n    return StringDecoder;\n  }\n\n  const kBOMSeen = Symbol('BOM seen');\n\n  function hasConverter(encoding) {\n    return encoding === 'utf-8' || encoding === 'utf-16le';\n  }\n\n  class TextDecoder {\n    constructor(encoding = 'utf-8', options = {}) {\n      encoding = `${encoding}`;\n      validateArgument(options, 'object', 'options', 'Object');\n\n      const enc = getEncodingFromLabel(encoding);\n      if (enc === undefined || !hasConverter(enc))\n        throw new ERR_ENCODING_NOT_SUPPORTED(encoding);\n\n      let flags = 0;\n      if (options !== null) {\n        if (options.fatal) {\n          throw new ERR_NO_ICU('\"fatal\" option');\n        }\n        flags |= options.ignoreBOM ? CONVERTER_FLAGS_IGNORE_BOM : 0;\n      }\n\n      this[kDecoder] = true;\n      // StringDecoder will normalize WHATWG encoding to Node.js encoding.\n      this[kHandle] = new (lazyStringDecoder())(enc);\n      this[kFlags] = flags;\n      this[kEncoding] = enc;\n      this[kBOMSeen] = false;\n    }\n\n    decode(input = empty, options = {}) {\n      validateDecoder(this);\n      if (isAnyArrayBuffer(input)) {\n        input = lazyBuffer().from(input);\n      } else if (isArrayBufferView(input)) {\n        input = lazyBuffer().from(input.buffer, input.byteOffset,\n                                  input.byteLength);\n      } else {\n        throw new ERR_INVALID_ARG_TYPE('input',\n                                       ['ArrayBuffer', 'ArrayBufferView'],\n                                       input);\n      }\n      validateArgument(options, 'object', 'options', 'Object');\n\n      if (this[kFlags] & CONVERTER_FLAGS_FLUSH) {\n        this[kBOMSeen] = false;\n      }\n\n      if (options !== null && options.stream) {\n        this[kFlags] &= ~CONVERTER_FLAGS_FLUSH;\n      } else {\n        this[kFlags] |= CONVERTER_FLAGS_FLUSH;\n      }\n\n      let result = this[kFlags] & CONVERTER_FLAGS_FLUSH ?\n        this[kHandle].end(input) :\n        this[kHandle].write(input);\n\n      if (result.length > 0 &&\n          !this[kBOMSeen] &&\n          !(this[kFlags] & CONVERTER_FLAGS_IGNORE_BOM)) {\n        // If the very first result in the stream is a BOM, and we are not\n        // explicitly told to ignore it, then we discard it.\n        if (result[0] === '\\ufeff') {\n          result = result.slice(1);\n        }\n        this[kBOMSeen] = true;\n      }\n\n      return result;\n    }\n  }\n\n  return TextDecoder;\n}\n\n// Mix in some shared properties.\nObjectDefineProperties(\n  TextDecoder.prototype,\n  ObjectGetOwnPropertyDescriptors({\n    get encoding() {\n      validateDecoder(this);\n      return this[kEncoding];\n    },\n\n    get fatal() {\n      validateDecoder(this);\n      return (this[kFlags] & CONVERTER_FLAGS_FATAL) === CONVERTER_FLAGS_FATAL;\n    },\n\n    get ignoreBOM() {\n      validateDecoder(this);\n      return (this[kFlags] & CONVERTER_FLAGS_IGNORE_BOM) ===\n              CONVERTER_FLAGS_IGNORE_BOM;\n    },\n\n    [inspect](depth, opts) {\n      validateDecoder(this);\n      if (typeof depth === 'number' && depth < 0)\n        return this;\n      const constructor = getConstructorOf(this) || TextDecoder;\n      const obj = ObjectCreate({ constructor });\n      obj.encoding = this.encoding;\n      obj.fatal = this.fatal;\n      obj.ignoreBOM = this.ignoreBOM;\n      if (opts.showHidden) {\n        obj[kFlags] = this[kFlags];\n        obj[kHandle] = this[kHandle];\n      }\n      // Lazy to avoid circular dependency\n      const { inspect } = require('internal/util/inspect');\n      return `${constructor.name} ${inspect(obj)}`;\n    }\n  })\n);\n\nObjectDefineProperties(TextDecoder.prototype, {\n  decode: { enumerable: true },\n  [inspect]: { enumerable: false },\n  [SymbolToStringTag]: {\n    configurable: true,\n    value: 'TextDecoder'\n  }\n});\n\nmodule.exports = {\n  getEncodingFromLabel,\n  TextDecoder,\n  TextEncoder\n};\n"
  },
  {
    "url": "internal/errors.js",
    "ranges": [
      {
        "start": 0,
        "end": 1404
      },
      {
        "start": 2120,
        "end": 2162
      },
      {
        "start": 2869,
        "end": 2959
      },
      {
        "start": 3085,
        "end": 3119
      },
      {
        "start": 3281,
        "end": 3295
      },
      {
        "start": 3404,
        "end": 3906
      },
      {
        "start": 6444,
        "end": 6448
      },
      {
        "start": 6523,
        "end": 6527
      },
      {
        "start": 6716,
        "end": 6811
      },
      {
        "start": 6858,
        "end": 6955
      },
      {
        "start": 7536,
        "end": 7542
      },
      {
        "start": 7615,
        "end": 7734
      },
      {
        "start": 8102,
        "end": 8107
      },
      {
        "start": 8723,
        "end": 9345
      },
      {
        "start": 10149,
        "end": 10167
      },
      {
        "start": 10271,
        "end": 10328
      },
      {
        "start": 10498,
        "end": 10791
      },
      {
        "start": 11988,
        "end": 12301
      },
      {
        "start": 13207,
        "end": 13386
      },
      {
        "start": 14092,
        "end": 14445
      },
      {
        "start": 15662,
        "end": 15826
      },
      {
        "start": 17342,
        "end": 17344
      },
      {
        "start": 17499,
        "end": 17789
      },
      {
        "start": 18167,
        "end": 18248
      },
      {
        "start": 18484,
        "end": 18763
      },
      {
        "start": 19154,
        "end": 19158
      },
      {
        "start": 20496,
        "end": 22263
      },
      {
        "start": 22427,
        "end": 25266
      },
      {
        "start": 25381,
        "end": 25670
      },
      {
        "start": 25764,
        "end": 28045
      },
      {
        "start": 28273,
        "end": 30006
      },
      {
        "start": 30224,
        "end": 31974
      },
      {
        "start": 32274,
        "end": 32316
      },
      {
        "start": 32460,
        "end": 32503
      },
      {
        "start": 35708,
        "end": 35749
      },
      {
        "start": 36005,
        "end": 36397
      },
      {
        "start": 36560,
        "end": 37222
      },
      {
        "start": 37357,
        "end": 37398
      },
      {
        "start": 37722,
        "end": 37881
      },
      {
        "start": 38029,
        "end": 38073
      },
      {
        "start": 38847,
        "end": 39225
      },
      {
        "start": 39389,
        "end": 39442
      },
      {
        "start": 39773,
        "end": 39817
      },
      {
        "start": 40124,
        "end": 40494
      },
      {
        "start": 40569,
        "end": 40613
      },
      {
        "start": 40901,
        "end": 41229
      },
      {
        "start": 41660,
        "end": 42336
      },
      {
        "start": 42859,
        "end": 42953
      },
      {
        "start": 43054,
        "end": 43756
      },
      {
        "start": 44454,
        "end": 44505
      },
      {
        "start": 44697,
        "end": 44746
      },
      {
        "start": 45062,
        "end": 45095
      },
      {
        "start": 45972,
        "end": 46424
      },
      {
        "start": 46683,
        "end": 48033
      },
      {
        "start": 48202,
        "end": 50100
      },
      {
        "start": 50231,
        "end": 50824
      },
      {
        "start": 51107,
        "end": 52087
      },
      {
        "start": 52185,
        "end": 52379
      },
      {
        "start": 52734,
        "end": 53129
      }
    ],
    "text": "/* eslint node-core/documented-errors: \"error\" */\n/* eslint node-core/alphabetize-errors: \"error\" */\n/* eslint node-core/prefer-util-format-errors: \"error\" */\n\n'use strict';\n\n// The whole point behind this internal module is to allow Node.js to no\n// longer be forced to treat every error message change as a semver-major\n// change. The NodeError classes here all expose a `code` property whose\n// value statically and permanently identifies the error. While the error\n// message may change, the code should not.\n\nconst {\n  ArrayIsArray,\n  Error,\n  ErrorCaptureStackTrace,\n  ErrorPrototypeToString,\n  JSONStringify,\n  Map,\n  MathAbs,\n  MathMax,\n  NumberIsInteger,\n  ObjectDefineProperty,\n  ObjectKeys,\n  RangeError,\n  String,\n  StringPrototypeStartsWith,\n  Symbol,\n  SymbolFor,\n  SyntaxError,\n  TypeError,\n  URIError,\n  WeakMap,\n} = primordials;\n\nconst isWindows = process.platform === 'win32';\n\nconst messages = new Map();\nconst codes = {};\n\nconst classRegExp = /^([A-Z][a-z0-9]*)+$/;\n// Sorted by a rough estimate on most frequently used entries.\nconst kTypes = [\n  'string',\n  'function',\n  'number',\n  'object',\n  // Accept 'Function' and 'Object' as alternative to the lower cased version.\n  'Function',\n  'Object',\n  'boolean',\n  'bigint',\n  'symbol'\n];\n\nconst MainContextError = Error;\nconst overrideStackTrace = new WeakMap();\nconst kNoOverride = Symbol('kNoOverride');\nconst prepareStackTrace = (globalThis, error, trace) => {\n  // API for node internals to override error stack formatting\n  // without interfering with userland code.\n  if (overrideStackTrace.has(error)) {\n    const f = overrideStackTrace.get(error);\n    overrideStackTrace.delete(error);\n    return f(error, trace);\n  }\n\n  const globalOverride =\n    maybeOverridePrepareStackTrace(globalThis, error, trace);\n  if (globalOverride !== kNoOverride) return globalOverride;\n\n  // Normal error formatting:\n  //\n  // Error: Message\n  //     at function (file)\n  //     at file\n  const errorString = ErrorPrototypeToString(error);\n  if (trace.length === 0) {\n    return errorString;\n  }\n  return `${errorString}\\n    at ${trace.join('\\n    at ')}`;\n};\n\nconst maybeOverridePrepareStackTrace = (globalThis, error, trace) => {\n  // Polyfill of V8's Error.prepareStackTrace API.\n  // https://crbug.com/v8/7848\n  // `globalThis` is the global that contains the constructor which\n  // created `error`.\n  if (typeof globalThis.Error?.prepareStackTrace === 'function') {\n    return globalThis.Error.prepareStackTrace(error, trace);\n  }\n  // We still have legacy usage that depends on the main context's `Error`\n  // being used, even when the error is from a different context.\n  // TODO(devsnek): evaluate if this can be eventually deprecated/removed.\n  if (typeof MainContextError.prepareStackTrace === 'function') {\n    return MainContextError.prepareStackTrace(error, trace);\n  }\n\n  return kNoOverride;\n};\n\nlet excludedStackFn;\n\n// Lazily loaded\nlet util;\nlet assert;\n\nlet internalUtil = null;\nfunction lazyInternalUtil() {\n  if (!internalUtil) {\n    internalUtil = require('internal/util');\n  }\n  return internalUtil;\n}\n\nlet internalUtilInspect = null;\nfunction lazyInternalUtilInspect() {\n  if (!internalUtilInspect) {\n    internalUtilInspect = require('internal/util/inspect');\n  }\n  return internalUtilInspect;\n}\n\nlet buffer;\nfunction lazyBuffer() {\n  if (buffer === undefined)\n    buffer = require('buffer').Buffer;\n  return buffer;\n}\n\n// A specialized Error that includes an additional info property with\n// additional information about the error condition.\n// It has the properties present in a UVException but with a custom error\n// message followed by the uv error code and uv error message.\n// It also has its own error code with the original uv error context put into\n// `err.info`.\n// The context passed into this error must have .code, .syscall and .message,\n// and may have .path and .dest.\nclass SystemError extends Error {\n  constructor(key, context) {\n    if (excludedStackFn === undefined) {\n      super();\n    } else {\n      const limit = Error.stackTraceLimit;\n      Error.stackTraceLimit = 0;\n      super();\n      // Reset the limit and setting the name property.\n      Error.stackTraceLimit = limit;\n    }\n    const prefix = getMessage(key, [], this);\n    let message = `${prefix}: ${context.syscall} returned ` +\n                  `${context.code} (${context.message})`;\n\n    if (context.path !== undefined)\n      message += ` ${context.path}`;\n    if (context.dest !== undefined)\n      message += ` => ${context.dest}`;\n\n    ObjectDefineProperty(this, 'message', {\n      value: message,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    });\n    addCodeToName(this, 'SystemError', key);\n\n    this.code = key;\n\n    ObjectDefineProperty(this, 'info', {\n      value: context,\n      enumerable: true,\n      configurable: true,\n      writable: false\n    });\n\n    ObjectDefineProperty(this, 'errno', {\n      get() {\n        return context.errno;\n      },\n      set: (value) => {\n        context.errno = value;\n      },\n      enumerable: true,\n      configurable: true\n    });\n\n    ObjectDefineProperty(this, 'syscall', {\n      get() {\n        return context.syscall;\n      },\n      set: (value) => {\n        context.syscall = value;\n      },\n      enumerable: true,\n      configurable: true\n    });\n\n    if (context.path !== undefined) {\n      // TODO(BridgeAR): Investigate why and when the `.toString()` was\n      // introduced. The `path` and `dest` properties in the context seem to\n      // always be of type string. We should probably just remove the\n      // `.toString()` and `Buffer.from()` operations and set the value on the\n      // context as the user did.\n      ObjectDefineProperty(this, 'path', {\n        get() {\n          return context.path != null ?\n            context.path.toString() : context.path;\n        },\n        set: (value) => {\n          context.path = value ?\n            lazyBuffer().from(value.toString()) : undefined;\n        },\n        enumerable: true,\n        configurable: true\n      });\n    }\n\n    if (context.dest !== undefined) {\n      ObjectDefineProperty(this, 'dest', {\n        get() {\n          return context.dest != null ?\n            context.dest.toString() : context.dest;\n        },\n        set: (value) => {\n          context.dest = value ?\n            lazyBuffer().from(value.toString()) : undefined;\n        },\n        enumerable: true,\n        configurable: true\n      });\n    }\n  }\n\n  toString() {\n    return `${this.name} [${this.code}]: ${this.message}`;\n  }\n\n  [SymbolFor('nodejs.util.inspect.custom')](recurseTimes, ctx) {\n    return lazyInternalUtilInspect().inspect(this, {\n      ...ctx,\n      getters: true,\n      customInspect: false\n    });\n  }\n}\n\nfunction makeSystemErrorWithCode(key) {\n  return class NodeError extends SystemError {\n    constructor(ctx) {\n      super(key, ctx);\n    }\n  };\n}\n\nfunction makeNodeErrorWithCode(Base, key) {\n  return class NodeError extends Base {\n    constructor(...args) {\n      if (excludedStackFn === undefined) {\n        super();\n      } else {\n        const limit = Error.stackTraceLimit;\n        Error.stackTraceLimit = 0;\n        super();\n        // Reset the limit and setting the name property.\n        Error.stackTraceLimit = limit;\n      }\n      const message = getMessage(key, args, this);\n      ObjectDefineProperty(this, 'message', {\n        value: message,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      });\n      addCodeToName(this, super.name, key);\n      this.code = key;\n    }\n\n    toString() {\n      return `${this.name} [${key}]: ${this.message}`;\n    }\n  };\n}\n\n// This function removes unnecessary frames from Node.js core errors.\nfunction hideStackFrames(fn) {\n  return function hidden(...args) {\n    // Make sure the most outer `hideStackFrames()` function is used.\n    let setStackFn = false;\n    if (excludedStackFn === undefined) {\n      excludedStackFn = hidden;\n      setStackFn = true;\n    }\n    try {\n      return fn(...args);\n    } finally {\n      if (setStackFn === true) {\n        excludedStackFn = undefined;\n      }\n    }\n  };\n}\n\nfunction addCodeToName(err, name, code) {\n  // Set the stack\n  if (excludedStackFn !== undefined) {\n    ErrorCaptureStackTrace(err, excludedStackFn);\n  }\n  // Add the error code to the name to include it in the stack trace.\n  err.name = `${name} [${code}]`;\n  // Access the stack to generate the error message including the error code\n  // from the name.\n  err.stack;\n  // Reset the name to the actual name.\n  if (name === 'SystemError') {\n    ObjectDefineProperty(err, 'name', {\n      value: name,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    });\n  } else {\n    delete err.name;\n  }\n}\n\n// Utility function for registering the error codes. Only used here. Exported\n// *only* to allow for testing.\nfunction E(sym, val, def, ...otherClasses) {\n  // Special case for SystemError that formats the error message differently\n  // The SystemErrors only have SystemError as their base classes.\n  messages.set(sym, val);\n  if (def === SystemError) {\n    def = makeSystemErrorWithCode(sym);\n  } else {\n    def = makeNodeErrorWithCode(def, sym);\n  }\n\n  if (otherClasses.length !== 0) {\n    otherClasses.forEach((clazz) => {\n      def[clazz.name] = makeNodeErrorWithCode(clazz, sym);\n    });\n  }\n  codes[sym] = def;\n}\n\nfunction getMessage(key, args, self) {\n  const msg = messages.get(key);\n\n  if (assert === undefined) assert = require('internal/assert');\n\n  if (typeof msg === 'function') {\n    assert(\n      msg.length <= args.length, // Default options do not count.\n      `Code: ${key}; The provided arguments length (${args.length}) does not ` +\n        `match the required ones (${msg.length}).`\n    );\n    return msg.apply(self, args);\n  }\n\n  const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;\n  assert(\n    expectedLength === args.length,\n    `Code: ${key}; The provided arguments length (${args.length}) does not ` +\n      `match the required ones (${expectedLength}).`\n  );\n  if (args.length === 0)\n    return msg;\n\n  args.unshift(msg);\n  return lazyInternalUtilInspect().format.apply(null, args);\n}\n\nlet uvBinding;\n\nfunction lazyUv() {\n  if (!uvBinding) {\n    uvBinding = internalBinding('uv');\n  }\n  return uvBinding;\n}\n\nconst uvUnmappedError = ['UNKNOWN', 'unknown error'];\n\nfunction uvErrmapGet(name) {\n  uvBinding = lazyUv();\n  if (!uvBinding.errmap) {\n    uvBinding.errmap = uvBinding.getErrorMap();\n  }\n  return uvBinding.errmap.get(name);\n}\n\n\n/**\n * This creates an error compatible with errors produced in the C++\n * function UVException using a context object with data assembled in C++.\n * The goal is to migrate them to ERR_* errors later when compatibility is\n * not a concern.\n *\n * @param {Object} ctx\n * @returns {Error}\n */\nfunction uvException(ctx) {\n  const [ code, uvmsg ] = uvErrmapGet(ctx.errno) || uvUnmappedError;\n  let message = `${code}: ${ctx.message || uvmsg}, ${ctx.syscall}`;\n\n  let path;\n  let dest;\n  if (ctx.path) {\n    path = ctx.path.toString();\n    message += ` '${path}'`;\n  }\n  if (ctx.dest) {\n    dest = ctx.dest.toString();\n    message += ` -> '${dest}'`;\n  }\n\n  // Reducing the limit improves the performance significantly. We do not loose\n  // the stack frames due to the `captureStackTrace()` function that is called\n  // later.\n  const tmpLimit = Error.stackTraceLimit;\n  Error.stackTraceLimit = 0;\n  // Pass the message to the constructor instead of setting it on the object\n  // to make sure it is the same as the one created in C++\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(message);\n  Error.stackTraceLimit = tmpLimit;\n\n  for (const prop of ObjectKeys(ctx)) {\n    if (prop === 'message' || prop === 'path' || prop === 'dest') {\n      continue;\n    }\n    err[prop] = ctx[prop];\n  }\n\n  err.code = code;\n  if (path) {\n    err.path = path;\n  }\n  if (dest) {\n    err.dest = dest;\n  }\n  ErrorCaptureStackTrace(err, excludedStackFn || uvException);\n  return err;\n}\n\n/**\n * This creates an error compatible with errors produced in the C++\n * This function should replace the deprecated\n * `exceptionWithHostPort()` function.\n *\n * @param {number} err - A libuv error number\n * @param {string} syscall\n * @param {string} address\n * @param {number} [port]\n * @returns {Error}\n */\nfunction uvExceptionWithHostPort(err, syscall, address, port) {\n  const [ code, uvmsg ] = uvErrmapGet(err) || uvUnmappedError;\n  const message = `${syscall} ${code}: ${uvmsg}`;\n  let details = '';\n\n  if (port && port > 0) {\n    details = ` ${address}:${port}`;\n  } else if (address) {\n    details = ` ${address}`;\n  }\n\n  // Reducing the limit improves the performance significantly. We do not loose\n  // the stack frames due to the `captureStackTrace()` function that is called\n  // later.\n  const tmpLimit = Error.stackTraceLimit;\n  Error.stackTraceLimit = 0;\n  // eslint-disable-next-line no-restricted-syntax\n  const ex = new Error(`${message}${details}`);\n  Error.stackTraceLimit = tmpLimit;\n  ex.code = code;\n  ex.errno = err;\n  ex.syscall = syscall;\n  ex.address = address;\n  if (port) {\n    ex.port = port;\n  }\n  ErrorCaptureStackTrace(ex, excludedStackFn || uvExceptionWithHostPort);\n  return ex;\n}\n\n/**\n * This used to be util._errnoException().\n *\n * @param {number} err - A libuv error number\n * @param {string} syscall\n * @param {string} [original]\n * @returns {Error}\n */\nfunction errnoException(err, syscall, original) {\n  // TODO(joyeecheung): We have to use the type-checked\n  // getSystemErrorName(err) to guard against invalid arguments from users.\n  // This can be replaced with [ code ] = errmap.get(err) when this method\n  // is no longer exposed to user land.\n  if (util === undefined) util = require('util');\n  const code = util.getSystemErrorName(err);\n  const message = original ?\n    `${syscall} ${code} ${original}` : `${syscall} ${code}`;\n\n  // eslint-disable-next-line no-restricted-syntax\n  const ex = new Error(message);\n  ex.errno = err;\n  ex.code = code;\n  ex.syscall = syscall;\n  ErrorCaptureStackTrace(ex, excludedStackFn || errnoException);\n  return ex;\n}\n\n/**\n * Deprecated, new function is `uvExceptionWithHostPort()`\n * New function added the error description directly\n * from C++. this method for backwards compatibility\n * @param {number} err - A libuv error number\n * @param {string} syscall\n * @param {string} address\n * @param {number} [port]\n * @param {string} [additional]\n * @returns {Error}\n */\nfunction exceptionWithHostPort(err, syscall, address, port, additional) {\n  // TODO(joyeecheung): We have to use the type-checked\n  // getSystemErrorName(err) to guard against invalid arguments from users.\n  // This can be replaced with [ code ] = errmap.get(err) when this method\n  // is no longer exposed to user land.\n  if (util === undefined) util = require('util');\n  const code = util.getSystemErrorName(err);\n  let details = '';\n  if (port && port > 0) {\n    details = ` ${address}:${port}`;\n  } else if (address) {\n    details = ` ${address}`;\n  }\n  if (additional) {\n    details += ` - Local (${additional})`;\n  }\n\n  // Reducing the limit improves the performance significantly. We do not loose\n  // the stack frames due to the `captureStackTrace()` function that is called\n  // later.\n  const tmpLimit = Error.stackTraceLimit;\n  Error.stackTraceLimit = 0;\n  // eslint-disable-next-line no-restricted-syntax\n  const ex = new Error(`${syscall} ${code}${details}`);\n  Error.stackTraceLimit = tmpLimit;\n  ex.errno = err;\n  ex.code = code;\n  ex.syscall = syscall;\n  ex.address = address;\n  if (port) {\n    ex.port = port;\n  }\n  ErrorCaptureStackTrace(ex, excludedStackFn || exceptionWithHostPort);\n  return ex;\n}\n\n/**\n * @param {number|string} code - A libuv error number or a c-ares error code\n * @param {string} syscall\n * @param {string} [hostname]\n * @returns {Error}\n */\nfunction dnsException(code, syscall, hostname) {\n  let errno;\n  // If `code` is of type number, it is a libuv error number, else it is a\n  // c-ares error code.\n  // TODO(joyeecheung): translate c-ares error codes into numeric ones and\n  // make them available in a property that's not error.errno (since they\n  // can be in conflict with libuv error codes). Also make sure\n  // util.getSystemErrorName() can understand them when an being informed that\n  // the number is a c-ares error code.\n  if (typeof code === 'number') {\n    errno = code;\n    // ENOTFOUND is not a proper POSIX error, but this error has been in place\n    // long enough that it's not practical to remove it.\n    if (code === lazyUv().UV_EAI_NODATA || code === lazyUv().UV_EAI_NONAME) {\n      code = 'ENOTFOUND'; // Fabricated error name.\n    } else {\n      code = lazyInternalUtil().getSystemErrorName(code);\n    }\n  }\n  const message = `${syscall} ${code}${hostname ? ` ${hostname}` : ''}`;\n  // Reducing the limit improves the performance significantly. We do not loose\n  // the stack frames due to the `captureStackTrace()` function that is called\n  // later.\n  const tmpLimit = Error.stackTraceLimit;\n  Error.stackTraceLimit = 0;\n  // eslint-disable-next-line no-restricted-syntax\n  const ex = new Error(message);\n  Error.stackTraceLimit = tmpLimit;\n  ex.errno = errno;\n  ex.code = code;\n  ex.syscall = syscall;\n  if (hostname) {\n    ex.hostname = hostname;\n  }\n  ErrorCaptureStackTrace(ex, excludedStackFn || dnsException);\n  return ex;\n}\n\nfunction connResetException(msg) {\n  // eslint-disable-next-line no-restricted-syntax\n  const ex = new Error(msg);\n  ex.code = 'ECONNRESET';\n  return ex;\n}\n\nlet maxStack_ErrorName;\nlet maxStack_ErrorMessage;\n/**\n * Returns true if `err.name` and `err.message` are equal to engine-specific\n * values indicating max call stack size has been exceeded.\n * \"Maximum call stack size exceeded\" in V8.\n *\n * @param {Error} err\n * @returns {boolean}\n */\nfunction isStackOverflowError(err) {\n  if (maxStack_ErrorMessage === undefined) {\n    try {\n      function overflowStack() { overflowStack(); }\n      overflowStack();\n    } catch (err) {\n      maxStack_ErrorMessage = err.message;\n      maxStack_ErrorName = err.name;\n    }\n  }\n\n  return err && err.name === maxStack_ErrorName &&\n         err.message === maxStack_ErrorMessage;\n}\n\n// Only use this for integers! Decimal numbers do not work with this function.\nfunction addNumericalSeparator(val) {\n  let res = '';\n  let i = val.length;\n  const start = val[0] === '-' ? 1 : 0;\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`;\n  }\n  return `${val.slice(0, i)}${res}`;\n}\n\n// Used to enhance the stack that will be picked up by the inspector\nconst kEnhanceStackBeforeInspector = Symbol('kEnhanceStackBeforeInspector');\n\n// These are supposed to be called only on fatal exceptions before\n// the process exits.\nconst fatalExceptionStackEnhancers = {\n  beforeInspector(error) {\n    if (typeof error[kEnhanceStackBeforeInspector] !== 'function') {\n      return error.stack;\n    }\n\n    try {\n      // Set the error.stack here so it gets picked up by the\n      // inspector.\n      error.stack = error[kEnhanceStackBeforeInspector]();\n    } catch {\n      // We are just enhancing the error. If it fails, ignore it.\n    }\n    return error.stack;\n  },\n  afterInspector(error) {\n    const originalStack = error.stack;\n    let useColors = true;\n    // Some consoles do not convert ANSI escape sequences to colors,\n    // rather display them directly to the stdout. On those consoles,\n    // libuv emulates colors by intercepting stdout stream and calling\n    // corresponding Windows API functions for setting console colors.\n    // However, fatal error are handled differently and we cannot easily\n    // highlight them. On Windows, detecting whether a console supports\n    // ANSI escape sequences is not reliable.\n    if (process.platform === 'win32') {\n      const info = internalBinding('os').getOSInformation();\n      const ver = info[2].split('.').map((a) => +a);\n      if (ver[0] !== 10 || ver[2] < 14393) {\n        useColors = false;\n      }\n    }\n    const {\n      inspect,\n      inspectDefaultOptions: {\n        colors: defaultColors\n      }\n    } = lazyInternalUtilInspect();\n    const colors = useColors &&\n                   ((internalBinding('util').guessHandleType(2) === 'TTY' &&\n                   require('internal/tty').hasColors()) ||\n                   defaultColors);\n    try {\n      return inspect(error, {\n        colors,\n        customInspect: false,\n        depth: MathMax(inspect.defaultOptions.depth, 5)\n      });\n    } catch {\n      return originalStack;\n    }\n  }\n};\n\nmodule.exports = {\n  addCodeToName, // Exported for NghttpError\n  codes,\n  dnsException,\n  errnoException,\n  exceptionWithHostPort,\n  getMessage,\n  hideStackFrames,\n  isStackOverflowError,\n  connResetException,\n  uvErrmapGet,\n  uvException,\n  uvExceptionWithHostPort,\n  SystemError,\n  // This is exported only to facilitate testing.\n  E,\n  kNoOverride,\n  prepareStackTrace,\n  maybeOverridePrepareStackTrace,\n  overrideStackTrace,\n  kEnhanceStackBeforeInspector,\n  fatalExceptionStackEnhancers\n};\n\n// To declare an error message, use the E(sym, val, def) function above. The sym\n// must be an upper case string. The val can be either a function or a string.\n// The def must be an error class.\n// The return value of the function must be a string.\n// Examples:\n// E('EXAMPLE_KEY1', 'This is the error value', Error);\n// E('EXAMPLE_KEY2', (a, b) => return `${a} ${b}`, RangeError);\n//\n// Once an error code has been assigned, the code itself MUST NOT change and\n// any given error code must never be reused to identify a different error.\n//\n// Any error code added here should also be added to the documentation\n//\n// Note: Please try to keep these in alphabetical order\n//\n// Note: Node.js specific errors must begin with the prefix ERR_\nE('ERR_AMBIGUOUS_ARGUMENT', 'The \"%s\" argument is ambiguous. %s', TypeError);\nE('ERR_ARG_NOT_ITERABLE', '%s must be iterable', TypeError);\nE('ERR_ASSERTION', '%s', Error);\nE('ERR_ASYNC_CALLBACK', '%s must be a function', TypeError);\nE('ERR_ASYNC_TYPE', 'Invalid name for async \"type\": %s', TypeError);\nE('ERR_BROTLI_INVALID_PARAM', '%s is not a valid Brotli parameter', RangeError);\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  // Using a default argument here is important so the argument is not counted\n  // towards `Function#length`.\n  (name = undefined) => {\n    if (name) {\n      return `\"${name}\" is outside of buffer bounds`;\n    }\n    return 'Attempt to access memory outside buffer bounds';\n  }, RangeError);\nE('ERR_BUFFER_TOO_LARGE',\n  'Cannot create a Buffer larger than %s bytes',\n  RangeError);\nE('ERR_CANNOT_WATCH_SIGINT', 'Cannot watch for SIGINT signals', Error);\nE('ERR_CHILD_CLOSED_BEFORE_REPLY',\n  'Child closed before reply received', Error);\nE('ERR_CHILD_PROCESS_IPC_REQUIRED',\n  \"Forked processes must have an IPC channel, missing value 'ipc' in %s\",\n  Error);\nE('ERR_CHILD_PROCESS_STDIO_MAXBUFFER', '%s maxBuffer length exceeded',\n  RangeError);\nE('ERR_CONSOLE_WRITABLE_STREAM',\n  'Console expects a writable stream instance for %s', TypeError);\nE('ERR_CONTEXT_NOT_INITIALIZED', 'context used is not initialized', Error);\nE('ERR_CPU_USAGE', 'Unable to obtain cpu usage %s', Error);\nE('ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED',\n  'Custom engines not supported by this OpenSSL', Error);\nE('ERR_CRYPTO_ECDH_INVALID_FORMAT', 'Invalid ECDH format: %s', TypeError);\nE('ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY',\n  'Public key is not valid for specified curve', Error);\nE('ERR_CRYPTO_ENGINE_UNKNOWN', 'Engine \"%s\" was not found', Error);\nE('ERR_CRYPTO_FIPS_FORCED',\n  'Cannot set FIPS mode, it was forced with --force-fips at startup.', Error);\nE('ERR_CRYPTO_FIPS_UNAVAILABLE', 'Cannot set FIPS mode in a non-FIPS build.',\n  Error);\nE('ERR_CRYPTO_HASH_FINALIZED', 'Digest already called', Error);\nE('ERR_CRYPTO_HASH_UPDATE_FAILED', 'Hash update failed', Error);\nE('ERR_CRYPTO_INCOMPATIBLE_KEY', 'Incompatible %s: %s', Error);\nE('ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS', 'The selected key encoding %s %s.',\n  Error);\nE('ERR_CRYPTO_INVALID_DIGEST', 'Invalid digest: %s', TypeError);\nE('ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE',\n  'Invalid key object type %s, expected %s.', TypeError);\nE('ERR_CRYPTO_INVALID_STATE', 'Invalid state for operation %s', Error);\nE('ERR_CRYPTO_PBKDF2_ERROR', 'PBKDF2 error', Error);\nE('ERR_CRYPTO_SCRYPT_INVALID_PARAMETER', 'Invalid scrypt parameter', Error);\nE('ERR_CRYPTO_SCRYPT_NOT_SUPPORTED', 'Scrypt algorithm not supported', Error);\n// Switch to TypeError. The current implementation does not seem right.\nE('ERR_CRYPTO_SIGN_KEY_REQUIRED', 'No key provided to sign', Error);\nE('ERR_DIR_CLOSED', 'Directory handle was closed', Error);\nE('ERR_DIR_CONCURRENT_OPERATION',\n  'Cannot do synchronous work on directory handle with concurrent ' +\n  'asynchronous operations', Error);\nE('ERR_DNS_SET_SERVERS_FAILED', 'c-ares failed to set servers: \"%s\" [%s]',\n  Error);\nE('ERR_DOMAIN_CALLBACK_NOT_AVAILABLE',\n  'A callback was registered through ' +\n     'process.setUncaughtExceptionCaptureCallback(), which is mutually ' +\n     'exclusive with using the `domain` module',\n  Error);\nE('ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE',\n  'The `domain` module is in use, which is mutually exclusive with calling ' +\n     'process.setUncaughtExceptionCaptureCallback()',\n  Error);\nE('ERR_ENCODING_INVALID_ENCODED_DATA', function(encoding, ret) {\n  this.errno = ret;\n  return `The encoded data was not valid for encoding ${encoding}`;\n}, TypeError);\nE('ERR_ENCODING_NOT_SUPPORTED', 'The \"%s\" encoding is not supported',\n  RangeError);\nE('ERR_EVAL_ESM_CANNOT_PRINT', '--print cannot be used with ESM input', Error);\nE('ERR_EVENT_RECURSION', 'The event \"%s\" is already being dispatched', Error);\nE('ERR_FALSY_VALUE_REJECTION', function(reason) {\n  this.reason = reason;\n  return 'Promise was rejected with falsy value';\n}, Error);\nE('ERR_FEATURE_UNAVAILABLE_ON_PLATFORM',\n  'The feature %s is unavailable on the current platform' +\n  ', which is being used to run Node.js',\n  TypeError);\nE('ERR_FS_EISDIR', 'Path is a directory', SystemError);\nE('ERR_FS_FILE_TOO_LARGE', 'File size (%s) is greater than 2 GB', RangeError);\nE('ERR_FS_INVALID_SYMLINK_TYPE',\n  'Symlink type must be one of \"dir\", \"file\", or \"junction\". Received \"%s\"',\n  Error); // Switch to TypeError. The current implementation does not seem right\nE('ERR_HTTP2_ALTSVC_INVALID_ORIGIN',\n  'HTTP/2 ALTSVC frames require a valid origin', TypeError);\nE('ERR_HTTP2_ALTSVC_LENGTH',\n  'HTTP/2 ALTSVC frames are limited to 16382 bytes', TypeError);\nE('ERR_HTTP2_CONNECT_AUTHORITY',\n  ':authority header is required for CONNECT requests', Error);\nE('ERR_HTTP2_CONNECT_PATH',\n  'The :path header is forbidden for CONNECT requests', Error);\nE('ERR_HTTP2_CONNECT_SCHEME',\n  'The :scheme header is forbidden for CONNECT requests', Error);\nE('ERR_HTTP2_GOAWAY_SESSION',\n  'New streams cannot be created after receiving a GOAWAY', Error);\nE('ERR_HTTP2_HEADERS_AFTER_RESPOND',\n  'Cannot specify additional headers after response initiated', Error);\nE('ERR_HTTP2_HEADERS_SENT', 'Response has already been initiated.', Error);\nE('ERR_HTTP2_HEADER_SINGLE_VALUE',\n  'Header field \"%s\" must only have a single value', TypeError);\nE('ERR_HTTP2_INFO_STATUS_NOT_ALLOWED',\n  'Informational status codes cannot be used', RangeError);\nE('ERR_HTTP2_INVALID_CONNECTION_HEADERS',\n  'HTTP/1 Connection specific headers are forbidden: \"%s\"', TypeError);\nE('ERR_HTTP2_INVALID_HEADER_VALUE',\n  'Invalid value \"%s\" for header \"%s\"', TypeError);\nE('ERR_HTTP2_INVALID_INFO_STATUS',\n  'Invalid informational status code: %s', RangeError);\nE('ERR_HTTP2_INVALID_ORIGIN',\n  'HTTP/2 ORIGIN frames require a valid origin', TypeError);\nE('ERR_HTTP2_INVALID_PACKED_SETTINGS_LENGTH',\n  'Packed settings length must be a multiple of six', RangeError);\nE('ERR_HTTP2_INVALID_PSEUDOHEADER',\n  '\"%s\" is an invalid pseudoheader or is used incorrectly', TypeError);\nE('ERR_HTTP2_INVALID_SESSION', 'The session has been destroyed', Error);\nE('ERR_HTTP2_INVALID_SETTING_VALUE',\n  // Using default arguments here is important so the arguments are not counted\n  // towards `Function#length`.\n  function(name, actual, min = undefined, max = undefined) {\n    this.actual = actual;\n    if (min !== undefined) {\n      this.min = min;\n      this.max = max;\n    }\n    return `Invalid value for setting \"${name}\": ${actual}`;\n  }, TypeError, RangeError);\nE('ERR_HTTP2_INVALID_STREAM', 'The stream has been destroyed', Error);\nE('ERR_HTTP2_MAX_PENDING_SETTINGS_ACK',\n  'Maximum number of pending settings acknowledgements', Error);\nE('ERR_HTTP2_NESTED_PUSH',\n  'A push stream cannot initiate another push stream.', Error);\nE('ERR_HTTP2_NO_SOCKET_MANIPULATION',\n  'HTTP/2 sockets should not be directly manipulated (e.g. read and written)',\n  Error);\nE('ERR_HTTP2_ORIGIN_LENGTH',\n  'HTTP/2 ORIGIN frames are limited to 16382 bytes', TypeError);\nE('ERR_HTTP2_OUT_OF_STREAMS',\n  'No stream ID is available because maximum stream ID has been reached',\n  Error);\nE('ERR_HTTP2_PAYLOAD_FORBIDDEN',\n  'Responses with %s status must not have a payload', Error);\nE('ERR_HTTP2_PING_CANCEL', 'HTTP2 ping cancelled', Error);\nE('ERR_HTTP2_PING_LENGTH', 'HTTP2 ping payload must be 8 bytes', RangeError);\nE('ERR_HTTP2_PSEUDOHEADER_NOT_ALLOWED',\n  'Cannot set HTTP/2 pseudo-headers', TypeError);\nE('ERR_HTTP2_PUSH_DISABLED', 'HTTP/2 client has disabled push streams', Error);\nE('ERR_HTTP2_SEND_FILE', 'Directories cannot be sent', Error);\nE('ERR_HTTP2_SEND_FILE_NOSEEK',\n  'Offset or length can only be specified for regular files', Error);\nE('ERR_HTTP2_SESSION_ERROR', 'Session closed with error code %s', Error);\nE('ERR_HTTP2_SETTINGS_CANCEL', 'HTTP2 session settings canceled', Error);\nE('ERR_HTTP2_SOCKET_BOUND',\n  'The socket is already bound to an Http2Session', Error);\nE('ERR_HTTP2_SOCKET_UNBOUND',\n  'The socket has been disconnected from the Http2Session', Error);\nE('ERR_HTTP2_STATUS_101',\n  'HTTP status code 101 (Switching Protocols) is forbidden in HTTP/2', Error);\nE('ERR_HTTP2_STATUS_INVALID', 'Invalid status code: %s', RangeError);\nE('ERR_HTTP2_STREAM_CANCEL', function(error) {\n  let msg = 'The pending stream has been canceled';\n  if (error) {\n    this.cause = error;\n    if (typeof error.message === 'string')\n      msg += ` (caused by: ${error.message})`;\n  }\n  return msg;\n}, Error);\nE('ERR_HTTP2_STREAM_ERROR', 'Stream closed with error code %s', Error);\nE('ERR_HTTP2_STREAM_SELF_DEPENDENCY',\n  'A stream cannot depend on itself', Error);\nE('ERR_HTTP2_TRAILERS_ALREADY_SENT',\n  'Trailing headers have already been sent', Error);\nE('ERR_HTTP2_TRAILERS_NOT_READY',\n  'Trailing headers cannot be sent until after the wantTrailers event is ' +\n  'emitted', Error);\nE('ERR_HTTP2_UNSUPPORTED_PROTOCOL', 'protocol \"%s\" is unsupported.', Error);\nE('ERR_HTTP_HEADERS_SENT',\n  'Cannot %s headers after they are sent to the client', Error);\nE('ERR_HTTP_INVALID_HEADER_VALUE',\n  'Invalid value \"%s\" for header \"%s\"', TypeError);\nE('ERR_HTTP_INVALID_STATUS_CODE', 'Invalid status code: %s', RangeError);\nE('ERR_HTTP_REQUEST_TIMEOUT', 'Request timeout', Error);\nE('ERR_HTTP_TRAILER_INVALID',\n  'Trailers are invalid with this transfer encoding', Error);\nE('ERR_INCOMPATIBLE_OPTION_PAIR',\n  'Option \"%s\" cannot be used in combination with option \"%s\"', TypeError);\nE('ERR_INPUT_TYPE_NOT_ALLOWED', '--input-type can only be used with string ' +\n  'input via --eval, --print, or STDIN', Error);\nE('ERR_INSPECTOR_ALREADY_ACTIVATED',\n  'Inspector is already activated. Close it with inspector.close() ' +\n  'before activating it again.',\n  Error);\nE('ERR_INSPECTOR_ALREADY_CONNECTED', '%s is already connected', Error);\nE('ERR_INSPECTOR_CLOSED', 'Session was closed', Error);\nE('ERR_INSPECTOR_COMMAND', 'Inspector error %d: %s', Error);\nE('ERR_INSPECTOR_NOT_ACTIVE', 'Inspector is not active', Error);\nE('ERR_INSPECTOR_NOT_AVAILABLE', 'Inspector is not available', Error);\nE('ERR_INSPECTOR_NOT_CONNECTED', 'Session is not connected', Error);\nE('ERR_INSPECTOR_NOT_WORKER', 'Current thread is not a worker', Error);\nE('ERR_INTERNAL_ASSERTION', (message) => {\n  const suffix = 'This is caused by either a bug in Node.js ' +\n    'or incorrect usage of Node.js internals.\\n' +\n    'Please open an issue with this stack trace at ' +\n    'https://github.com/nodejs/node/issues\\n';\n  return message === undefined ? suffix : `${message}\\n${suffix}`;\n}, Error);\nE('ERR_INVALID_ADDRESS_FAMILY', function(addressType, host, port) {\n  this.host = host;\n  this.port = port;\n  return `Invalid address family: ${addressType} ${host}:${port}`;\n}, RangeError);\nE('ERR_INVALID_ARG_TYPE',\n  (name, expected, actual) => {\n    assert(typeof name === 'string', \"'name' must be a string\");\n    if (!ArrayIsArray(expected)) {\n      expected = [expected];\n    }\n\n    let msg = 'The ';\n    if (name.endsWith(' argument')) {\n      // For cases like 'first argument'\n      msg += `${name} `;\n    } else {\n      const type = name.includes('.') ? 'property' : 'argument';\n      msg += `\"${name}\" ${type} `;\n    }\n    msg += 'must be ';\n\n    const types = [];\n    const instances = [];\n    const other = [];\n\n    for (const value of expected) {\n      assert(typeof value === 'string',\n             'All expected entries have to be of type string');\n      if (kTypes.includes(value)) {\n        types.push(value.toLowerCase());\n      } else if (classRegExp.test(value)) {\n        instances.push(value);\n      } else {\n        assert(value !== 'object',\n               'The value \"object\" should be written as \"Object\"');\n        other.push(value);\n      }\n    }\n\n    // Special handle `object` in case other instances are allowed to outline\n    // the differences between each other.\n    if (instances.length > 0) {\n      const pos = types.indexOf('object');\n      if (pos !== -1) {\n        types.splice(pos, 1);\n        instances.push('Object');\n      }\n    }\n\n    if (types.length > 0) {\n      if (types.length > 2) {\n        const last = types.pop();\n        msg += `one of type ${types.join(', ')}, or ${last}`;\n      } else if (types.length === 2) {\n        msg += `one of type ${types[0]} or ${types[1]}`;\n      } else {\n        msg += `of type ${types[0]}`;\n      }\n      if (instances.length > 0 || other.length > 0)\n        msg += ' or ';\n    }\n\n    if (instances.length > 0) {\n      if (instances.length > 2) {\n        const last = instances.pop();\n        msg += `an instance of ${instances.join(', ')}, or ${last}`;\n      } else {\n        msg += `an instance of ${instances[0]}`;\n        if (instances.length === 2) {\n          msg += ` or ${instances[1]}`;\n        }\n      }\n      if (other.length > 0)\n        msg += ' or ';\n    }\n\n    if (other.length > 0) {\n      if (other.length > 2) {\n        const last = other.pop();\n        msg += `one of ${other.join(', ')}, or ${last}`;\n      } else if (other.length === 2) {\n        msg += `one of ${other[0]} or ${other[1]}`;\n      } else {\n        if (other[0].toLowerCase() !== other[0])\n          msg += 'an ';\n        msg += `${other[0]}`;\n      }\n    }\n\n    if (actual == null) {\n      msg += `. Received ${actual}`;\n    } else if (typeof actual === 'function' && actual.name) {\n      msg += `. Received function ${actual.name}`;\n    } else if (typeof actual === 'object') {\n      if (actual.constructor && actual.constructor.name) {\n        msg += `. Received an instance of ${actual.constructor.name}`;\n      } else {\n        const inspected = lazyInternalUtilInspect()\n          .inspect(actual, { depth: -1 });\n        msg += `. Received ${inspected}`;\n      }\n    } else {\n      let inspected = lazyInternalUtilInspect()\n        .inspect(actual, { colors: false });\n      if (inspected.length > 25)\n        inspected = `${inspected.slice(0, 25)}...`;\n      msg += `. Received type ${typeof actual} (${inspected})`;\n    }\n    return msg;\n  }, TypeError);\nE('ERR_INVALID_ARG_VALUE', (name, value, reason = 'is invalid') => {\n  let inspected = lazyInternalUtilInspect().inspect(value);\n  if (inspected.length > 128) {\n    inspected = `${inspected.slice(0, 128)}...`;\n  }\n  return `The argument '${name}' ${reason}. Received ${inspected}`;\n}, TypeError, RangeError);\nE('ERR_INVALID_ASYNC_ID', 'Invalid %s value: %s', RangeError);\nE('ERR_INVALID_BUFFER_SIZE',\n  'Buffer size must be a multiple of %s', RangeError);\nE('ERR_INVALID_CALLBACK',\n  'Callback must be a function. Received %O', TypeError);\nE('ERR_INVALID_CHAR',\n  // Using a default argument here is important so the argument is not counted\n  // towards `Function#length`.\n  (name, field = undefined) => {\n    let msg = `Invalid character in ${name}`;\n    if (field !== undefined) {\n      msg += ` [\"${field}\"]`;\n    }\n    return msg;\n  }, TypeError);\nE('ERR_INVALID_CURSOR_POS',\n  'Cannot set cursor row without setting its column', TypeError);\nE('ERR_INVALID_FD',\n  '\"fd\" must be a positive integer: %s', RangeError);\nE('ERR_INVALID_FD_TYPE', 'Unsupported fd type: %s', TypeError);\nE('ERR_INVALID_FILE_URL_HOST',\n  'File URL host must be \"localhost\" or empty on %s', TypeError);\nE('ERR_INVALID_FILE_URL_PATH', 'File URL path %s', TypeError);\nE('ERR_INVALID_HANDLE_TYPE', 'This handle type cannot be sent', TypeError);\nE('ERR_INVALID_HTTP_TOKEN', '%s must be a valid HTTP token [\"%s\"]', TypeError);\nE('ERR_INVALID_IP_ADDRESS', 'Invalid IP address: %s', TypeError);\nE('ERR_INVALID_MODULE_SPECIFIER', (request, reason, base = undefined) => {\n  return `Invalid module \"${request}\" ${reason}${base ?\n    ` imported from ${base}` : ''}`;\n}, TypeError);\nE('ERR_INVALID_OPT_VALUE', (name, value, reason = '') => {\n  let inspected = typeof value === 'string' ?\n    value : lazyInternalUtilInspect().inspect(value);\n  if (inspected.length > 128) inspected = `${inspected.slice(0, 128)}...`;\n  if (reason) reason = '. ' + reason;\n  return `The value \"${inspected}\" is invalid for option \"${name}\"` + reason;\n}, TypeError, RangeError);\nE('ERR_INVALID_OPT_VALUE_ENCODING',\n  'The value \"%s\" is invalid for option \"encoding\"', TypeError);\nE('ERR_INVALID_PACKAGE_CONFIG', (path, base, message) => {\n  return `Invalid package config ${path}${base ? ` while importing ${base}` :\n    ''}${message ? `. ${message}` : ''}`;\n}, Error);\nE('ERR_INVALID_PACKAGE_TARGET',\n  (pkgPath, key, target, isImport = false, base = undefined) => {\n    const relError = typeof target === 'string' && !isImport &&\n      target.length && !StringPrototypeStartsWith(target, './');\n    if (key === '.') {\n      assert(isImport === false);\n      return `Invalid \"exports\" main target ${JSONStringify(target)} defined ` +\n        `in the package config ${pkgPath}package.json${base ?\n          ` imported from ${base}` : ''}${relError ?\n          '; targets must start with \"./\"' : ''}`;\n    }\n    return `Invalid \"${isImport ? 'imports' : 'exports'}\" target ${\n      JSONStringify(target)} defined for '${key}' in the package config ${\n      pkgPath}package.json${base ? ` imported from ${base}` : ''}${relError ?\n      '; targets must start with \"./\"' : ''}`;\n  }, Error);\nE('ERR_INVALID_PERFORMANCE_MARK',\n  'The \"%s\" performance mark has not been set', Error);\nE('ERR_INVALID_PROTOCOL',\n  'Protocol \"%s\" not supported. Expected \"%s\"',\n  TypeError);\nE('ERR_INVALID_REPL_EVAL_CONFIG',\n  'Cannot specify both \"breakEvalOnSigint\" and \"eval\" for REPL', TypeError);\nE('ERR_INVALID_REPL_INPUT', '%s', TypeError);\nE('ERR_INVALID_RETURN_PROPERTY', (input, name, prop, value) => {\n  return `Expected a valid ${input} to be returned for the \"${prop}\" from the` +\n         ` \"${name}\" function but got ${value}.`;\n}, TypeError);\nE('ERR_INVALID_RETURN_PROPERTY_VALUE', (input, name, prop, value) => {\n  let type;\n  if (value && value.constructor && value.constructor.name) {\n    type = `instance of ${value.constructor.name}`;\n  } else {\n    type = `type ${typeof value}`;\n  }\n  return `Expected ${input} to be returned for the \"${prop}\" from the` +\n         ` \"${name}\" function but got ${type}.`;\n}, TypeError);\nE('ERR_INVALID_RETURN_VALUE', (input, name, value) => {\n  let type;\n  if (value && value.constructor && value.constructor.name) {\n    type = `instance of ${value.constructor.name}`;\n  } else {\n    type = `type ${typeof value}`;\n  }\n  return `Expected ${input} to be returned from the \"${name}\"` +\n         ` function but got ${type}.`;\n}, TypeError);\nE('ERR_INVALID_SYNC_FORK_INPUT',\n  'Asynchronous forks do not support ' +\n    'Buffer, TypedArray, DataView or string input: %s',\n  TypeError);\nE('ERR_INVALID_THIS', 'Value of \"this\" must be of type %s', TypeError);\nE('ERR_INVALID_TUPLE', '%s must be an iterable %s tuple', TypeError);\nE('ERR_INVALID_URI', 'URI malformed', URIError);\nE('ERR_INVALID_URL', function(input) {\n  this.input = input;\n  return `Invalid URL: ${input}`;\n}, TypeError);\nE('ERR_INVALID_URL_SCHEME',\n  (expected) => {\n    if (typeof expected === 'string')\n      expected = [expected];\n    assert(expected.length <= 2);\n    const res = expected.length === 2 ?\n      `one of scheme ${expected[0]} or ${expected[1]}` :\n      `of scheme ${expected[0]}`;\n    return `The URL must be ${res}`;\n  }, TypeError);\nE('ERR_IPC_CHANNEL_CLOSED', 'Channel closed', Error);\nE('ERR_IPC_DISCONNECTED', 'IPC channel is already disconnected', Error);\nE('ERR_IPC_ONE_PIPE', 'Child process can have only one IPC pipe', Error);\nE('ERR_IPC_SYNC_FORK', 'IPC cannot be used with synchronous forks', Error);\nE('ERR_MANIFEST_ASSERT_INTEGRITY',\n  (moduleURL, realIntegrities) => {\n    let msg = `The content of \"${\n      moduleURL\n    }\" does not match the expected integrity.`;\n    if (realIntegrities.size) {\n      const sri = [...realIntegrities.entries()].map(([alg, dgs]) => {\n        return `${alg}-${dgs}`;\n      }).join(' ');\n      msg += ` Integrities found are: ${sri}`;\n    } else {\n      msg += ' The resource was not found in the policy.';\n    }\n    return msg;\n  }, Error);\nE('ERR_MANIFEST_DEPENDENCY_MISSING',\n  'Manifest resource %s does not list %s as a dependency specifier for ' +\n  'conditions: %s',\n  Error);\nE('ERR_MANIFEST_INTEGRITY_MISMATCH',\n  'Manifest resource %s has multiple entries but integrity lists do not match',\n  SyntaxError);\nE('ERR_MANIFEST_INVALID_RESOURCE_FIELD',\n  'Manifest resource %s has invalid property value for %s',\n  TypeError);\nE('ERR_MANIFEST_TDZ', 'Manifest initialization has not yet run', Error);\nE('ERR_MANIFEST_UNKNOWN_ONERROR',\n  'Manifest specified unknown error behavior \"%s\".',\n  SyntaxError);\nE('ERR_METHOD_NOT_IMPLEMENTED', 'The %s method is not implemented', Error);\nE('ERR_MISSING_ARGS',\n  (...args) => {\n    assert(args.length > 0, 'At least one arg needs to be specified');\n    let msg = 'The ';\n    const len = args.length;\n    args = args.map((a) => `\"${a}\"`);\n    switch (len) {\n      case 1:\n        msg += `${args[0]} argument`;\n        break;\n      case 2:\n        msg += `${args[0]} and ${args[1]} arguments`;\n        break;\n      default:\n        msg += args.slice(0, len - 1).join(', ');\n        msg += `, and ${args[len - 1]} arguments`;\n        break;\n    }\n    return `${msg} must be specified`;\n  }, TypeError);\nE('ERR_MISSING_OPTION', '%s is required', TypeError);\nE('ERR_MODULE_NOT_FOUND', (path, base, type = 'package') => {\n  return `Cannot find ${type} '${path}' imported from ${base}`;\n}, Error);\nE('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times', Error);\nE('ERR_NAPI_CONS_FUNCTION', 'Constructor must be a function', TypeError);\nE('ERR_NAPI_INVALID_DATAVIEW_ARGS',\n  'byte_offset + byte_length should be less than or equal to the size in ' +\n    'bytes of the array passed in',\n  RangeError);\nE('ERR_NAPI_INVALID_TYPEDARRAY_ALIGNMENT',\n  'start offset of %s should be a multiple of %s', RangeError);\nE('ERR_NAPI_INVALID_TYPEDARRAY_LENGTH',\n  'Invalid typed array length', RangeError);\nE('ERR_NO_CRYPTO',\n  'Node.js is not compiled with OpenSSL crypto support', Error);\nE('ERR_NO_ICU',\n  '%s is not supported on Node.js compiled without ICU', TypeError);\nE('ERR_OUT_OF_RANGE',\n  (str, range, input, replaceDefaultBoolean = false) => {\n    assert(range, 'Missing \"range\" argument');\n    let msg = replaceDefaultBoolean ? str :\n      `The value of \"${str}\" is out of range.`;\n    let received;\n    if (NumberIsInteger(input) && MathAbs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input));\n    } else if (typeof input === 'bigint') {\n      received = String(input);\n      if (input > 2n ** 32n || input < -(2n ** 32n)) {\n        received = addNumericalSeparator(received);\n      }\n      received += 'n';\n    } else {\n      received = lazyInternalUtilInspect().inspect(input);\n    }\n    msg += ` It must be ${range}. Received ${received}`;\n    return msg;\n  }, RangeError);\nE('ERR_PACKAGE_IMPORT_NOT_DEFINED', (specifier, packagePath, base) => {\n  return `Package import specifier \"${specifier}\" is not defined${packagePath ?\n    ` in package ${packagePath}package.json` : ''} imported from ${base}`;\n}, TypeError);\nE('ERR_PACKAGE_PATH_NOT_EXPORTED', (pkgPath, subpath, base = undefined) => {\n  if (subpath === '.')\n    return `No \"exports\" main defined in ${pkgPath}package.json${base ?\n      ` imported from ${base}` : ''}`;\n  return `Package subpath '${subpath}' is not defined by \"exports\" in ${\n    pkgPath}package.json${base ? ` imported from ${base}` : ''}`;\n}, Error);\nE('ERR_REQUIRE_ESM',\n  (filename, parentPath = null, packageJsonPath = null) => {\n    let msg = `Must use import to load ES Module: ${filename}`;\n    if (parentPath && packageJsonPath) {\n      const path = require('path');\n      const basename = path.basename(filename) === path.basename(parentPath) ?\n        filename : path.basename(filename);\n      msg +=\n        '\\nrequire() of ES modules is not supported.\\nrequire() of ' +\n        `${filename} from ${parentPath} ` +\n        'is an ES module file as it is a .js file whose nearest parent ' +\n        'package.json contains \"type\": \"module\" which defines all .js ' +\n        'files in that package scope as ES modules.\\nInstead rename ' +\n        `${basename} to end in .cjs, change the requiring code to use ` +\n        'import(), or remove \"type\": \"module\" from ' +\n        `${packageJsonPath}.\\n`;\n      return msg;\n    }\n    return msg;\n  }, Error);\nE('ERR_SCRIPT_EXECUTION_INTERRUPTED',\n  'Script execution was interrupted by `SIGINT`', Error);\nE('ERR_SERVER_ALREADY_LISTEN',\n  'Listen method has been called more than once without closing.', Error);\nE('ERR_SERVER_NOT_RUNNING', 'Server is not running.', Error);\nE('ERR_SOCKET_ALREADY_BOUND', 'Socket is already bound', Error);\nE('ERR_SOCKET_BAD_BUFFER_SIZE',\n  'Buffer size must be a positive integer', TypeError);\nE('ERR_SOCKET_BAD_PORT', (name, port, allowZero = true) => {\n  assert(typeof allowZero === 'boolean',\n         \"The 'allowZero' argument must be of type boolean.\");\n  const operator = allowZero ? '>=' : '>';\n  return `${name} should be ${operator} 0 and < 65536. Received ${port}.`;\n}, RangeError);\nE('ERR_SOCKET_BAD_TYPE',\n  'Bad socket type specified. Valid types are: udp4, udp6', TypeError);\nE('ERR_SOCKET_BUFFER_SIZE',\n  'Could not get or set buffer size',\n  SystemError);\nE('ERR_SOCKET_CLOSED', 'Socket is closed', Error);\nE('ERR_SOCKET_DGRAM_IS_CONNECTED', 'Already connected', Error);\nE('ERR_SOCKET_DGRAM_NOT_CONNECTED', 'Not connected', Error);\nE('ERR_SOCKET_DGRAM_NOT_RUNNING', 'Not running', Error);\nE('ERR_SRI_PARSE',\n  'Subresource Integrity string %j had an unexpected %j at position %d',\n  SyntaxError);\nE('ERR_STREAM_ALREADY_FINISHED',\n  'Cannot call %s after a stream was finished',\n  Error);\nE('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable', Error);\nE('ERR_STREAM_DESTROYED', 'Cannot call %s after a stream was destroyed', Error);\nE('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);\nE('ERR_STREAM_PREMATURE_CLOSE', 'Premature close', Error);\nE('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF', Error);\nE('ERR_STREAM_UNSHIFT_AFTER_END_EVENT',\n  'stream.unshift() after end event', Error);\nE('ERR_STREAM_WRAP', 'Stream has StringDecoder set or is in objectMode', Error);\nE('ERR_STREAM_WRITE_AFTER_END', 'write after end', Error);\nE('ERR_SYNTHETIC', 'JavaScript Callstack', Error);\nE('ERR_SYSTEM_ERROR', 'A system error occurred', SystemError);\nE('ERR_TLS_CERT_ALTNAME_INVALID', function(reason, host, cert) {\n  this.reason = reason;\n  this.host = host;\n  this.cert = cert;\n  return `Hostname/IP does not match certificate's altnames: ${reason}`;\n}, Error);\nE('ERR_TLS_DH_PARAM_SIZE', 'DH parameter size %s is less than 2048', Error);\nE('ERR_TLS_HANDSHAKE_TIMEOUT', 'TLS handshake timeout', Error);\nE('ERR_TLS_INVALID_CONTEXT', '%s must be a SecureContext', TypeError),\nE('ERR_TLS_INVALID_STATE', 'TLS socket connection must be securely established',\n  Error),\nE('ERR_TLS_INVALID_PROTOCOL_VERSION',\n  '%j is not a valid %s TLS protocol version', TypeError);\nE('ERR_TLS_PROTOCOL_VERSION_CONFLICT',\n  'TLS protocol version %j conflicts with secureProtocol %j', TypeError);\nE('ERR_TLS_RENEGOTIATION_DISABLED',\n  'TLS session renegotiation disabled for this socket', Error);\n\n// This should probably be a `TypeError`.\nE('ERR_TLS_REQUIRED_SERVER_NAME',\n  '\"servername\" is required parameter for Server.addContext', Error);\nE('ERR_TLS_SESSION_ATTACK', 'TLS session renegotiation attack detected', Error);\nE('ERR_TLS_SNI_FROM_SERVER',\n  'Cannot issue SNI from a TLS server-side socket', Error);\nE('ERR_TRACE_EVENTS_CATEGORY_REQUIRED',\n  'At least one category is required', TypeError);\nE('ERR_TRACE_EVENTS_UNAVAILABLE', 'Trace events are unavailable', Error);\nE('ERR_TRANSFORM_ALREADY_TRANSFORMING',\n  'Calling transform done when still transforming', Error);\n\n// This should probably be a `RangeError`.\nE('ERR_TRANSFORM_WITH_LENGTH_0',\n  'Calling transform done when writableState.length != 0', Error);\nE('ERR_TTY_INIT_FAILED', 'TTY initialization failed', SystemError);\nE('ERR_UNAVAILABLE_DURING_EXIT', 'Cannot call function in process exit ' +\n  'handler', Error);\nE('ERR_UNCAUGHT_EXCEPTION_CAPTURE_ALREADY_SET',\n  '`process.setupUncaughtExceptionCapture()` was called while a capture ' +\n    'callback was already active',\n  Error);\nE('ERR_UNESCAPED_CHARACTERS', '%s contains unescaped characters', TypeError);\nE('ERR_UNHANDLED_ERROR',\n  // Using a default argument here is important so the argument is not counted\n  // towards `Function#length`.\n  (err = undefined) => {\n    const msg = 'Unhandled error.';\n    if (err === undefined) return msg;\n    return `${msg} (${err})`;\n  }, Error);\nE('ERR_UNKNOWN_BUILTIN_MODULE', 'No such built-in module: %s', Error);\nE('ERR_UNKNOWN_CREDENTIAL', '%s identifier does not exist: %s', Error);\nE('ERR_UNKNOWN_ENCODING', 'Unknown encoding: %s', TypeError);\nE('ERR_UNKNOWN_FILE_EXTENSION',\n  'Unknown file extension \"%s\" for %s',\n  TypeError);\nE('ERR_UNKNOWN_MODULE_FORMAT', 'Unknown module format: %s', RangeError);\nE('ERR_UNKNOWN_SIGNAL', 'Unknown signal: %s', TypeError);\nE('ERR_UNSUPPORTED_DIR_IMPORT', \"Directory import '%s' is not supported \" +\n'resolving ES modules imported from %s', Error);\nE('ERR_UNSUPPORTED_ESM_URL_SCHEME', (url) => {\n  let msg = 'Only file and data URLs are supported by the default ESM loader';\n  if (isWindows && url.protocol.length === 2) {\n    msg +=\n      '. On Windows, absolute paths must be valid file:// URLs';\n  }\n  msg += `. Received protocol '${url.protocol}'`;\n  return msg;\n}, Error);\n\n// This should probably be a `TypeError`.\nE('ERR_VALID_PERFORMANCE_ENTRY_TYPE',\n  'At least one valid performance entry type is required', Error);\nE('ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING',\n  'A dynamic import callback was not specified.', TypeError);\nE('ERR_VM_MODULE_ALREADY_LINKED', 'Module has already been linked', Error);\nE('ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA',\n  'Cached data cannot be created for a module which has been evaluated', Error);\nE('ERR_VM_MODULE_DIFFERENT_CONTEXT',\n  'Linked modules must use the same context', Error);\nE('ERR_VM_MODULE_LINKING_ERRORED',\n  'Linking has already failed for the provided module', Error);\nE('ERR_VM_MODULE_NOT_MODULE',\n  'Provided module is not an instance of Module', Error);\nE('ERR_VM_MODULE_STATUS', 'Module status %s', Error);\nE('ERR_WASI_ALREADY_STARTED', 'WASI instance has already started', Error);\nE('ERR_WORKER_INIT_FAILED', 'Worker initialization failure: %s', Error);\nE('ERR_WORKER_INVALID_EXEC_ARGV', (errors, msg = 'invalid execArgv flags') =>\n  `Initiated Worker with ${msg}: ${errors.join(', ')}`,\n  Error);\nE('ERR_WORKER_NOT_RUNNING', 'Worker instance not running', Error);\nE('ERR_WORKER_OUT_OF_MEMORY',\n  'Worker terminated due to reaching memory limit: %s', Error);\nE('ERR_WORKER_PATH', (filename) =>\n  'The worker script or module filename must be an absolute path or a ' +\n  'relative path starting with \\'./\\' or \\'../\\'.' +\n  (filename.startsWith('file://') ?\n    ' Wrap file:// URLs with `new URL`.' : ''\n  ) +\n  (filename.startsWith('data:text/javascript') ?\n    ' Wrap data: URLs with `new URL`.' : ''\n  ) +\n  ` Received \"${filename}\"`,\n  TypeError);\nE('ERR_WORKER_UNSERIALIZABLE_ERROR',\n  'Serializing an uncaught exception failed', Error);\nE('ERR_WORKER_UNSUPPORTED_EXTENSION',\n  'The worker script extension must be \".js\", \".mjs\", or \".cjs\". Received \"%s\"',\n  TypeError);\nE('ERR_WORKER_UNSUPPORTED_OPERATION',\n  '%s is not supported in workers', TypeError);\nE('ERR_ZLIB_INITIALIZATION_FAILED', 'Initialization failed', Error);\n"
  },
  {
    "url": "internal/fixed_queue.js",
    "ranges": [
      {
        "start": 0,
        "end": 3077
      },
      {
        "start": 3129,
        "end": 3133
      },
      {
        "start": 3200,
        "end": 3204
      },
      {
        "start": 3291,
        "end": 3295
      },
      {
        "start": 3510,
        "end": 3630
      },
      {
        "start": 3677,
        "end": 3681
      },
      {
        "start": 3945,
        "end": 3949
      },
      {
        "start": 4180,
        "end": 4184
      }
    ],
    "text": "'use strict';\n\nconst {\n  Array,\n} = primordials;\n\n// Currently optimal queue size, tested on V8 6.0 - 6.6. Must be power of two.\nconst kSize = 2048;\nconst kMask = kSize - 1;\n\n// The FixedQueue is implemented as a singly-linked list of fixed-size\n// circular buffers. It looks something like this:\n//\n//  head                                                       tail\n//    |                                                          |\n//    v                                                          v\n// +-----------+ <-----\\       +-----------+ <------\\         +-----------+\n// |  [null]   |        \\----- |   next    |         \\------- |   next    |\n// +-----------+               +-----------+                  +-----------+\n// |   item    | <-- bottom    |   item    | <-- bottom       |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |       bottom --> |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |    ...    |               |    ...    |                  |    ...    |\n// |   item    |               |   item    |                  |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |  [empty]  | <-- top       |   item    |                  |   item    |\n// |  [empty]  |               |   item    |                  |   item    |\n// |  [empty]  |               |  [empty]  | <-- top  top --> |  [empty]  |\n// +-----------+               +-----------+                  +-----------+\n//\n// Or, if there is only one circular buffer, it looks something\n// like either of these:\n//\n//  head   tail                                 head   tail\n//    |     |                                     |     |\n//    v     v                                     v     v\n// +-----------+                               +-----------+\n// |  [null]   |                               |  [null]   |\n// +-----------+                               +-----------+\n// |  [empty]  |                               |   item    |\n// |  [empty]  |                               |   item    |\n// |   item    | <-- bottom            top --> |  [empty]  |\n// |   item    |                               |  [empty]  |\n// |  [empty]  | <-- top            bottom --> |   item    |\n// |  [empty]  |                               |   item    |\n// +-----------+                               +-----------+\n//\n// Adding a value means moving `top` forward by one, removing means\n// moving `bottom` forward by one. After reaching the end, the queue\n// wraps around.\n//\n// When `top === bottom` the current queue is empty and when\n// `top + 1 === bottom` it's full. This wastes a single space of storage\n// but allows much quicker checks.\n\nclass FixedCircularBuffer {\n  constructor() {\n    this.bottom = 0;\n    this.top = 0;\n    this.list = new Array(kSize);\n    this.next = null;\n  }\n\n  isEmpty() {\n    return this.top === this.bottom;\n  }\n\n  isFull() {\n    return ((this.top + 1) & kMask) === this.bottom;\n  }\n\n  push(data) {\n    this.list[this.top] = data;\n    this.top = (this.top + 1) & kMask;\n  }\n\n  shift() {\n    const nextItem = this.list[this.bottom];\n    if (nextItem === undefined)\n      return null;\n    this.list[this.bottom] = undefined;\n    this.bottom = (this.bottom + 1) & kMask;\n    return nextItem;\n  }\n}\n\nmodule.exports = class FixedQueue {\n  constructor() {\n    this.head = this.tail = new FixedCircularBuffer();\n  }\n\n  isEmpty() {\n    return this.head.isEmpty();\n  }\n\n  push(data) {\n    if (this.head.isFull()) {\n      // Head is full: Creates a new queue, sets the old queue's `.next` to it,\n      // and sets it as the new main queue.\n      this.head = this.head.next = new FixedCircularBuffer();\n    }\n    this.head.push(data);\n  }\n\n  shift() {\n    const tail = this.tail;\n    const next = tail.shift();\n    if (tail.isEmpty() && tail.next !== null) {\n      // If there is another queue, it forms the new tail.\n      this.tail = tail.next;\n    }\n    return next;\n  }\n};\n"
  },
  {
    "url": "internal/fs/dir.js",
    "ranges": [
      {
        "start": 0,
        "end": 1092
      },
      {
        "start": 1864,
        "end": 1868
      },
      {
        "start": 1911,
        "end": 1915
      },
      {
        "start": 1982,
        "end": 1986
      },
      {
        "start": 3358,
        "end": 3362
      },
      {
        "start": 4118,
        "end": 4122
      },
      {
        "start": 4682,
        "end": 4686
      },
      {
        "start": 5063,
        "end": 5067
      },
      {
        "start": 5330,
        "end": 5491
      },
      {
        "start": 6116,
        "end": 6118
      },
      {
        "start": 6475,
        "end": 6531
      }
    ],
    "text": "'use strict';\n\nconst {\n  ObjectDefineProperty,\n  Symbol,\n  SymbolAsyncIterator,\n} = primordials;\n\nconst pathModule = require('path');\nconst binding = internalBinding('fs');\nconst dirBinding = internalBinding('fs_dir');\nconst {\n  codes: {\n    ERR_DIR_CLOSED,\n    ERR_DIR_CONCURRENT_OPERATION,\n    ERR_INVALID_CALLBACK,\n    ERR_MISSING_ARGS\n  }\n} = require('internal/errors');\n\nconst { FSReqCallback } = binding;\nconst internalUtil = require('internal/util');\nconst {\n  getDirent,\n  getOptions,\n  getValidatedPath,\n  handleErrorFromBinding\n} = require('internal/fs/utils');\nconst {\n  validateUint32\n} = require('internal/validators');\n\nconst kDirHandle = Symbol('kDirHandle');\nconst kDirPath = Symbol('kDirPath');\nconst kDirBufferedEntries = Symbol('kDirBufferedEntries');\nconst kDirClosed = Symbol('kDirClosed');\nconst kDirOptions = Symbol('kDirOptions');\nconst kDirReadImpl = Symbol('kDirReadImpl');\nconst kDirReadPromisified = Symbol('kDirReadPromisified');\nconst kDirClosePromisified = Symbol('kDirClosePromisified');\nconst kDirOperationQueue = Symbol('kDirOperationQueue');\n\nclass Dir {\n  constructor(handle, path, options) {\n    if (handle == null) throw new ERR_MISSING_ARGS('handle');\n    this[kDirHandle] = handle;\n    this[kDirBufferedEntries] = [];\n    this[kDirPath] = path;\n    this[kDirClosed] = false;\n\n    // Either `null` or an Array of pending operations (= functions to be called\n    // once the current operation is done).\n    this[kDirOperationQueue] = null;\n\n    this[kDirOptions] = {\n      bufferSize: 32,\n      ...getOptions(options, {\n        encoding: 'utf8'\n      })\n    };\n\n    validateUint32(this[kDirOptions].bufferSize, 'options.bufferSize', true);\n\n    this[kDirReadPromisified] =\n        internalUtil.promisify(this[kDirReadImpl]).bind(this, false);\n    this[kDirClosePromisified] = internalUtil.promisify(this.close).bind(this);\n  }\n\n  get path() {\n    return this[kDirPath];\n  }\n\n  read(callback) {\n    return this[kDirReadImpl](true, callback);\n  }\n\n  [kDirReadImpl](maybeSync, callback) {\n    if (this[kDirClosed] === true) {\n      throw new ERR_DIR_CLOSED();\n    }\n\n    if (callback === undefined) {\n      return this[kDirReadPromisified]();\n    } else if (typeof callback !== 'function') {\n      throw new ERR_INVALID_CALLBACK(callback);\n    }\n\n    if (this[kDirOperationQueue] !== null) {\n      this[kDirOperationQueue].push(() => {\n        this[kDirReadImpl](maybeSync, callback);\n      });\n      return;\n    }\n\n    if (this[kDirBufferedEntries].length > 0) {\n      const [ name, type ] = this[kDirBufferedEntries].splice(0, 2);\n      if (maybeSync)\n        process.nextTick(getDirent, this[kDirPath], name, type, callback);\n      else\n        getDirent(this[kDirPath], name, type, callback);\n      return;\n    }\n\n    const req = new FSReqCallback();\n    req.oncomplete = (err, result) => {\n      process.nextTick(() => {\n        const queue = this[kDirOperationQueue];\n        this[kDirOperationQueue] = null;\n        for (const op of queue) op();\n      });\n\n      if (err || result === null) {\n        return callback(err, result);\n      }\n\n      this[kDirBufferedEntries] = result.slice(2);\n      getDirent(this[kDirPath], result[0], result[1], callback);\n    };\n\n    this[kDirOperationQueue] = [];\n    this[kDirHandle].read(\n      this[kDirOptions].encoding,\n      this[kDirOptions].bufferSize,\n      req\n    );\n  }\n\n  readSync() {\n    if (this[kDirClosed] === true) {\n      throw new ERR_DIR_CLOSED();\n    }\n\n    if (this[kDirOperationQueue] !== null) {\n      throw new ERR_DIR_CONCURRENT_OPERATION();\n    }\n\n    if (this[kDirBufferedEntries].length > 0) {\n      const [ name, type ] = this[kDirBufferedEntries].splice(0, 2);\n      return getDirent(this[kDirPath], name, type);\n    }\n\n    const ctx = { path: this[kDirPath] };\n    const result = this[kDirHandle].read(\n      this[kDirOptions].encoding,\n      this[kDirOptions].bufferSize,\n      undefined,\n      ctx\n    );\n    handleErrorFromBinding(ctx);\n\n    if (result === null) {\n      return result;\n    }\n\n    this[kDirBufferedEntries] = result.slice(2);\n    return getDirent(this[kDirPath], result[0], result[1]);\n  }\n\n  close(callback) {\n    if (this[kDirClosed] === true) {\n      throw new ERR_DIR_CLOSED();\n    }\n\n    if (callback === undefined) {\n      return this[kDirClosePromisified]();\n    } else if (typeof callback !== 'function') {\n      throw new ERR_INVALID_CALLBACK(callback);\n    }\n\n    if (this[kDirOperationQueue] !== null) {\n      this[kDirOperationQueue].push(() => {\n        this.close(callback);\n      });\n      return;\n    }\n\n    this[kDirClosed] = true;\n    const req = new FSReqCallback();\n    req.oncomplete = callback;\n    this[kDirHandle].close(req);\n  }\n\n  closeSync() {\n    if (this[kDirClosed] === true) {\n      throw new ERR_DIR_CLOSED();\n    }\n\n    if (this[kDirOperationQueue] !== null) {\n      throw new ERR_DIR_CONCURRENT_OPERATION();\n    }\n\n    this[kDirClosed] = true;\n    const ctx = { path: this[kDirPath] };\n    const result = this[kDirHandle].close(undefined, ctx);\n    handleErrorFromBinding(ctx);\n    return result;\n  }\n\n  async* entries() {\n    try {\n      while (true) {\n        const result = await this[kDirReadPromisified]();\n        if (result === null) {\n          break;\n        }\n        yield result;\n      }\n    } finally {\n      await this[kDirClosePromisified]();\n    }\n  }\n}\n\nObjectDefineProperty(Dir.prototype, SymbolAsyncIterator, {\n  value: Dir.prototype.entries,\n  enumerable: false,\n  writable: true,\n  configurable: true,\n});\n\nfunction opendir(path, options, callback) {\n  callback = typeof options === 'function' ? options : callback;\n  if (typeof callback !== 'function') {\n    throw new ERR_INVALID_CALLBACK(callback);\n  }\n  path = getValidatedPath(path);\n  options = getOptions(options, {\n    encoding: 'utf8'\n  });\n\n  function opendirCallback(error, handle) {\n    if (error) {\n      callback(error);\n    } else {\n      callback(null, new Dir(handle, path, options));\n    }\n  }\n\n  const req = new FSReqCallback();\n  req.oncomplete = opendirCallback;\n\n  dirBinding.opendir(\n    pathModule.toNamespacedPath(path),\n    options.encoding,\n    req\n  );\n}\n\nfunction opendirSync(path, options) {\n  path = getValidatedPath(path);\n  options = getOptions(options, {\n    encoding: 'utf8'\n  });\n\n  const ctx = { path };\n  const handle = dirBinding.opendir(\n    pathModule.toNamespacedPath(path),\n    options.encoding,\n    undefined,\n    ctx\n  );\n  handleErrorFromBinding(ctx);\n\n  return new Dir(handle, path, options);\n}\n\nmodule.exports = {\n  Dir,\n  opendir,\n  opendirSync\n};\n"
  },
  {
    "url": "internal/fs/promises.js",
    "ranges": [
      {
        "start": 0,
        "end": 2166
      },
      {
        "start": 2343,
        "end": 2347
      },
      {
        "start": 2404,
        "end": 2408
      },
      {
        "start": 2444,
        "end": 2448
      },
      {
        "start": 2530,
        "end": 2534
      },
      {
        "start": 2590,
        "end": 2594
      },
      {
        "start": 2658,
        "end": 2662
      },
      {
        "start": 2714,
        "end": 2718
      },
      {
        "start": 2762,
        "end": 2766
      },
      {
        "start": 2875,
        "end": 2879
      },
      {
        "start": 2960,
        "end": 2964
      },
      {
        "start": 3031,
        "end": 3035
      },
      {
        "start": 3095,
        "end": 3099
      },
      {
        "start": 3163,
        "end": 3167
      },
      {
        "start": 3241,
        "end": 3245
      },
      {
        "start": 3356,
        "end": 3360
      },
      {
        "start": 3443,
        "end": 3447
      },
      {
        "start": 3528,
        "end": 3532
      },
      {
        "start": 4224,
        "end": 4228
      },
      {
        "start": 4697,
        "end": 4701
      },
      {
        "start": 4754,
        "end": 4758
      },
      {
        "start": 4845,
        "end": 4849
      },
      {
        "start": 5467,
        "end": 5469
      },
      {
        "start": 6027,
        "end": 6029
      },
      {
        "start": 6892,
        "end": 7045
      },
      {
        "start": 7266,
        "end": 7268
      },
      {
        "start": 7626,
        "end": 7746
      },
      {
        "start": 8071,
        "end": 8073
      },
      {
        "start": 9127,
        "end": 9129
      },
      {
        "start": 9449,
        "end": 9451
      },
      {
        "start": 10372,
        "end": 10374
      },
      {
        "start": 10706,
        "end": 10708
      },
      {
        "start": 11014,
        "end": 11016
      },
      {
        "start": 11159,
        "end": 11161
      },
      {
        "start": 11320,
        "end": 11322
      },
      {
        "start": 11519,
        "end": 11521
      },
      {
        "start": 11784,
        "end": 11786
      },
      {
        "start": 11875,
        "end": 11877
      },
      {
        "start": 11958,
        "end": 11960
      },
      {
        "start": 12492,
        "end": 12494
      },
      {
        "start": 12946,
        "end": 12948
      },
      {
        "start": 13191,
        "end": 13193
      },
      {
        "start": 13606,
        "end": 13608
      },
      {
        "start": 13786,
        "end": 13788
      },
      {
        "start": 14058,
        "end": 14060
      },
      {
        "start": 14327,
        "end": 14329
      },
      {
        "start": 14652,
        "end": 14654
      },
      {
        "start": 14792,
        "end": 14794
      },
      {
        "start": 14927,
        "end": 14929
      },
      {
        "start": 15115,
        "end": 15117
      },
      {
        "start": 15355,
        "end": 15357
      },
      {
        "start": 15599,
        "end": 15601
      },
      {
        "start": 15764,
        "end": 15766
      },
      {
        "start": 16005,
        "end": 16007
      },
      {
        "start": 16279,
        "end": 16281
      },
      {
        "start": 16480,
        "end": 16482
      },
      {
        "start": 16759,
        "end": 16761
      },
      {
        "start": 16938,
        "end": 16940
      },
      {
        "start": 17270,
        "end": 17272
      },
      {
        "start": 17785,
        "end": 17787
      },
      {
        "start": 18028,
        "end": 18030
      },
      {
        "start": 18351,
        "end": 18758
      }
    ],
    "text": "'use strict';\n\n// Most platforms don't allow reads or writes >= 2 GB.\n// See https://github.com/libuv/libuv/pull/1501.\nconst kIoMaxLength = 2 ** 31 - 1;\n\n// Note: This is different from kReadFileBufferLength used for non-promisified\n// fs.readFile.\nconst kReadFileMaxChunkSize = 2 ** 14;\nconst kWriteFileMaxChunkSize = 2 ** 14;\n\nconst {\n  Error,\n  MathMax,\n  MathMin,\n  NumberIsSafeInteger,\n  Promise,\n  PromisePrototypeFinally,\n  PromiseResolve,\n  Symbol,\n  Uint8Array,\n} = primordials;\n\nconst {\n  F_OK,\n  O_SYMLINK,\n  O_WRONLY,\n  S_IFMT,\n  S_IFREG\n} = internalBinding('constants').fs;\nconst binding = internalBinding('fs');\nconst { Buffer } = require('buffer');\nconst {\n  ERR_FS_FILE_TOO_LARGE,\n  ERR_INVALID_ARG_TYPE,\n  ERR_INVALID_ARG_VALUE,\n  ERR_METHOD_NOT_IMPLEMENTED\n} = require('internal/errors').codes;\nconst { isArrayBufferView } = require('internal/util/types');\nconst { rimrafPromises } = require('internal/fs/rimraf');\nconst {\n  copyObject,\n  getDirents,\n  getOptions,\n  getStatsFromBinding,\n  getValidatedPath,\n  getValidMode,\n  nullCheck,\n  preprocessSymlinkDestination,\n  stringToFlags,\n  stringToSymlinkType,\n  toUnixTimestamp,\n  validateBufferArray,\n  validateOffsetLengthRead,\n  validateOffsetLengthWrite,\n  validateRmOptions,\n  validateRmdirOptions,\n  validateStringAfterArrayBufferView,\n  warnOnNonPortableTemplate\n} = require('internal/fs/utils');\nconst { opendir } = require('internal/fs/dir');\nconst {\n  parseFileMode,\n  validateBuffer,\n  validateInteger,\n  validateUint32\n} = require('internal/validators');\nconst pathModule = require('path');\nconst { promisify } = require('internal/util');\n\nconst kHandle = Symbol('kHandle');\nconst kFd = Symbol('kFd');\nconst kRefs = Symbol('kRefs');\nconst kClosePromise = Symbol('kClosePromise');\nconst kCloseResolve = Symbol('kCloseResolve');\nconst kCloseReject = Symbol('kCloseReject');\n\nconst { kUsePromises } = binding;\nconst {\n  JSTransferable, kDeserialize, kTransfer, kTransferList\n} = require('internal/worker/js_transferable');\n\nconst getDirectoryEntriesPromise = promisify(getDirents);\nconst validateRmOptionsPromise = promisify(validateRmOptions);\n\nclass FileHandle extends JSTransferable {\n  constructor(filehandle) {\n    super();\n    this[kHandle] = filehandle;\n    this[kFd] = filehandle ? filehandle.fd : -1;\n\n    this[kRefs] = 1;\n    this[kClosePromise] = null;\n  }\n\n  getAsyncId() {\n    return this[kHandle].getAsyncId();\n  }\n\n  get fd() {\n    return this[kFd];\n  }\n\n  appendFile(data, options) {\n    return fsCall(writeFile, this, data, options);\n  }\n\n  chmod(mode) {\n    return fsCall(fchmod, this, mode);\n  }\n\n  chown(uid, gid) {\n    return fsCall(fchown, this, uid, gid);\n  }\n\n  datasync() {\n    return fsCall(fdatasync, this);\n  }\n\n  sync() {\n    return fsCall(fsync, this);\n  }\n\n  read(buffer, offset, length, position) {\n    return fsCall(read, this, buffer, offset, length, position);\n  }\n\n  readv(buffers, position) {\n    return fsCall(readv, this, buffers, position);\n  }\n\n  readFile(options) {\n    return fsCall(readFile, this, options);\n  }\n\n  stat(options) {\n    return fsCall(fstat, this, options);\n  }\n\n  truncate(len = 0) {\n    return fsCall(ftruncate, this, len);\n  }\n\n  utimes(atime, mtime) {\n    return fsCall(futimes, this, atime, mtime);\n  }\n\n  write(buffer, offset, length, position) {\n    return fsCall(write, this, buffer, offset, length, position);\n  }\n\n  writev(buffers, position) {\n    return fsCall(writev, this, buffers, position);\n  }\n\n  writeFile(data, options) {\n    return fsCall(writeFile, this, data, options);\n  }\n\n  close = () => {\n    if (this[kFd] === -1) {\n      return PromiseResolve();\n    }\n\n    if (this[kClosePromise]) {\n      return this[kClosePromise];\n    }\n\n    this[kRefs]--;\n    if (this[kRefs] === 0) {\n      this[kFd] = -1;\n      this[kClosePromise] = this[kHandle].close().finally(() => {\n        this[kClosePromise] = undefined;\n      });\n    } else {\n      this[kClosePromise] = new Promise((resolve, reject) => {\n        this[kCloseResolve] = resolve;\n        this[kCloseReject] = reject;\n      }).finally(() => {\n        this[kClosePromise] = undefined;\n        this[kCloseReject] = undefined;\n        this[kCloseResolve] = undefined;\n      });\n    }\n\n    return this[kClosePromise];\n  }\n\n  [kTransfer]() {\n    if (this[kClosePromise] || this[kRefs] > 1) {\n      const DOMException = internalBinding('messaging').DOMException;\n      throw new DOMException('Cannot transfer FileHandle while in use',\n                             'DataCloneError');\n    }\n\n    const handle = this[kHandle];\n    this[kFd] = -1;\n    this[kHandle] = null;\n    this[kRefs] = 0;\n\n    return {\n      data: { handle },\n      deserializeInfo: 'internal/fs/promises:FileHandle'\n    };\n  }\n\n  [kTransferList]() {\n    return [ this[kHandle] ];\n  }\n\n  [kDeserialize]({ handle }) {\n    this[kHandle] = handle;\n    this[kFd] = handle.fd;\n  }\n}\n\nasync function fsCall(fn, handle, ...args) {\n  if (handle[kRefs] === undefined) {\n    throw new ERR_INVALID_ARG_TYPE('filehandle', 'FileHandle', handle);\n  }\n\n  if (handle.fd === -1) {\n    // eslint-disable-next-line no-restricted-syntax\n    const err = new Error('file closed');\n    err.code = 'EBADF';\n    err.syscall = fn.name;\n    throw err;\n  }\n\n  try {\n    handle[kRefs]++;\n    return await fn(handle, ...args);\n  } finally {\n    handle[kRefs]--;\n    if (handle[kRefs] === 0) {\n      handle[kFd] = -1;\n      handle[kHandle]\n        .close()\n        .then(handle[kCloseResolve], handle[kCloseReject]);\n    }\n  }\n}\n\nasync function writeFileHandle(filehandle, data) {\n  // `data` could be any kind of typed array.\n  data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n  let remaining = data.length;\n  if (remaining === 0) return;\n  do {\n    const { bytesWritten } =\n      await write(filehandle, data, 0,\n                  MathMin(kWriteFileMaxChunkSize, data.length));\n    remaining -= bytesWritten;\n    data = new Uint8Array(\n      data.buffer,\n      data.byteOffset + bytesWritten,\n      data.byteLength - bytesWritten\n    );\n  } while (remaining > 0);\n}\n\nasync function readFileHandle(filehandle, options) {\n  const statFields = await binding.fstat(filehandle.fd, false, kUsePromises);\n\n  let size;\n  if ((statFields[1/* mode */] & S_IFMT) === S_IFREG) {\n    size = statFields[8/* size */];\n  } else {\n    size = 0;\n  }\n\n  if (size > kIoMaxLength)\n    throw new ERR_FS_FILE_TOO_LARGE(size);\n\n  const chunks = [];\n  const chunkSize = size === 0 ?\n    kReadFileMaxChunkSize :\n    MathMin(size, kReadFileMaxChunkSize);\n  let endOfFile = false;\n  do {\n    const buf = Buffer.alloc(chunkSize);\n    const { bytesRead, buffer } =\n      await read(filehandle, buf, 0, chunkSize, -1);\n    endOfFile = bytesRead === 0;\n    if (bytesRead > 0)\n      chunks.push(buffer.slice(0, bytesRead));\n  } while (!endOfFile);\n\n  const result = Buffer.concat(chunks);\n\n  return options.encoding ? result.toString(options.encoding) : result;\n}\n\n// All of the functions are defined as async in order to ensure that errors\n// thrown cause promise rejections rather than being thrown synchronously.\nasync function access(path, mode = F_OK) {\n  path = getValidatedPath(path);\n\n  mode = getValidMode(mode, 'access');\n  return binding.access(pathModule.toNamespacedPath(path), mode,\n                        kUsePromises);\n}\n\nasync function copyFile(src, dest, mode) {\n  src = getValidatedPath(src, 'src');\n  dest = getValidatedPath(dest, 'dest');\n  mode = getValidMode(mode, 'copyFile');\n  return binding.copyFile(pathModule.toNamespacedPath(src),\n                          pathModule.toNamespacedPath(dest),\n                          mode,\n                          kUsePromises);\n}\n\n// Note that unlike fs.open() which uses numeric file descriptors,\n// fsPromises.open() uses the fs.FileHandle class.\nasync function open(path, flags, mode) {\n  path = getValidatedPath(path);\n  const flagsNumber = stringToFlags(flags);\n  mode = parseFileMode(mode, 'mode', 0o666);\n  return new FileHandle(\n    await binding.openFileHandle(pathModule.toNamespacedPath(path),\n                                 flagsNumber, mode, kUsePromises));\n}\n\nasync function read(handle, bufferOrOptions, offset, length, position) {\n  let buffer = bufferOrOptions;\n  if (!isArrayBufferView(buffer)) {\n    if (bufferOrOptions.buffer) {\n      buffer = bufferOrOptions.buffer;\n      validateBuffer(buffer);\n    } else {\n      buffer = Buffer.alloc(16384);\n    }\n    offset = bufferOrOptions.offset || 0;\n    length = buffer.length;\n    position = bufferOrOptions.position || null;\n  }\n\n  if (offset == null) {\n    offset = 0;\n  } else {\n    validateInteger(offset, 'offset');\n  }\n\n  length |= 0;\n\n  if (length === 0)\n    return { bytesRead: length, buffer };\n\n  if (buffer.length === 0) {\n    throw new ERR_INVALID_ARG_VALUE('buffer', buffer,\n                                    'is empty and cannot be written');\n  }\n\n  validateOffsetLengthRead(offset, length, buffer.length);\n\n  if (!NumberIsSafeInteger(position))\n    position = -1;\n\n  const bytesRead = (await binding.read(handle.fd, buffer, offset, length,\n                                        position, kUsePromises)) || 0;\n\n  return { bytesRead, buffer };\n}\n\nasync function readv(handle, buffers, position) {\n  validateBufferArray(buffers);\n\n  if (typeof position !== 'number')\n    position = null;\n\n  const bytesRead = (await binding.readBuffers(handle.fd, buffers, position,\n                                               kUsePromises)) || 0;\n  return { bytesRead, buffers };\n}\n\nasync function write(handle, buffer, offset, length, position) {\n  if (buffer.length === 0)\n    return { bytesWritten: 0, buffer };\n\n  if (isArrayBufferView(buffer)) {\n    if (offset == null) {\n      offset = 0;\n    } else {\n      validateInteger(offset, 'offset');\n    }\n    if (typeof length !== 'number')\n      length = buffer.length - offset;\n    if (typeof position !== 'number')\n      position = null;\n    validateOffsetLengthWrite(offset, length, buffer.byteLength);\n    const bytesWritten =\n      (await binding.writeBuffer(handle.fd, buffer, offset,\n                                 length, position, kUsePromises)) || 0;\n    return { bytesWritten, buffer };\n  }\n\n  validateStringAfterArrayBufferView(buffer, 'buffer');\n  const bytesWritten = (await binding.writeString(handle.fd, buffer, offset,\n                                                  length, kUsePromises)) || 0;\n  return { bytesWritten, buffer };\n}\n\nasync function writev(handle, buffers, position) {\n  validateBufferArray(buffers);\n\n  if (typeof position !== 'number')\n    position = null;\n\n  const bytesWritten = (await binding.writeBuffers(handle.fd, buffers, position,\n                                                   kUsePromises)) || 0;\n  return { bytesWritten, buffers };\n}\n\nasync function rename(oldPath, newPath) {\n  oldPath = getValidatedPath(oldPath, 'oldPath');\n  newPath = getValidatedPath(newPath, 'newPath');\n  return binding.rename(pathModule.toNamespacedPath(oldPath),\n                        pathModule.toNamespacedPath(newPath),\n                        kUsePromises);\n}\n\nasync function truncate(path, len = 0) {\n  const fd = await open(path, 'r+');\n  return PromisePrototypeFinally(ftruncate(fd, len), fd.close);\n}\n\nasync function ftruncate(handle, len = 0) {\n  validateInteger(len, 'len');\n  len = MathMax(0, len);\n  return binding.ftruncate(handle.fd, len, kUsePromises);\n}\n\nasync function rm(path, options) {\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\n  options = await validateRmOptionsPromise(path, options);\n  return rimrafPromises(path, options);\n}\n\nasync function rmdir(path, options) {\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\n  options = validateRmdirOptions(options);\n\n  if (options.recursive) {\n    return rimrafPromises(path, options);\n  }\n\n  return binding.rmdir(path, kUsePromises);\n}\n\nasync function fdatasync(handle) {\n  return binding.fdatasync(handle.fd, kUsePromises);\n}\n\nasync function fsync(handle) {\n  return binding.fsync(handle.fd, kUsePromises);\n}\n\nasync function mkdir(path, options) {\n  if (typeof options === 'number' || typeof options === 'string') {\n    options = { mode: options };\n  }\n  const {\n    recursive = false,\n    mode = 0o777\n  } = options || {};\n  path = getValidatedPath(path);\n  if (typeof recursive !== 'boolean')\n    throw new ERR_INVALID_ARG_TYPE('options.recursive', 'boolean', recursive);\n\n  return binding.mkdir(pathModule.toNamespacedPath(path),\n                       parseFileMode(mode, 'mode', 0o777), recursive,\n                       kUsePromises);\n}\n\nasync function readdir(path, options) {\n  options = getOptions(options, {});\n  path = getValidatedPath(path);\n  const result = await binding.readdir(pathModule.toNamespacedPath(path),\n                                       options.encoding,\n                                       !!options.withFileTypes,\n                                       kUsePromises);\n  return options.withFileTypes ?\n    getDirectoryEntriesPromise(path, result) :\n    result;\n}\n\nasync function readlink(path, options) {\n  options = getOptions(options, {});\n  path = getValidatedPath(path, 'oldPath');\n  return binding.readlink(pathModule.toNamespacedPath(path),\n                          options.encoding, kUsePromises);\n}\n\nasync function symlink(target, path, type_) {\n  const type = (typeof type_ === 'string' ? type_ : null);\n  target = getValidatedPath(target, 'target');\n  path = getValidatedPath(path);\n  return binding.symlink(preprocessSymlinkDestination(target, type, path),\n                         pathModule.toNamespacedPath(path),\n                         stringToSymlinkType(type),\n                         kUsePromises);\n}\n\nasync function fstat(handle, options = { bigint: false }) {\n  const result = await binding.fstat(handle.fd, options.bigint, kUsePromises);\n  return getStatsFromBinding(result);\n}\n\nasync function lstat(path, options = { bigint: false }) {\n  path = getValidatedPath(path);\n  const result = await binding.lstat(pathModule.toNamespacedPath(path),\n                                     options.bigint, kUsePromises);\n  return getStatsFromBinding(result);\n}\n\nasync function stat(path, options = { bigint: false }) {\n  path = getValidatedPath(path);\n  const result = await binding.stat(pathModule.toNamespacedPath(path),\n                                    options.bigint, kUsePromises);\n  return getStatsFromBinding(result);\n}\n\nasync function link(existingPath, newPath) {\n  existingPath = getValidatedPath(existingPath, 'existingPath');\n  newPath = getValidatedPath(newPath, 'newPath');\n  return binding.link(pathModule.toNamespacedPath(existingPath),\n                      pathModule.toNamespacedPath(newPath),\n                      kUsePromises);\n}\n\nasync function unlink(path) {\n  path = getValidatedPath(path);\n  return binding.unlink(pathModule.toNamespacedPath(path), kUsePromises);\n}\n\nasync function fchmod(handle, mode) {\n  mode = parseFileMode(mode, 'mode');\n  return binding.fchmod(handle.fd, mode, kUsePromises);\n}\n\nasync function chmod(path, mode) {\n  path = getValidatedPath(path);\n  mode = parseFileMode(mode, 'mode');\n  return binding.chmod(pathModule.toNamespacedPath(path), mode, kUsePromises);\n}\n\nasync function lchmod(path, mode) {\n  if (O_SYMLINK === undefined)\n    throw new ERR_METHOD_NOT_IMPLEMENTED('lchmod()');\n\n  const fd = await open(path, O_WRONLY | O_SYMLINK);\n  return PromisePrototypeFinally(fchmod(fd, mode), fd.close);\n}\n\nasync function lchown(path, uid, gid) {\n  path = getValidatedPath(path);\n  validateUint32(uid, 'uid');\n  validateUint32(gid, 'gid');\n  return binding.lchown(pathModule.toNamespacedPath(path),\n                        uid, gid, kUsePromises);\n}\n\nasync function fchown(handle, uid, gid) {\n  validateUint32(uid, 'uid');\n  validateUint32(gid, 'gid');\n  return binding.fchown(handle.fd, uid, gid, kUsePromises);\n}\n\nasync function chown(path, uid, gid) {\n  path = getValidatedPath(path);\n  validateUint32(uid, 'uid');\n  validateUint32(gid, 'gid');\n  return binding.chown(pathModule.toNamespacedPath(path),\n                       uid, gid, kUsePromises);\n}\n\nasync function utimes(path, atime, mtime) {\n  path = getValidatedPath(path);\n  return binding.utimes(pathModule.toNamespacedPath(path),\n                        toUnixTimestamp(atime),\n                        toUnixTimestamp(mtime),\n                        kUsePromises);\n}\n\nasync function futimes(handle, atime, mtime) {\n  atime = toUnixTimestamp(atime, 'atime');\n  mtime = toUnixTimestamp(mtime, 'mtime');\n  return binding.futimes(handle.fd, atime, mtime, kUsePromises);\n}\n\nasync function lutimes(path, atime, mtime) {\n  path = getValidatedPath(path);\n  return binding.lutimes(pathModule.toNamespacedPath(path),\n                         toUnixTimestamp(atime),\n                         toUnixTimestamp(mtime),\n                         kUsePromises);\n}\n\nasync function realpath(path, options) {\n  options = getOptions(options, {});\n  path = getValidatedPath(path);\n  return binding.realpath(path, options.encoding, kUsePromises);\n}\n\nasync function mkdtemp(prefix, options) {\n  options = getOptions(options, {});\n  if (!prefix || typeof prefix !== 'string') {\n    throw new ERR_INVALID_ARG_TYPE('prefix', 'string', prefix);\n  }\n  nullCheck(prefix);\n  warnOnNonPortableTemplate(prefix);\n  return binding.mkdtemp(`${prefix}XXXXXX`, options.encoding, kUsePromises);\n}\n\nasync function writeFile(path, data, options) {\n  options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'w' });\n  const flag = options.flag || 'w';\n\n  if (!isArrayBufferView(data)) {\n    validateStringAfterArrayBufferView(data, 'data');\n    data = Buffer.from(data, options.encoding || 'utf8');\n  }\n\n  if (path instanceof FileHandle)\n    return writeFileHandle(path, data);\n\n  const fd = await open(path, flag, options.mode);\n  return PromisePrototypeFinally(writeFileHandle(fd, data), fd.close);\n}\n\nasync function appendFile(path, data, options) {\n  options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'a' });\n  options = copyObject(options);\n  options.flag = options.flag || 'a';\n  return writeFile(path, data, options);\n}\n\nasync function readFile(path, options) {\n  options = getOptions(options, { flag: 'r' });\n  const flag = options.flag || 'r';\n\n  if (path instanceof FileHandle)\n    return readFileHandle(path, options);\n\n  const fd = await open(path, flag, 0o666);\n  return PromisePrototypeFinally(readFileHandle(fd, options), fd.close);\n}\n\nmodule.exports = {\n  exports: {\n    access,\n    copyFile,\n    open,\n    opendir: promisify(opendir),\n    rename,\n    truncate,\n    rm,\n    rmdir,\n    mkdir,\n    readdir,\n    readlink,\n    symlink,\n    lstat,\n    stat,\n    link,\n    unlink,\n    chmod,\n    lchmod,\n    lchown,\n    chown,\n    utimes,\n    lutimes,\n    realpath,\n    mkdtemp,\n    writeFile,\n    appendFile,\n    readFile,\n  },\n\n  FileHandle\n};\n"
  },
  {
    "url": "internal/fs/rimraf.js",
    "ranges": [
      {
        "start": 0,
        "end": 1137
      },
      {
        "start": 1597,
        "end": 1600
      },
      {
        "start": 2458,
        "end": 2461
      },
      {
        "start": 2896,
        "end": 2899
      },
      {
        "start": 3197,
        "end": 3200
      },
      {
        "start": 3872,
        "end": 3875
      },
      {
        "start": 4073,
        "end": 4076
      },
      {
        "start": 4781,
        "end": 4784
      },
      {
        "start": 5267,
        "end": 5270
      },
      {
        "start": 6540,
        "end": 6543
      },
      {
        "start": 6979,
        "end": 7039
      }
    ],
    "text": "// This file is a modified version of the rimraf module on npm. It has been\n// modified in the following ways:\n// - Use of the assert module has been replaced with core's error system.\n// - All code related to the glob dependency has been removed.\n// - Bring your own custom fs module is not currently supported.\n// - Some basic code cleanup.\n'use strict';\n\nconst {\n  Promise,\n  Set,\n} = primordials;\n\nconst { Buffer } = require('buffer');\nconst fs = require('fs');\nconst {\n  chmod,\n  chmodSync,\n  lstat,\n  lstatSync,\n  readdir,\n  readdirSync,\n  rmdir,\n  rmdirSync,\n  stat,\n  statSync,\n  unlink,\n  unlinkSync\n} = fs;\nconst { sep } = require('path');\nconst { setTimeout } = require('timers');\nconst { sleep } = require('internal/util');\nconst notEmptyErrorCodes = new Set(['ENOTEMPTY', 'EEXIST', 'EPERM']);\nconst retryErrorCodes = new Set(\n  ['EBUSY', 'EMFILE', 'ENFILE', 'ENOTEMPTY', 'EPERM']);\nconst isWindows = process.platform === 'win32';\nconst epermHandler = isWindows ? fixWinEPERM : _rmdir;\nconst epermHandlerSync = isWindows ? fixWinEPERMSync : _rmdirSync;\nconst readdirEncoding = 'buffer';\nconst separator = Buffer.from(sep);\n\n\nfunction rimraf(path, options, callback) {\n  let retries = 0;\n\n  _rimraf(path, options, function CB(err) {\n    if (err) {\n      if (retryErrorCodes.has(err.code) && retries < options.maxRetries) {\n        retries++;\n        const delay = retries * options.retryDelay;\n        return setTimeout(_rimraf, delay, path, options, CB);\n      }\n\n      // The file is already gone.\n      if (err.code === 'ENOENT')\n        err = null;\n    }\n\n    callback(err);\n  });\n}\n\n\nfunction _rimraf(path, options, callback) {\n  // SunOS lets the root user unlink directories. Use lstat here to make sure\n  // it's not a directory.\n  lstat(path, (err, stats) => {\n    if (err) {\n      if (err.code === 'ENOENT')\n        return callback(null);\n\n      // Windows can EPERM on stat.\n      if (isWindows && err.code === 'EPERM')\n        return fixWinEPERM(path, options, err, callback);\n    } else if (stats.isDirectory()) {\n      return _rmdir(path, options, err, callback);\n    }\n\n    unlink(path, (err) => {\n      if (err) {\n        if (err.code === 'ENOENT')\n          return callback(null);\n        if (err.code === 'EISDIR')\n          return _rmdir(path, options, err, callback);\n        if (err.code === 'EPERM') {\n          return epermHandler(path, options, err, callback);\n        }\n      }\n\n      return callback(err);\n    });\n  });\n}\n\n\nfunction fixWinEPERM(path, options, originalErr, callback) {\n  chmod(path, 0o666, (err) => {\n    if (err)\n      return callback(err.code === 'ENOENT' ? null : originalErr);\n\n    stat(path, (err, stats) => {\n      if (err)\n        return callback(err.code === 'ENOENT' ? null : originalErr);\n\n      if (stats.isDirectory())\n        _rmdir(path, options, originalErr, callback);\n      else\n        unlink(path, callback);\n    });\n  });\n}\n\n\nfunction _rmdir(path, options, originalErr, callback) {\n  rmdir(path, (err) => {\n    if (err) {\n      if (notEmptyErrorCodes.has(err.code))\n        return _rmchildren(path, options, callback);\n      if (err.code === 'ENOTDIR')\n        return callback(originalErr);\n    }\n\n    callback(err);\n  });\n}\n\n\nfunction _rmchildren(path, options, callback) {\n  const pathBuf = Buffer.from(path);\n\n  readdir(pathBuf, readdirEncoding, (err, files) => {\n    if (err)\n      return callback(err);\n\n    let numFiles = files.length;\n\n    if (numFiles === 0)\n      return rmdir(path, callback);\n\n    let done = false;\n\n    files.forEach((child) => {\n      const childPath = Buffer.concat([pathBuf, separator, child]);\n\n      rimraf(childPath, options, (err) => {\n        if (done)\n          return;\n\n        if (err) {\n          done = true;\n          return callback(err);\n        }\n\n        numFiles--;\n        if (numFiles === 0)\n          rmdir(path, callback);\n      });\n    });\n  });\n}\n\n\nfunction rimrafPromises(path, options) {\n  return new Promise((resolve, reject) => {\n    rimraf(path, options, (err) => {\n      if (err)\n        return reject(err);\n\n      resolve();\n    });\n  });\n}\n\n\nfunction rimrafSync(path, options) {\n  let stats;\n\n  try {\n    stats = lstatSync(path);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n\n    // Windows can EPERM on stat.\n    if (isWindows && err.code === 'EPERM')\n      fixWinEPERMSync(path, options, err);\n  }\n\n  try {\n    // SunOS lets the root user unlink directories.\n    if (stats !== undefined && stats.isDirectory())\n      _rmdirSync(path, options, null);\n    else\n      _unlinkSync(path, options);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n    if (err.code === 'EPERM')\n      return epermHandlerSync(path, options, err);\n    if (err.code !== 'EISDIR')\n      throw err;\n\n    _rmdirSync(path, options, err);\n  }\n}\n\n\nfunction _unlinkSync(path, options) {\n  const tries = options.maxRetries + 1;\n\n  for (let i = 1; i <= tries; i++) {\n    try {\n      return unlinkSync(path);\n    } catch (err) {\n      // Only sleep if this is not the last try, and the delay is greater\n      // than zero, and an error was encountered that warrants a retry.\n      if (retryErrorCodes.has(err.code) &&\n          i < tries &&\n          options.retryDelay > 0) {\n        sleep(i * options.retryDelay);\n      }\n    }\n  }\n}\n\n\nfunction _rmdirSync(path, options, originalErr) {\n  try {\n    rmdirSync(path);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n    if (err.code === 'ENOTDIR')\n      throw originalErr;\n\n    if (notEmptyErrorCodes.has(err.code)) {\n      // Removing failed. Try removing all children and then retrying the\n      // original removal. Windows has a habit of not closing handles promptly\n      // when files are deleted, resulting in spurious ENOTEMPTY failures. Work\n      // around that issue by retrying on Windows.\n      const pathBuf = Buffer.from(path);\n\n      readdirSync(pathBuf, readdirEncoding).forEach((child) => {\n        const childPath = Buffer.concat([pathBuf, separator, child]);\n\n        rimrafSync(childPath, options);\n      });\n\n      const tries = options.maxRetries + 1;\n\n      for (let i = 1; i <= tries; i++) {\n        try {\n          return fs.rmdirSync(path);\n        } catch (err) {\n          // Only sleep if this is not the last try, and the delay is greater\n          // than zero, and an error was encountered that warrants a retry.\n          if (retryErrorCodes.has(err.code) &&\n              i < tries &&\n              options.retryDelay > 0) {\n            sleep(i * options.retryDelay);\n          }\n        }\n      }\n    }\n  }\n}\n\n\nfunction fixWinEPERMSync(path, options, originalErr) {\n  try {\n    chmodSync(path, 0o666);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n\n    throw originalErr;\n  }\n\n  let stats;\n\n  try {\n    stats = statSync(path);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n\n    throw originalErr;\n  }\n\n  if (stats.isDirectory())\n    _rmdirSync(path, options, originalErr);\n  else\n    _unlinkSync(path, options);\n}\n\n\nmodule.exports = { rimraf, rimrafPromises, rimrafSync };\n"
  },
  {
    "url": "internal/fs/utils.js",
    "ranges": [
      {
        "start": 0,
        "end": 2473
      },
      {
        "start": 2552,
        "end": 2554
      },
      {
        "start": 2701,
        "end": 2720
      },
      {
        "start": 2795,
        "end": 2799
      },
      {
        "start": 2860,
        "end": 2864
      },
      {
        "start": 2921,
        "end": 2925
      },
      {
        "start": 2990,
        "end": 2994
      },
      {
        "start": 3062,
        "end": 3066
      },
      {
        "start": 3131,
        "end": 3135
      },
      {
        "start": 3192,
        "end": 3196
      },
      {
        "start": 3257,
        "end": 3302
      },
      {
        "start": 3381,
        "end": 3526
      },
      {
        "start": 3575,
        "end": 3580
      },
      {
        "start": 3708,
        "end": 3758
      },
      {
        "start": 4365,
        "end": 4367
      },
      {
        "start": 5462,
        "end": 5464
      },
      {
        "start": 6186,
        "end": 6188
      },
      {
        "start": 6728,
        "end": 6730
      },
      {
        "start": 7259,
        "end": 7400
      },
      {
        "start": 7953,
        "end": 7957
      },
      {
        "start": 8628,
        "end": 8661
      },
      {
        "start": 8968,
        "end": 9004
      },
      {
        "start": 9061,
        "end": 9093
      },
      {
        "start": 9150,
        "end": 9189
      },
      {
        "start": 9246,
        "end": 9289
      },
      {
        "start": 9346,
        "end": 9386
      },
      {
        "start": 9443,
        "end": 9475
      },
      {
        "start": 9532,
        "end": 9566
      },
      {
        "start": 9624,
        "end": 9749
      },
      {
        "start": 9831,
        "end": 9833
      },
      {
        "start": 9916,
        "end": 10265
      },
      {
        "start": 10329,
        "end": 10331
      },
      {
        "start": 11067,
        "end": 11225
      },
      {
        "start": 11471,
        "end": 11474
      },
      {
        "start": 11991,
        "end": 12332
      },
      {
        "start": 12562,
        "end": 12565
      },
      {
        "start": 13643,
        "end": 13645
      },
      {
        "start": 14853,
        "end": 14899
      },
      {
        "start": 15259,
        "end": 15321
      },
      {
        "start": 15764,
        "end": 15818
      },
      {
        "start": 16197,
        "end": 16255
      },
      {
        "start": 16529,
        "end": 16571
      },
      {
        "start": 16841,
        "end": 16886
      },
      {
        "start": 17021,
        "end": 17069
      },
      {
        "start": 17400,
        "end": 17441
      },
      {
        "start": 17899,
        "end": 18135
      },
      {
        "start": 18755,
        "end": 18805
      },
      {
        "start": 19387,
        "end": 19439
      },
      {
        "start": 19921,
        "end": 19962
      },
      {
        "start": 20540,
        "end": 20603
      },
      {
        "start": 20975,
        "end": 21593
      }
    ],
    "text": "'use strict';\n\nconst {\n  ArrayIsArray,\n  BigInt,\n  DateNow,\n  ErrorCaptureStackTrace,\n  ObjectPrototypeHasOwnProperty,\n  Number,\n  NumberIsFinite,\n  MathMin,\n  ObjectSetPrototypeOf,\n  ReflectOwnKeys,\n  Symbol,\n} = primordials;\n\nconst { Buffer } = require('buffer');\nconst {\n  codes: {\n    ERR_FS_EISDIR,\n    ERR_FS_INVALID_SYMLINK_TYPE,\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_ARG_VALUE,\n    ERR_INVALID_OPT_VALUE,\n    ERR_INVALID_OPT_VALUE_ENCODING,\n    ERR_OUT_OF_RANGE\n  },\n  hideStackFrames,\n  uvException\n} = require('internal/errors');\nconst {\n  isArrayBufferView,\n  isUint8Array,\n  isDate,\n  isBigUint64Array\n} = require('internal/util/types');\nconst { once } = require('internal/util');\nconst { toPathIfFileURL } = require('internal/url');\nconst {\n  validateBoolean,\n  validateInt32,\n  validateUint32\n} = require('internal/validators');\nconst pathModule = require('path');\nconst kType = Symbol('type');\nconst kStats = Symbol('stats');\nconst assert = require('internal/assert');\n\nconst {\n  fs: {\n    F_OK = 0,\n    W_OK = 0,\n    R_OK = 0,\n    X_OK = 0,\n    COPYFILE_EXCL,\n    COPYFILE_FICLONE,\n    COPYFILE_FICLONE_FORCE,\n    O_APPEND,\n    O_CREAT,\n    O_EXCL,\n    O_RDONLY,\n    O_RDWR,\n    O_SYNC,\n    O_TRUNC,\n    O_WRONLY,\n    S_IFBLK,\n    S_IFCHR,\n    S_IFDIR,\n    S_IFIFO,\n    S_IFLNK,\n    S_IFMT,\n    S_IFREG,\n    S_IFSOCK,\n    UV_FS_SYMLINK_DIR,\n    UV_FS_SYMLINK_JUNCTION,\n    UV_DIRENT_UNKNOWN,\n    UV_DIRENT_FILE,\n    UV_DIRENT_DIR,\n    UV_DIRENT_LINK,\n    UV_DIRENT_FIFO,\n    UV_DIRENT_SOCKET,\n    UV_DIRENT_CHAR,\n    UV_DIRENT_BLOCK\n  },\n  os: {\n    errno: {\n      EISDIR\n    }\n  }\n} = internalBinding('constants');\n\n// The access modes can be any of F_OK, R_OK, W_OK or X_OK. Some might not be\n// available on specific systems. They can be used in combination as well\n// (F_OK | R_OK | W_OK | X_OK).\nconst kMinimumAccessMode = MathMin(F_OK, W_OK, R_OK, X_OK);\nconst kMaximumAccessMode = F_OK | W_OK | R_OK | X_OK;\n\nconst kDefaultCopyMode = 0;\n// The copy modes can be any of COPYFILE_EXCL, COPYFILE_FICLONE or\n// COPYFILE_FICLONE_FORCE. They can be used in combination as well\n// (COPYFILE_EXCL | COPYFILE_FICLONE | COPYFILE_FICLONE_FORCE).\nconst kMinimumCopyMode = MathMin(\n  kDefaultCopyMode,\n  COPYFILE_EXCL,\n  COPYFILE_FICLONE,\n  COPYFILE_FICLONE_FORCE\n);\nconst kMaximumCopyMode = COPYFILE_EXCL |\n                         COPYFILE_FICLONE |\n                         COPYFILE_FICLONE_FORCE;\n\nconst isWindows = process.platform === 'win32';\n\nlet fs;\nfunction lazyLoadFs() {\n  if (!fs) {\n    fs = require('fs');\n  }\n  return fs;\n}\n\nfunction assertEncoding(encoding) {\n  if (encoding && !Buffer.isEncoding(encoding)) {\n    throw new ERR_INVALID_OPT_VALUE_ENCODING(encoding);\n  }\n}\n\nclass Dirent {\n  constructor(name, type) {\n    this.name = name;\n    this[kType] = type;\n  }\n\n  isDirectory() {\n    return this[kType] === UV_DIRENT_DIR;\n  }\n\n  isFile() {\n    return this[kType] === UV_DIRENT_FILE;\n  }\n\n  isBlockDevice() {\n    return this[kType] === UV_DIRENT_BLOCK;\n  }\n\n  isCharacterDevice() {\n    return this[kType] === UV_DIRENT_CHAR;\n  }\n\n  isSymbolicLink() {\n    return this[kType] === UV_DIRENT_LINK;\n  }\n\n  isFIFO() {\n    return this[kType] === UV_DIRENT_FIFO;\n  }\n\n  isSocket() {\n    return this[kType] === UV_DIRENT_SOCKET;\n  }\n}\n\nclass DirentFromStats extends Dirent {\n  constructor(name, stats) {\n    super(name, null);\n    this[kStats] = stats;\n  }\n}\n\nfor (const name of ReflectOwnKeys(Dirent.prototype)) {\n  if (name === 'constructor') {\n    continue;\n  }\n  DirentFromStats.prototype[name] = function() {\n    return this[kStats][name]();\n  };\n}\n\nfunction copyObject(source) {\n  const target = {};\n  for (const key in source)\n    target[key] = source[key];\n  return target;\n}\n\nconst bufferSep = Buffer.from(pathModule.sep);\n\nfunction join(path, name) {\n  if ((typeof path === 'string' || isUint8Array(path)) &&\n      name === undefined) {\n    return path;\n  }\n\n  if (typeof path === 'string' && isUint8Array(name)) {\n    const pathBuffer = Buffer.from(pathModule.join(path, pathModule.sep));\n    return Buffer.concat([pathBuffer, name]);\n  }\n\n  if (typeof path === 'string' && typeof name === 'string') {\n    return pathModule.join(path, name);\n  }\n\n  if (isUint8Array(path) && isUint8Array(name)) {\n    return Buffer.concat([path, bufferSep, name]);\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    'path', ['string', 'Buffer'], path);\n}\n\nfunction getDirents(path, [names, types], callback) {\n  let i;\n  if (typeof callback === 'function') {\n    const len = names.length;\n    let toFinish = 0;\n    callback = once(callback);\n    for (i = 0; i < len; i++) {\n      const type = types[i];\n      if (type === UV_DIRENT_UNKNOWN) {\n        const name = names[i];\n        const idx = i;\n        toFinish++;\n        let filepath;\n        try {\n          filepath = join(path, name);\n        } catch (err) {\n          callback(err);\n          return;\n        }\n        lazyLoadFs().lstat(filepath, (err, stats) => {\n          if (err) {\n            callback(err);\n            return;\n          }\n          names[idx] = new DirentFromStats(name, stats);\n          if (--toFinish === 0) {\n            callback(null, names);\n          }\n        });\n      } else {\n        names[i] = new Dirent(names[i], types[i]);\n      }\n    }\n    if (toFinish === 0) {\n      callback(null, names);\n    }\n  } else {\n    const len = names.length;\n    for (i = 0; i < len; i++) {\n      names[i] = getDirent(path, names[i], types[i]);\n    }\n    return names;\n  }\n}\n\nfunction getDirent(path, name, type, callback) {\n  if (typeof callback === 'function') {\n    if (type === UV_DIRENT_UNKNOWN) {\n      let filepath;\n      try {\n        filepath = join(path, name);\n      } catch (err) {\n        callback(err);\n        return;\n      }\n      lazyLoadFs().lstat(filepath, (err, stats) => {\n        if (err) {\n          callback(err);\n          return;\n        }\n        callback(null, new DirentFromStats(name, stats));\n      });\n    } else {\n      callback(null, new Dirent(name, type));\n    }\n  } else if (type === UV_DIRENT_UNKNOWN) {\n    const stats = lazyLoadFs().lstatSync(join(path, name));\n    return new DirentFromStats(name, stats);\n  } else {\n    return new Dirent(name, type);\n  }\n}\n\nfunction getOptions(options, defaultOptions) {\n  if (options === null || options === undefined ||\n      typeof options === 'function') {\n    return defaultOptions;\n  }\n\n  if (typeof options === 'string') {\n    defaultOptions = { ...defaultOptions };\n    defaultOptions.encoding = options;\n    options = defaultOptions;\n  } else if (typeof options !== 'object') {\n    throw new ERR_INVALID_ARG_TYPE('options', ['string', 'Object'], options);\n  }\n\n  if (options.encoding !== 'buffer')\n    assertEncoding(options.encoding);\n  return options;\n}\n\nfunction handleErrorFromBinding(ctx) {\n  if (ctx.errno !== undefined) {  // libuv error numbers\n    const err = uvException(ctx);\n    ErrorCaptureStackTrace(err, handleErrorFromBinding);\n    throw err;\n  }\n  if (ctx.error !== undefined) {  // Errors created in C++ land.\n    // TODO(joyeecheung): currently, ctx.error are encoding errors\n    // usually caused by memory problems. We need to figure out proper error\n    // code(s) for this.\n    ErrorCaptureStackTrace(ctx.error, handleErrorFromBinding);\n    throw ctx.error;\n  }\n}\n\n// Check if the path contains null types if it is a string nor Uint8Array,\n// otherwise return silently.\nconst nullCheck = hideStackFrames((path, propName, throwError = true) => {\n  const pathIsString = typeof path === 'string';\n  const pathIsUint8Array = isUint8Array(path);\n\n  // We can only perform meaningful checks on strings and Uint8Arrays.\n  if ((!pathIsString && !pathIsUint8Array) ||\n      (pathIsString && !path.includes('\\u0000')) ||\n      (pathIsUint8Array && !path.includes(0))) {\n    return;\n  }\n\n  const err = new ERR_INVALID_ARG_VALUE(\n    propName,\n    path,\n    'must be a string or Uint8Array without null bytes'\n  );\n  if (throwError) {\n    throw err;\n  }\n  return err;\n});\n\nfunction preprocessSymlinkDestination(path, type, linkPath) {\n  if (!isWindows) {\n    // No preprocessing is needed on Unix.\n    return path;\n  }\n  if (type === 'junction') {\n    // Junctions paths need to be absolute and \\\\?\\-prefixed.\n    // A relative target is relative to the link's parent directory.\n    path = pathModule.resolve(linkPath, '..', path);\n    return pathModule.toNamespacedPath(path);\n  }\n  if (pathModule.isAbsolute(path)) {\n    // If the path is absolute, use the \\\\?\\-prefix to enable long filenames\n    return pathModule.toNamespacedPath(path);\n  }\n  // Windows symlinks don't tolerate forward slashes.\n  return ('' + path).replace(/\\//g, '\\\\');\n}\n\n// Constructor for file stats.\nfunction StatsBase(dev, mode, nlink, uid, gid, rdev, blksize,\n                   ino, size, blocks) {\n  this.dev = dev;\n  this.mode = mode;\n  this.nlink = nlink;\n  this.uid = uid;\n  this.gid = gid;\n  this.rdev = rdev;\n  this.blksize = blksize;\n  this.ino = ino;\n  this.size = size;\n  this.blocks = blocks;\n}\n\nStatsBase.prototype.isDirectory = function() {\n  return this._checkModeProperty(S_IFDIR);\n};\n\nStatsBase.prototype.isFile = function() {\n  return this._checkModeProperty(S_IFREG);\n};\n\nStatsBase.prototype.isBlockDevice = function() {\n  return this._checkModeProperty(S_IFBLK);\n};\n\nStatsBase.prototype.isCharacterDevice = function() {\n  return this._checkModeProperty(S_IFCHR);\n};\n\nStatsBase.prototype.isSymbolicLink = function() {\n  return this._checkModeProperty(S_IFLNK);\n};\n\nStatsBase.prototype.isFIFO = function() {\n  return this._checkModeProperty(S_IFIFO);\n};\n\nStatsBase.prototype.isSocket = function() {\n  return this._checkModeProperty(S_IFSOCK);\n};\n\nconst kNsPerMsBigInt = 10n ** 6n;\nconst kNsPerSecBigInt = 10n ** 9n;\nconst kMsPerSec = 10 ** 3;\nconst kNsPerMs = 10 ** 6;\nfunction msFromTimeSpec(sec, nsec) {\n  return sec * kMsPerSec + nsec / kNsPerMs;\n}\n\nfunction nsFromTimeSpecBigInt(sec, nsec) {\n  return sec * kNsPerSecBigInt + nsec;\n}\n\n// The Date constructor performs Math.floor() to the timestamp.\n// https://www.ecma-international.org/ecma-262/#sec-timeclip\n// Since there may be a precision loss when the timestamp is\n// converted to a floating point number, we manually round\n// the timestamp here before passing it to Date().\n// Refs: https://github.com/nodejs/node/pull/12607\nfunction dateFromMs(ms) {\n  return new Date(Number(ms) + 0.5);\n}\n\nfunction BigIntStats(dev, mode, nlink, uid, gid, rdev, blksize,\n                     ino, size, blocks,\n                     atimeNs, mtimeNs, ctimeNs, birthtimeNs) {\n  StatsBase.call(this, dev, mode, nlink, uid, gid, rdev, blksize,\n                 ino, size, blocks);\n\n  this.atimeMs = atimeNs / kNsPerMsBigInt;\n  this.mtimeMs = mtimeNs / kNsPerMsBigInt;\n  this.ctimeMs = ctimeNs / kNsPerMsBigInt;\n  this.birthtimeMs = birthtimeNs / kNsPerMsBigInt;\n  this.atimeNs = atimeNs;\n  this.mtimeNs = mtimeNs;\n  this.ctimeNs = ctimeNs;\n  this.birthtimeNs = birthtimeNs;\n  this.atime = dateFromMs(this.atimeMs);\n  this.mtime = dateFromMs(this.mtimeMs);\n  this.ctime = dateFromMs(this.ctimeMs);\n  this.birthtime = dateFromMs(this.birthtimeMs);\n}\n\nObjectSetPrototypeOf(BigIntStats.prototype, StatsBase.prototype);\nObjectSetPrototypeOf(BigIntStats, StatsBase);\n\nBigIntStats.prototype._checkModeProperty = function(property) {\n  if (isWindows && (property === S_IFIFO || property === S_IFBLK ||\n    property === S_IFSOCK)) {\n    return false;  // Some types are not available on Windows\n  }\n  return (this.mode & BigInt(S_IFMT)) === BigInt(property);\n};\n\nfunction Stats(dev, mode, nlink, uid, gid, rdev, blksize,\n               ino, size, blocks,\n               atimeMs, mtimeMs, ctimeMs, birthtimeMs) {\n  StatsBase.call(this, dev, mode, nlink, uid, gid, rdev, blksize,\n                 ino, size, blocks);\n  this.atimeMs = atimeMs;\n  this.mtimeMs = mtimeMs;\n  this.ctimeMs = ctimeMs;\n  this.birthtimeMs = birthtimeMs;\n  this.atime = dateFromMs(atimeMs);\n  this.mtime = dateFromMs(mtimeMs);\n  this.ctime = dateFromMs(ctimeMs);\n  this.birthtime = dateFromMs(birthtimeMs);\n}\n\nObjectSetPrototypeOf(Stats.prototype, StatsBase.prototype);\nObjectSetPrototypeOf(Stats, StatsBase);\n\n// HACK: Workaround for https://github.com/standard-things/esm/issues/821.\n// TODO(ronag): Remove this as soon as `esm` publishes a fixed version.\nStats.prototype.isFile = StatsBase.prototype.isFile;\n\nStats.prototype._checkModeProperty = function(property) {\n  if (isWindows && (property === S_IFIFO || property === S_IFBLK ||\n    property === S_IFSOCK)) {\n    return false;  // Some types are not available on Windows\n  }\n  return (this.mode & S_IFMT) === property;\n};\n\nfunction getStatsFromBinding(stats, offset = 0) {\n  if (isBigUint64Array(stats)) {\n    return new BigIntStats(\n      stats[0 + offset], stats[1 + offset], stats[2 + offset],\n      stats[3 + offset], stats[4 + offset], stats[5 + offset],\n      stats[6 + offset], stats[7 + offset], stats[8 + offset],\n      stats[9 + offset],\n      nsFromTimeSpecBigInt(stats[10 + offset], stats[11 + offset]),\n      nsFromTimeSpecBigInt(stats[12 + offset], stats[13 + offset]),\n      nsFromTimeSpecBigInt(stats[14 + offset], stats[15 + offset]),\n      nsFromTimeSpecBigInt(stats[16 + offset], stats[17 + offset])\n    );\n  }\n  return new Stats(\n    stats[0 + offset], stats[1 + offset], stats[2 + offset],\n    stats[3 + offset], stats[4 + offset], stats[5 + offset],\n    stats[6 + offset], stats[7 + offset], stats[8 + offset],\n    stats[9 + offset],\n    msFromTimeSpec(stats[10 + offset], stats[11 + offset]),\n    msFromTimeSpec(stats[12 + offset], stats[13 + offset]),\n    msFromTimeSpec(stats[14 + offset], stats[15 + offset]),\n    msFromTimeSpec(stats[16 + offset], stats[17 + offset])\n  );\n}\n\nfunction stringToFlags(flags) {\n  if (typeof flags === 'number') {\n    return flags;\n  }\n\n  if (flags == null) {\n    return O_RDONLY;\n  }\n\n  switch (flags) {\n    case 'r' : return O_RDONLY;\n    case 'rs' : // Fall through.\n    case 'sr' : return O_RDONLY | O_SYNC;\n    case 'r+' : return O_RDWR;\n    case 'rs+' : // Fall through.\n    case 'sr+' : return O_RDWR | O_SYNC;\n\n    case 'w' : return O_TRUNC | O_CREAT | O_WRONLY;\n    case 'wx' : // Fall through.\n    case 'xw' : return O_TRUNC | O_CREAT | O_WRONLY | O_EXCL;\n\n    case 'w+' : return O_TRUNC | O_CREAT | O_RDWR;\n    case 'wx+': // Fall through.\n    case 'xw+': return O_TRUNC | O_CREAT | O_RDWR | O_EXCL;\n\n    case 'a' : return O_APPEND | O_CREAT | O_WRONLY;\n    case 'ax' : // Fall through.\n    case 'xa' : return O_APPEND | O_CREAT | O_WRONLY | O_EXCL;\n    case 'as' : // Fall through.\n    case 'sa' : return O_APPEND | O_CREAT | O_WRONLY | O_SYNC;\n\n    case 'a+' : return O_APPEND | O_CREAT | O_RDWR;\n    case 'ax+': // Fall through.\n    case 'xa+': return O_APPEND | O_CREAT | O_RDWR | O_EXCL;\n    case 'as+': // Fall through.\n    case 'sa+': return O_APPEND | O_CREAT | O_RDWR | O_SYNC;\n  }\n\n  throw new ERR_INVALID_OPT_VALUE('flags', flags);\n}\n\nconst stringToSymlinkType = hideStackFrames((type) => {\n  let flags = 0;\n  if (typeof type === 'string') {\n    switch (type) {\n      case 'dir':\n        flags |= UV_FS_SYMLINK_DIR;\n        break;\n      case 'junction':\n        flags |= UV_FS_SYMLINK_JUNCTION;\n        break;\n      case 'file':\n        break;\n      default:\n        throw new ERR_FS_INVALID_SYMLINK_TYPE(type);\n    }\n  }\n  return flags;\n});\n\n// converts Date or number to a fractional UNIX timestamp\nfunction toUnixTimestamp(time, name = 'time') {\n  // eslint-disable-next-line eqeqeq\n  if (typeof time === 'string' && +time == time) {\n    return +time;\n  }\n  if (NumberIsFinite(time)) {\n    if (time < 0) {\n      return DateNow() / 1000;\n    }\n    return time;\n  }\n  if (isDate(time)) {\n    // Convert to 123.456 UNIX timestamp\n    return time.getTime() / 1000;\n  }\n  throw new ERR_INVALID_ARG_TYPE(name, ['Date', 'Time in seconds'], time);\n}\n\nconst validateOffsetLengthRead = hideStackFrames(\n  (offset, length, bufferLength) => {\n    if (offset < 0) {\n      throw new ERR_OUT_OF_RANGE('offset', '>= 0', offset);\n    }\n    if (length < 0) {\n      throw new ERR_OUT_OF_RANGE('length', '>= 0', length);\n    }\n    if (offset + length > bufferLength) {\n      throw new ERR_OUT_OF_RANGE('length',\n                                 `<= ${bufferLength - offset}`, length);\n    }\n  }\n);\n\nconst validateOffsetLengthWrite = hideStackFrames(\n  (offset, length, byteLength) => {\n    if (offset > byteLength) {\n      throw new ERR_OUT_OF_RANGE('offset', `<= ${byteLength}`, offset);\n    }\n\n    if (length > byteLength - offset) {\n      throw new ERR_OUT_OF_RANGE('length', `<= ${byteLength - offset}`, length);\n    }\n  }\n);\n\nconst validatePath = hideStackFrames((path, propName = 'path') => {\n  if (typeof path !== 'string' && !isUint8Array(path)) {\n    throw new ERR_INVALID_ARG_TYPE(propName, ['string', 'Buffer', 'URL'], path);\n  }\n\n  const err = nullCheck(path, propName, false);\n\n  if (err !== undefined) {\n    throw err;\n  }\n});\n\nconst getValidatedPath = hideStackFrames((fileURLOrPath, propName = 'path') => {\n  const path = toPathIfFileURL(fileURLOrPath);\n  validatePath(path, propName);\n  return path;\n});\n\nconst validateBufferArray = hideStackFrames((buffers, propName = 'buffers') => {\n  if (!ArrayIsArray(buffers))\n    throw new ERR_INVALID_ARG_TYPE(propName, 'ArrayBufferView[]', buffers);\n\n  for (let i = 0; i < buffers.length; i++) {\n    if (!isArrayBufferView(buffers[i]))\n      throw new ERR_INVALID_ARG_TYPE(propName, 'ArrayBufferView[]', buffers);\n  }\n\n  return buffers;\n});\n\nlet nonPortableTemplateWarn = true;\n\nfunction warnOnNonPortableTemplate(template) {\n  // Template strings passed to the mkdtemp() family of functions should not\n  // end with 'X' because they are handled inconsistently across platforms.\n  if (nonPortableTemplateWarn && template.endsWith('X')) {\n    process.emitWarning('mkdtemp() templates ending with X are not portable. ' +\n                        'For details see: https://nodejs.org/api/fs.html');\n    nonPortableTemplateWarn = false;\n  }\n}\n\nconst defaultRmOptions = {\n  recursive: false,\n  force: false,\n  retryDelay: 100,\n  maxRetries: 0\n};\n\nconst defaultRmdirOptions = {\n  retryDelay: 100,\n  maxRetries: 0,\n  recursive: false,\n};\n\nconst validateRmOptions = hideStackFrames((path, options, callback) => {\n  options = validateRmdirOptions(options, defaultRmOptions);\n  validateBoolean(options.force, 'options.force');\n\n  lazyLoadFs().stat(path, (err, stats) => {\n    if (err) {\n      if (options.force && err.code === 'ENOENT') {\n        return callback(null, options);\n      }\n      return callback(err, options);\n    }\n\n    if (stats.isDirectory() && !options.recursive) {\n      return callback(new ERR_FS_EISDIR({\n        code: 'EISDIR',\n        message: 'is a directory',\n        path,\n        syscall: 'rm',\n        errno: EISDIR\n      }));\n    }\n    return callback(null, options);\n  });\n});\n\nconst validateRmOptionsSync = hideStackFrames((path, options) => {\n  options = validateRmdirOptions(options, defaultRmOptions);\n  validateBoolean(options.force, 'options.force');\n\n  try {\n    const stats = lazyLoadFs().statSync(path);\n\n    if (stats.isDirectory() && !options.recursive) {\n      throw new ERR_FS_EISDIR({\n        code: 'EISDIR',\n        message: 'is a directory',\n        path,\n        syscall: 'rm',\n        errno: EISDIR\n      });\n    }\n  } catch (err) {\n    if (err.code !== 'ENOENT') {\n      throw err;\n    } else if (err.code === 'ENOENT' && !options.force) {\n      throw err;\n    }\n  }\n\n  return options;\n});\n\nconst validateRmdirOptions = hideStackFrames(\n  (options, defaults = defaultRmdirOptions) => {\n    if (options === undefined)\n      return defaults;\n    if (options === null || typeof options !== 'object')\n      throw new ERR_INVALID_ARG_TYPE('options', 'object', options);\n\n    options = { ...defaults, ...options };\n\n    validateBoolean(options.recursive, 'options.recursive');\n    validateInt32(options.retryDelay, 'options.retryDelay', 0);\n    validateUint32(options.maxRetries, 'options.maxRetries');\n\n    return options;\n  });\n\nconst getValidMode = hideStackFrames((mode, type) => {\n  let min = kMinimumAccessMode;\n  let max = kMaximumAccessMode;\n  let def = F_OK;\n  if (type === 'copyFile') {\n    min = kMinimumCopyMode;\n    max = kMaximumCopyMode;\n    def = mode || kDefaultCopyMode;\n  } else {\n    assert(type === 'access');\n  }\n  if (mode == null) {\n    return def;\n  }\n  if (Number.isInteger(mode) && mode >= min && mode <= max) {\n    return mode;\n  }\n  if (typeof mode !== 'number') {\n    throw new ERR_INVALID_ARG_TYPE('mode', 'integer', mode);\n  }\n  throw new ERR_OUT_OF_RANGE(\n    'mode', `an integer >= ${min} && <= ${max}`, mode);\n});\n\nconst validateStringAfterArrayBufferView = hideStackFrames((buffer, name) => {\n  if (typeof buffer === 'string') {\n    return;\n  }\n\n  if (\n    typeof buffer === 'object' &&\n    buffer !== null &&\n    typeof buffer.toString === 'function' &&\n    ObjectPrototypeHasOwnProperty(buffer, 'toString')\n  ) {\n    return;\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    name,\n    ['string', 'Buffer', 'TypedArray', 'DataView'],\n    buffer\n  );\n});\n\nmodule.exports = {\n  assertEncoding,\n  BigIntStats,  // for testing\n  copyObject,\n  Dirent,\n  getDirent,\n  getDirents,\n  getOptions,\n  getValidatedPath,\n  getValidMode,\n  handleErrorFromBinding,\n  nullCheck,\n  preprocessSymlinkDestination,\n  realpathCacheKey: Symbol('realpathCacheKey'),\n  getStatsFromBinding,\n  stringToFlags,\n  stringToSymlinkType,\n  Stats,\n  toUnixTimestamp,\n  validateBufferArray,\n  validateOffsetLengthRead,\n  validateOffsetLengthWrite,\n  validatePath,\n  validateRmOptions,\n  validateRmOptionsSync,\n  validateRmdirOptions,\n  validateStringAfterArrayBufferView,\n  warnOnNonPortableTemplate\n};\n"
  },
  {
    "url": "internal/idna.js",
    "ranges": [
      {
        "start": 0,
        "end": 264
      }
    ],
    "text": "'use strict';\n\nif (internalBinding('config').hasIntl) {\n  const { toASCII, toUnicode } = internalBinding('icu');\n  module.exports = { toASCII, toUnicode };\n} else {\n  const { toASCII, toUnicode } = require('punycode');\n  module.exports = { toASCII, toUnicode };\n}\n"
  },
  {
    "url": "internal/inspector_async_hook.js",
    "ranges": [
      {
        "start": 0,
        "end": 75
      },
      {
        "start": 1257,
        "end": 1259
      },
      {
        "start": 1840,
        "end": 1842
      },
      {
        "start": 1928,
        "end": 1972
      }
    ],
    "text": "'use strict';\n\nlet hook;\nlet config;\n\nconst {\n  SafeSet,\n} = primordials;\n\nfunction lazyHookCreation() {\n  const inspector = internalBinding('inspector');\n  const { createHook } = require('async_hooks');\n  config = internalBinding('config');\n\n  hook = createHook({\n    init(asyncId, type, triggerAsyncId, resource) {\n    // It's difficult to tell which tasks will be recurring and which won't,\n    // therefore we mark all tasks as recurring. Based on the discussion\n    // in https://github.com/nodejs/node/pull/13870#discussion_r124515293,\n    // this should be fine as long as we call asyncTaskCanceled() too.\n      const recurring = true;\n      if (type === 'PROMISE')\n        this.promiseIds.add(asyncId);\n      else\n        inspector.asyncTaskScheduled(type, asyncId, recurring);\n    },\n\n    before(asyncId) {\n      if (this.promiseIds.has(asyncId))\n        return;\n      inspector.asyncTaskStarted(asyncId);\n    },\n\n    after(asyncId) {\n      if (this.promiseIds.has(asyncId))\n        return;\n      inspector.asyncTaskFinished(asyncId);\n    },\n\n    destroy(asyncId) {\n      if (this.promiseIds.has(asyncId))\n        return this.promiseIds.delete(asyncId);\n      inspector.asyncTaskCanceled(asyncId);\n    },\n  });\n\n  hook.promiseIds = new SafeSet();\n}\n\nfunction enable() {\n  if (hook === undefined) lazyHookCreation();\n  if (config.bits < 64) {\n    // V8 Inspector stores task ids as (void*) pointers.\n    // async_hooks store ids as 64bit numbers.\n    // As a result, we cannot reliably translate async_hook ids to V8 async_task\n    // ids on 32bit platforms.\n    process.emitWarning(\n      'Warning: Async stack traces in debugger are not available ' +\n      `on ${config.bits}bit platforms. The feature is disabled.`,\n      {\n        code: 'INSPECTOR_ASYNC_STACK_TRACES_NOT_AVAILABLE',\n      });\n  } else {\n    hook.enable();\n  }\n}\n\nfunction disable() {\n  if (hook === undefined) lazyHookCreation();\n  hook.disable();\n}\n\nmodule.exports = {\n  enable,\n  disable\n};\n"
  },
  {
    "url": "internal/linkedlist.js",
    "ranges": [
      {
        "start": 0,
        "end": 15
      },
      {
        "start": 88,
        "end": 118
      },
      {
        "start": 210,
        "end": 245
      },
      {
        "start": 472,
        "end": 528
      },
      {
        "start": 980,
        "end": 982
      },
      {
        "start": 1042,
        "end": 1112
      }
    ],
    "text": "'use strict';\n\nfunction init(list) {\n  list._idleNext = list;\n  list._idlePrev = list;\n}\n\n// Show the most idle item.\nfunction peek(list) {\n  if (list._idlePrev === list) return null;\n  return list._idlePrev;\n}\n\n// Remove an item from its list.\nfunction remove(item) {\n  if (item._idleNext) {\n    item._idleNext._idlePrev = item._idlePrev;\n  }\n\n  if (item._idlePrev) {\n    item._idlePrev._idleNext = item._idleNext;\n  }\n\n  item._idleNext = null;\n  item._idlePrev = null;\n}\n\n// Remove an item from its list and place at the end.\nfunction append(list, item) {\n  if (item._idleNext || item._idlePrev) {\n    remove(item);\n  }\n\n  // Items are linked  with _idleNext -> (older) and _idlePrev -> (newer).\n  // Note: This linkage (next being older) may seem counter-intuitive at first.\n  item._idleNext = list._idleNext;\n  item._idlePrev = list;\n\n  // The list _idleNext points to tail (newest) and _idlePrev to head (oldest).\n  list._idleNext._idlePrev = item;\n  list._idleNext = item;\n}\n\nfunction isEmpty(list) {\n  return list._idleNext === list;\n}\n\nmodule.exports = {\n  init,\n  peek,\n  remove,\n  append,\n  isEmpty\n};\n"
  },
  {
    "url": "internal/main/run_main_module.js",
    "ranges": [
      {
        "start": 0,
        "end": 632
      }
    ],
    "text": "'use strict';\n\nconst {\n  prepareMainThreadExecution\n} = require('internal/bootstrap/pre_execution');\n\nprepareMainThreadExecution(true);\n\nmarkBootstrapComplete();\n\n// Note: this loads the module through the ESM loader if the module is\n// determined to be an ES module. This hangs from the CJS module loader\n// because we currently allow monkey-patching of the module loaders\n// in the preloaded scripts through require('module').\n// runMain here might be monkey-patched by users in --require.\n// XXX: the monkey-patchability here should probably be deprecated.\nrequire('internal/modules/cjs/loader').Module.runMain(process.argv[1]);\n"
  },
  {
    "url": "internal/modules/cjs/helpers.js",
    "ranges": [
      {
        "start": 0,
        "end": 1315
      },
      {
        "start": 3313,
        "end": 3498
      },
      {
        "start": 3624,
        "end": 3626
      },
      {
        "start": 5091,
        "end": 5093
      },
      {
        "start": 5281,
        "end": 5427
      }
    ],
    "text": "'use strict';\n\nconst {\n  ArrayPrototypeJoin,\n  ObjectDefineProperty,\n  ObjectPrototypeHasOwnProperty,\n  SafeMap,\n  SafeSet,\n} = primordials;\nconst {\n  ERR_MANIFEST_DEPENDENCY_MISSING,\n  ERR_UNKNOWN_BUILTIN_MODULE\n} = require('internal/errors').codes;\nconst { NativeModule } = require('internal/bootstrap/loaders');\n\nconst { validateString } = require('internal/validators');\nconst path = require('path');\nconst { pathToFileURL, fileURLToPath } = require('internal/url');\nconst { URL } = require('url');\n\nconst { getOptionValue } = require('internal/options');\nconst userConditions = getOptionValue('--conditions');\n\nlet debug = require('internal/util/debuglog').debuglog('module', (fn) => {\n  debug = fn;\n});\n\n// TODO: Use this set when resolving pkg#exports conditions in loader.js.\nconst cjsConditions = new SafeSet(['require', 'node', ...userConditions]);\n\nfunction loadNativeModule(filename, request) {\n  const mod = NativeModule.map.get(filename);\n  if (mod) {\n    debug('load native module %s', request);\n    mod.compileForPublicLoader();\n    return mod;\n  }\n}\n\n// Invoke with makeRequireFunction(module) where |module| is the Module object\n// to use as the context for the require() function.\n// Use redirects to set up a mapping from a policy and restrict dependencies\nconst urlToFileCache = new SafeMap();\nfunction makeRequireFunction(mod, redirects) {\n  const Module = mod.constructor;\n\n  let require;\n  if (redirects) {\n    const id = mod.filename || mod.id;\n    const conditions = cjsConditions;\n    const { resolve, reaction } = redirects;\n    require = function require(specifier) {\n      let missing = true;\n      const destination = resolve(specifier, conditions);\n      if (destination === true) {\n        missing = false;\n      } else if (destination) {\n        const href = destination.href;\n        if (destination.protocol === 'node:') {\n          const specifier = destination.pathname;\n          const mod = loadNativeModule(specifier, href);\n          if (mod && mod.canBeRequiredByUsers) {\n            return mod.exports;\n          }\n          throw new ERR_UNKNOWN_BUILTIN_MODULE(specifier);\n        } else if (destination.protocol === 'file:') {\n          let filepath;\n          if (urlToFileCache.has(href)) {\n            filepath = urlToFileCache.get(href);\n          } else {\n            filepath = fileURLToPath(destination);\n            urlToFileCache.set(href, filepath);\n          }\n          return mod.require(filepath);\n        }\n      }\n      if (missing) {\n        reaction(new ERR_MANIFEST_DEPENDENCY_MISSING(\n          id,\n          specifier,\n          ArrayPrototypeJoin([...conditions], ', ')\n        ));\n      }\n      return mod.require(specifier);\n    };\n  } else {\n    require = function require(path) {\n      return mod.require(path);\n    };\n  }\n\n  function resolve(request, options) {\n    validateString(request, 'request');\n    return Module._resolveFilename(request, mod, false, options);\n  }\n\n  require.resolve = resolve;\n\n  function paths(request) {\n    validateString(request, 'request');\n    return Module._resolveLookupPaths(request, mod);\n  }\n\n  resolve.paths = paths;\n\n  require.main = process.mainModule;\n\n  // Enable support to add extra extension types.\n  require.extensions = Module._extensions;\n\n  require.cache = Module._cache;\n\n  return require;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n * because the buffer-to-string conversion in `fs.readFileSync()`\n * translates it to FEFF, the UTF-16 BOM.\n */\nfunction stripBOM(content) {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\nfunction addBuiltinLibsToObject(object) {\n  // Make built-in modules available directly (loaded lazily).\n  const { builtinModules } = require('internal/modules/cjs/loader').Module;\n  builtinModules.forEach((name) => {\n    // Neither add underscored modules, nor ones that contain slashes (e.g.,\n    // 'fs/promises') or ones that are already defined.\n    if (name.startsWith('_') ||\n        name.includes('/') ||\n        ObjectPrototypeHasOwnProperty(object, name)) {\n      return;\n    }\n    // Goals of this mechanism are:\n    // - Lazy loading of built-in modules\n    // - Having all built-in modules available as non-enumerable properties\n    // - Allowing the user to re-assign these variables as if there were no\n    //   pre-existing globals with the same name.\n\n    const setReal = (val) => {\n      // Deleting the property before re-assigning it disables the\n      // getter/setter mechanism.\n      delete object[name];\n      object[name] = val;\n    };\n\n    ObjectDefineProperty(object, name, {\n      get: () => {\n        const lib = require(name);\n\n        // Disable the current getter/setter and set up a new\n        // non-enumerable property.\n        delete object[name];\n        ObjectDefineProperty(object, name, {\n          get: () => lib,\n          set: setReal,\n          configurable: true,\n          enumerable: false\n        });\n\n        return lib;\n      },\n      set: setReal,\n      configurable: true,\n      enumerable: false\n    });\n  });\n}\n\nfunction normalizeReferrerURL(referrer) {\n  if (typeof referrer === 'string' && path.isAbsolute(referrer)) {\n    return pathToFileURL(referrer).href;\n  }\n  return new URL(referrer).href;\n}\n\nmodule.exports = {\n  addBuiltinLibsToObject,\n  cjsConditions,\n  loadNativeModule,\n  makeRequireFunction,\n  normalizeReferrerURL,\n  stripBOM,\n};\n"
  },
  {
    "url": "internal/modules/cjs/loader.js",
    "ranges": [
      {
        "start": 0,
        "end": 5741
      },
      {
        "start": 5818,
        "end": 5963
      },
      {
        "start": 6085,
        "end": 6090
      },
      {
        "start": 6223,
        "end": 6270
      },
      {
        "start": 6298,
        "end": 6303
      },
      {
        "start": 6357,
        "end": 6407
      },
      {
        "start": 6443,
        "end": 6581
      },
      {
        "start": 6606,
        "end": 6954
      },
      {
        "start": 7764,
        "end": 7766
      },
      {
        "start": 8309,
        "end": 8311
      },
      {
        "start": 9612,
        "end": 10165
      },
      {
        "start": 10296,
        "end": 10666
      },
      {
        "start": 11102,
        "end": 11104
      },
      {
        "start": 11393,
        "end": 11395
      },
      {
        "start": 12244,
        "end": 12405
      },
      {
        "start": 13143,
        "end": 16080
      },
      {
        "start": 17471,
        "end": 17563
      },
      {
        "start": 18604,
        "end": 18638
      },
      {
        "start": 19776,
        "end": 19779
      },
      {
        "start": 19962,
        "end": 20155
      },
      {
        "start": 20527,
        "end": 20532
      },
      {
        "start": 20773,
        "end": 20974
      },
      {
        "start": 21624,
        "end": 27947
      },
      {
        "start": 28661,
        "end": 28663
      },
      {
        "start": 28953,
        "end": 29042
      },
      {
        "start": 29846,
        "end": 29964
      },
      {
        "start": 30263,
        "end": 30443
      },
      {
        "start": 31559,
        "end": 31759
      },
      {
        "start": 34026,
        "end": 34085
      },
      {
        "start": 34859,
        "end": 34923
      },
      {
        "start": 35287,
        "end": 35351
      },
      {
        "start": 35669,
        "end": 35672
      },
      {
        "start": 36097,
        "end": 36382
      },
      {
        "start": 36935,
        "end": 37706
      },
      {
        "start": 37763,
        "end": 37923
      },
      {
        "start": 38429,
        "end": 38463
      },
      {
        "start": 38619,
        "end": 38673
      }
    ],
    "text": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayIsArray,\n  ArrayPrototypeJoin,\n  Error,\n  JSONParse,\n  Map,\n  ObjectCreate,\n  ObjectDefineProperty,\n  ObjectFreeze,\n  ObjectGetOwnPropertyDescriptor,\n  ObjectGetPrototypeOf,\n  ObjectKeys,\n  ObjectPrototypeHasOwnProperty,\n  ObjectSetPrototypeOf,\n  ReflectSet,\n  RegExpPrototypeTest,\n  SafeMap,\n  SafeWeakMap,\n  String,\n  StringPrototypeEndsWith,\n  StringPrototypeLastIndexOf,\n  StringPrototypeIndexOf,\n  StringPrototypeMatch,\n  StringPrototypeSlice,\n  StringPrototypeStartsWith,\n} = primordials;\n\n// Map used to store CJS parsing data.\nconst cjsParseCache = new SafeWeakMap();\n\n// Set first due to cycle with ESM loader functions.\nmodule.exports = {\n  wrapSafe, Module, toRealPath, readPackageScope, cjsParseCache,\n  get hasLoadedAnyUserCJSModule() { return hasLoadedAnyUserCJSModule; }\n};\n\nconst { NativeModule } = require('internal/bootstrap/loaders');\nconst {\n  maybeCacheSourceMap,\n  rekeySourceMap\n} = require('internal/source_map/source_map_cache');\nconst { pathToFileURL, fileURLToPath, isURLInstance } = require('internal/url');\nconst { deprecate } = require('internal/util');\nconst vm = require('vm');\nconst assert = require('internal/assert');\nconst fs = require('fs');\nconst internalFS = require('internal/fs/utils');\nconst path = require('path');\nconst { sep } = path;\nconst internalFsBinding = internalBinding('fs');\nconst packageJsonReader = require('internal/modules/package_json_reader');\nconst { safeGetenv } = internalBinding('credentials');\nconst {\n  makeRequireFunction,\n  normalizeReferrerURL,\n  stripBOM,\n  cjsConditions,\n  loadNativeModule\n} = require('internal/modules/cjs/helpers');\nconst { getOptionValue } = require('internal/options');\nconst enableSourceMaps = getOptionValue('--enable-source-maps');\nconst preserveSymlinks = getOptionValue('--preserve-symlinks');\nconst preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\n// Do not eagerly grab .manifest, it may be in TDZ\nconst policy = getOptionValue('--experimental-policy') ?\n  require('internal/process/policy') :\n  null;\nconst { compileFunction } = internalBinding('contextify');\n\n// Whether any user-provided CJS modules had been loaded (executed).\n// Used for internal assertions.\nlet hasLoadedAnyUserCJSModule = false;\n\nconst {\n  ERR_INVALID_ARG_VALUE,\n  ERR_INVALID_OPT_VALUE,\n  ERR_INVALID_MODULE_SPECIFIER,\n  ERR_REQUIRE_ESM\n} = require('internal/errors').codes;\nconst { validateString } = require('internal/validators');\nconst pendingDeprecation = getOptionValue('--pending-deprecation');\n\nconst {\n  CHAR_FORWARD_SLASH,\n  CHAR_BACKWARD_SLASH,\n  CHAR_COLON\n} = require('internal/constants');\n\n// Store the \"global\" variable from global scope into a local scope, so we can\n// still reference it from this file even after we deleted the \"global\" variable\n// from the global scope.\nconst localGlobal = global;\n// Do the same for \"Buffer\".\nconst localBuffer = Buffer;\n\nconst {\n  isProxy\n} = require('internal/util/types');\n\nconst asyncESM = require('internal/process/esm_loader');\nconst { enrichCJSError } = require('internal/modules/esm/translators');\nconst { kEvaluated } = internalBinding('module_wrap');\nconst {\n  encodedSepRegEx,\n  packageExportsResolve,\n  packageImportsResolve\n} = require('internal/modules/esm/resolve');\n\nconst isWindows = process.platform === 'win32';\n\nconst relativeResolveCache = ObjectCreate(null);\n\nlet requireDepth = 0;\nlet statCache = null;\n\nfunction stat(filename) {\n  filename = path.toNamespacedPath(filename);\n  if (statCache !== null) {\n    const result = statCache.get(filename);\n    if (result !== undefined) return result;\n  }\n  const result = internalFsBinding.internalModuleStat(filename);\n  if (statCache !== null) statCache.set(filename, result);\n  return result;\n}\n\nfunction updateChildren(parent, child, scan) {\n  const children = parent && parent.children;\n  if (children && !(scan && children.includes(child)))\n    children.push(child);\n}\n\nfunction Module(id = '', parent) {\n  this.id = id;\n  this.path = path.dirname(id);\n  this.exports = {};\n  this.parent = parent;\n  updateChildren(parent, this, false);\n  this.filename = null;\n  this.loaded = false;\n  this.children = [];\n}\n\nconst builtinModules = [];\nfor (const [id, mod] of NativeModule.map) {\n  if (mod.canBeRequiredByUsers) {\n    builtinModules.push(id);\n  }\n}\n\nObjectFreeze(builtinModules);\nModule.builtinModules = builtinModules;\n\nModule._cache = ObjectCreate(null);\nModule._pathCache = ObjectCreate(null);\nModule._extensions = ObjectCreate(null);\nlet modulePaths = [];\nModule.globalPaths = [];\n\nlet patched = false;\n\n// eslint-disable-next-line func-style\nlet wrap = function(script) {\n  return Module.wrapper[0] + script + Module.wrapper[1];\n};\n\nconst wrapper = [\n  '(function (exports, require, module, __filename, __dirname) { ',\n  '\\n});'\n];\n\nlet wrapperProxy = new Proxy(wrapper, {\n  set(target, property, value, receiver) {\n    patched = true;\n    return ReflectSet(target, property, value, receiver);\n  },\n\n  defineProperty(target, property, descriptor) {\n    patched = true;\n    return ObjectDefineProperty(target, property, descriptor);\n  }\n});\n\nObjectDefineProperty(Module, 'wrap', {\n  get() {\n    return wrap;\n  },\n\n  set(value) {\n    patched = true;\n    wrap = value;\n  }\n});\n\nObjectDefineProperty(Module, 'wrapper', {\n  get() {\n    return wrapperProxy;\n  },\n\n  set(value) {\n    patched = true;\n    wrapperProxy = value;\n  }\n});\n\nlet debug = require('internal/util/debuglog').debuglog('module', (fn) => {\n  debug = fn;\n});\nModule._debug = deprecate(debug, 'Module._debug is deprecated.', 'DEP0077');\n\n// Given a module name, and a list of paths to test, returns the first\n// matching file in the following precedence.\n//\n// require(\"a.<ext>\")\n//   -> a.<ext>\n//\n// require(\"a\")\n//   -> a\n//   -> a.<ext>\n//   -> a/index.<ext>\n\nconst packageJsonCache = new SafeMap();\n\nfunction readPackage(requestPath) {\n  const jsonPath = path.resolve(requestPath, 'package.json');\n\n  const existing = packageJsonCache.get(jsonPath);\n  if (existing !== undefined) return existing;\n\n  const result = packageJsonReader.read(jsonPath);\n  const json = result.containsKeys === false ? '{}' : result.string;\n  if (json === undefined) {\n    packageJsonCache.set(jsonPath, false);\n    return false;\n  }\n\n  try {\n    const parsed = JSONParse(json);\n    const filtered = {\n      name: parsed.name,\n      main: parsed.main,\n      exports: parsed.exports,\n      imports: parsed.imports,\n      type: parsed.type\n    };\n    packageJsonCache.set(jsonPath, filtered);\n    return filtered;\n  } catch (e) {\n    e.path = jsonPath;\n    e.message = 'Error parsing ' + jsonPath + ': ' + e.message;\n    throw e;\n  }\n}\n\nfunction readPackageScope(checkPath) {\n  const rootSeparatorIndex = StringPrototypeIndexOf(checkPath, sep);\n  let separatorIndex;\n  do {\n    separatorIndex = StringPrototypeLastIndexOf(checkPath, sep);\n    checkPath = StringPrototypeSlice(checkPath, 0, separatorIndex);\n    if (StringPrototypeEndsWith(checkPath, sep + 'node_modules'))\n      return false;\n    const pjson = readPackage(checkPath + sep);\n    if (pjson) return {\n      data: pjson,\n      path: checkPath,\n    };\n  } while (separatorIndex > rootSeparatorIndex);\n  return false;\n}\n\nfunction tryPackage(requestPath, exts, isMain, originalPath) {\n  const pkg = readPackage(requestPath)?.main;\n\n  if (!pkg) {\n    return tryExtensions(path.resolve(requestPath, 'index'), exts, isMain);\n  }\n\n  const filename = path.resolve(requestPath, pkg);\n  let actual = tryFile(filename, isMain) ||\n    tryExtensions(filename, exts, isMain) ||\n    tryExtensions(path.resolve(filename, 'index'), exts, isMain);\n  if (actual === false) {\n    actual = tryExtensions(path.resolve(requestPath, 'index'), exts, isMain);\n    if (!actual) {\n      // eslint-disable-next-line no-restricted-syntax\n      const err = new Error(\n        `Cannot find module '${filename}'. ` +\n        'Please verify that the package.json has a valid \"main\" entry'\n      );\n      err.code = 'MODULE_NOT_FOUND';\n      err.path = path.resolve(requestPath, 'package.json');\n      err.requestPath = originalPath;\n      // TODO(BridgeAR): Add the requireStack as well.\n      throw err;\n    } else if (pendingDeprecation) {\n      const jsonPath = path.resolve(requestPath, 'package.json');\n      process.emitWarning(\n        `Invalid 'main' field in '${jsonPath}' of '${pkg}'. ` +\n          'Please either fix that or report it to the module author',\n        'DeprecationWarning',\n        'DEP0128'\n      );\n    }\n  }\n  return actual;\n}\n\n// In order to minimize unnecessary lstat() calls,\n// this cache is a list of known-real paths.\n// Set to an empty Map to reset.\nconst realpathCache = new Map();\n\n// Check if the file exists and is not a directory\n// if using --preserve-symlinks and isMain is false,\n// keep symlinks intact, otherwise resolve to the\n// absolute realpath.\nfunction tryFile(requestPath, isMain) {\n  const rc = stat(requestPath);\n  if (rc !== 0) return;\n  if (preserveSymlinks && !isMain) {\n    return path.resolve(requestPath);\n  }\n  return toRealPath(requestPath);\n}\n\nfunction toRealPath(requestPath) {\n  return fs.realpathSync(requestPath, {\n    [internalFS.realpathCacheKey]: realpathCache\n  });\n}\n\n// Given a path, check if the file exists with any of the set extensions\nfunction tryExtensions(p, exts, isMain) {\n  for (let i = 0; i < exts.length; i++) {\n    const filename = tryFile(p + exts[i], isMain);\n\n    if (filename) {\n      return filename;\n    }\n  }\n  return false;\n}\n\n// Find the longest (possibly multi-dot) extension registered in\n// Module._extensions\nfunction findLongestRegisteredExtension(filename) {\n  const name = path.basename(filename);\n  let currentExtension;\n  let index;\n  let startIndex = 0;\n  while ((index = name.indexOf('.', startIndex)) !== -1) {\n    startIndex = index + 1;\n    if (index === 0) continue; // Skip dotfiles like .gitignore\n    currentExtension = name.slice(index);\n    if (Module._extensions[currentExtension]) return currentExtension;\n  }\n  return '.js';\n}\n\nfunction trySelfParentPath(parent) {\n  if (!parent) return false;\n\n  if (parent.filename) {\n    return parent.filename;\n  } else if (parent.id === '<repl>' || parent.id === 'internal/preload') {\n    try {\n      return process.cwd() + path.sep;\n    } catch {\n      return false;\n    }\n  }\n}\n\nfunction trySelf(parentPath, request) {\n  if (!parentPath) return false;\n\n  const { data: pkg, path: pkgPath } = readPackageScope(parentPath) || {};\n  if (!pkg || pkg.exports === undefined) return false;\n  if (typeof pkg.name !== 'string') return false;\n\n  let expansion;\n  if (request === pkg.name) {\n    expansion = '.';\n  } else if (StringPrototypeStartsWith(request, `${pkg.name}/`)) {\n    expansion = '.' + StringPrototypeSlice(request, pkg.name.length);\n  } else {\n    return false;\n  }\n\n  try {\n    return finalizeEsmResolution(packageExportsResolve(\n      pathToFileURL(pkgPath + '/package.json'), expansion, pkg,\n      pathToFileURL(parentPath), cjsConditions), request, parentPath, pkgPath);\n  } catch (e) {\n    if (e.code === 'ERR_MODULE_NOT_FOUND')\n      throw createEsmNotFoundErr(request, pkgPath + '/package.json');\n    throw e;\n  }\n}\n\n// This only applies to requests of a specific form:\n// 1. name/.*\n// 2. @scope/name/.*\nconst EXPORTS_PATTERN = /^((?:@[^/\\\\%]+\\/)?[^./\\\\%][^/\\\\%]*)(\\/.*)?$/;\nfunction resolveExports(nmPath, request) {\n  // The implementation's behavior is meant to mirror resolution in ESM.\n  const [, name, expansion = ''] =\n    StringPrototypeMatch(request, EXPORTS_PATTERN) || [];\n  if (!name)\n    return;\n  const pkgPath = path.resolve(nmPath, name);\n  const pkg = readPackage(pkgPath);\n  if (pkg && pkg.exports !== null && pkg.exports !== undefined) {\n    try {\n      return finalizeEsmResolution(packageExportsResolve(\n        pathToFileURL(pkgPath + '/package.json'), '.' + expansion, pkg, null,\n        cjsConditions), request, null, pkgPath);\n    } catch (e) {\n      if (e.code === 'ERR_MODULE_NOT_FOUND')\n        throw createEsmNotFoundErr(request, pkgPath + '/package.json');\n      throw e;\n    }\n  }\n}\n\nconst trailingSlashRegex = /(?:^|\\/)\\.?\\.$/;\nModule._findPath = function(request, paths, isMain) {\n  const absoluteRequest = path.isAbsolute(request);\n  if (absoluteRequest) {\n    paths = [''];\n  } else if (!paths || paths.length === 0) {\n    return false;\n  }\n\n  const cacheKey = request + '\\x00' +\n                (paths.length === 1 ? paths[0] : paths.join('\\x00'));\n  const entry = Module._pathCache[cacheKey];\n  if (entry)\n    return entry;\n\n  let exts;\n  let trailingSlash = request.length > 0 &&\n    request.charCodeAt(request.length - 1) === CHAR_FORWARD_SLASH;\n  if (!trailingSlash) {\n    trailingSlash = RegExpPrototypeTest(trailingSlashRegex, request);\n  }\n\n  // For each path\n  for (let i = 0; i < paths.length; i++) {\n    // Don't search further if path doesn't exist\n    const curPath = paths[i];\n    if (curPath && stat(curPath) < 1) continue;\n\n    if (!absoluteRequest) {\n      const exportsResolved = resolveExports(curPath, request);\n      if (exportsResolved)\n        return exportsResolved;\n    }\n\n    const basePath = path.resolve(curPath, request);\n    let filename;\n\n    const rc = stat(basePath);\n    if (!trailingSlash) {\n      if (rc === 0) {  // File.\n        if (!isMain) {\n          if (preserveSymlinks) {\n            filename = path.resolve(basePath);\n          } else {\n            filename = toRealPath(basePath);\n          }\n        } else if (preserveSymlinksMain) {\n          // For the main module, we use the preserveSymlinksMain flag instead\n          // mainly for backward compatibility, as the preserveSymlinks flag\n          // historically has not applied to the main module.  Most likely this\n          // was intended to keep .bin/ binaries working, as following those\n          // symlinks is usually required for the imports in the corresponding\n          // files to resolve; that said, in some use cases following symlinks\n          // causes bigger problems which is why the preserveSymlinksMain option\n          // is needed.\n          filename = path.resolve(basePath);\n        } else {\n          filename = toRealPath(basePath);\n        }\n      }\n\n      if (!filename) {\n        // Try it with each of the extensions\n        if (exts === undefined)\n          exts = ObjectKeys(Module._extensions);\n        filename = tryExtensions(basePath, exts, isMain);\n      }\n    }\n\n    if (!filename && rc === 1) {  // Directory.\n      // try it with each of the extensions at \"index\"\n      if (exts === undefined)\n        exts = ObjectKeys(Module._extensions);\n      filename = tryPackage(basePath, exts, isMain, request);\n    }\n\n    if (filename) {\n      Module._pathCache[cacheKey] = filename;\n      return filename;\n    }\n  }\n\n  return false;\n};\n\n// 'node_modules' character codes reversed\nconst nmChars = [ 115, 101, 108, 117, 100, 111, 109, 95, 101, 100, 111, 110 ];\nconst nmLen = nmChars.length;\nif (isWindows) {\n  // 'from' is the __dirname of the module.\n  Module._nodeModulePaths = function(from) {\n    // Guarantee that 'from' is absolute.\n    from = path.resolve(from);\n\n    // note: this approach *only* works when the path is guaranteed\n    // to be absolute.  Doing a fully-edge-case-correct path.split\n    // that works on both Windows and Posix is non-trivial.\n\n    // return root node_modules when path is 'D:\\\\'.\n    // path.resolve will make sure from.length >=3 in Windows.\n    if (from.charCodeAt(from.length - 1) === CHAR_BACKWARD_SLASH &&\n        from.charCodeAt(from.length - 2) === CHAR_COLON)\n      return [from + 'node_modules'];\n\n    const paths = [];\n    for (let i = from.length - 1, p = 0, last = from.length; i >= 0; --i) {\n      const code = from.charCodeAt(i);\n      // The path segment separator check ('\\' and '/') was used to get\n      // node_modules path for every path segment.\n      // Use colon as an extra condition since we can get node_modules\n      // path for drive root like 'C:\\node_modules' and don't need to\n      // parse drive name.\n      if (code === CHAR_BACKWARD_SLASH ||\n          code === CHAR_FORWARD_SLASH ||\n          code === CHAR_COLON) {\n        if (p !== nmLen)\n          paths.push(from.slice(0, last) + '\\\\node_modules');\n        last = i;\n        p = 0;\n      } else if (p !== -1) {\n        if (nmChars[p] === code) {\n          ++p;\n        } else {\n          p = -1;\n        }\n      }\n    }\n\n    return paths;\n  };\n} else { // posix\n  // 'from' is the __dirname of the module.\n  Module._nodeModulePaths = function(from) {\n    // Guarantee that 'from' is absolute.\n    from = path.resolve(from);\n    // Return early not only to avoid unnecessary work, but to *avoid* returning\n    // an array of two items for a root: [ '//node_modules', '/node_modules' ]\n    if (from === '/')\n      return ['/node_modules'];\n\n    // note: this approach *only* works when the path is guaranteed\n    // to be absolute.  Doing a fully-edge-case-correct path.split\n    // that works on both Windows and Posix is non-trivial.\n    const paths = [];\n    for (let i = from.length - 1, p = 0, last = from.length; i >= 0; --i) {\n      const code = from.charCodeAt(i);\n      if (code === CHAR_FORWARD_SLASH) {\n        if (p !== nmLen)\n          paths.push(from.slice(0, last) + '/node_modules');\n        last = i;\n        p = 0;\n      } else if (p !== -1) {\n        if (nmChars[p] === code) {\n          ++p;\n        } else {\n          p = -1;\n        }\n      }\n    }\n\n    // Append /node_modules to handle root paths.\n    paths.push('/node_modules');\n\n    return paths;\n  };\n}\n\nModule._resolveLookupPaths = function(request, parent) {\n  if (NativeModule.canBeRequiredByUsers(request)) {\n    debug('looking for %j in []', request);\n    return null;\n  }\n\n  // Check for node modules paths.\n  if (request.charAt(0) !== '.' ||\n      (request.length > 1 &&\n      request.charAt(1) !== '.' &&\n      request.charAt(1) !== '/' &&\n      (!isWindows || request.charAt(1) !== '\\\\'))) {\n\n    let paths = modulePaths;\n    if (parent != null && parent.paths && parent.paths.length) {\n      paths = parent.paths.concat(paths);\n    }\n\n    debug('looking for %j in %j', request, paths);\n    return paths.length > 0 ? paths : null;\n  }\n\n  // In REPL, parent.filename is null.\n  if (!parent || !parent.id || !parent.filename) {\n    // Make require('./path/to/foo') work - normally the path is taken\n    // from realpath(__filename) but in REPL there is no filename\n    const mainPaths = ['.'];\n\n    debug('looking for %j in %j', request, mainPaths);\n    return mainPaths;\n  }\n\n  debug('RELATIVE: requested: %s from parent.id %s', request, parent.id);\n\n  const parentDir = [path.dirname(parent.filename)];\n  debug('looking for %j', parentDir);\n  return parentDir;\n};\n\nfunction emitCircularRequireWarning(prop) {\n  process.emitWarning(\n    `Accessing non-existent property '${String(prop)}' of module exports ` +\n    'inside circular dependency'\n  );\n}\n\n// A Proxy that can be used as the prototype of a module.exports object and\n// warns when non-existent properties are accessed.\nconst CircularRequirePrototypeWarningProxy = new Proxy({}, {\n  get(target, prop) {\n    // Allow __esModule access in any case because it is used in the output\n    // of transpiled code to determine whether something comes from an\n    // ES module, and is not used as a regular key of `module.exports`.\n    if (prop in target || prop === '__esModule') return target[prop];\n    emitCircularRequireWarning(prop);\n    return undefined;\n  },\n\n  getOwnPropertyDescriptor(target, prop) {\n    if (ObjectPrototypeHasOwnProperty(target, prop) || prop === '__esModule')\n      return ObjectGetOwnPropertyDescriptor(target, prop);\n    emitCircularRequireWarning(prop);\n    return undefined;\n  }\n});\n\n// Object.prototype and ObjectPrototype refer to our 'primordials' versions\n// and are not identical to the versions on the global object.\nconst PublicObjectPrototype = global.Object.prototype;\n\nfunction getExportsForCircularRequire(module) {\n  if (module.exports &&\n      !isProxy(module.exports) &&\n      ObjectGetPrototypeOf(module.exports) === PublicObjectPrototype &&\n      // Exclude transpiled ES6 modules / TypeScript code because those may\n      // employ unusual patterns for accessing 'module.exports'. That should\n      // be okay because ES6 modules have a different approach to circular\n      // dependencies anyway.\n      !module.exports.__esModule) {\n    // This is later unset once the module is done loading.\n    ObjectSetPrototypeOf(\n      module.exports, CircularRequirePrototypeWarningProxy);\n  }\n\n  return module.exports;\n}\n\n// Check the cache for the requested file.\n// 1. If a module already exists in the cache: return its exports object.\n// 2. If the module is native: call\n//    `NativeModule.prototype.compileForPublicLoader()` and return the exports.\n// 3. Otherwise, create a new module for the file and save it to the cache.\n//    Then have it load  the file contents before returning its exports\n//    object.\nModule._load = function(request, parent, isMain) {\n  let relResolveCacheIdentifier;\n  if (parent) {\n    debug('Module._load REQUEST %s parent: %s', request, parent.id);\n    // Fast path for (lazy loaded) modules in the same directory. The indirect\n    // caching is required to allow cache invalidation without changing the old\n    // cache key names.\n    relResolveCacheIdentifier = `${parent.path}\\x00${request}`;\n    const filename = relativeResolveCache[relResolveCacheIdentifier];\n    if (filename !== undefined) {\n      const cachedModule = Module._cache[filename];\n      if (cachedModule !== undefined) {\n        updateChildren(parent, cachedModule, true);\n        if (!cachedModule.loaded)\n          return getExportsForCircularRequire(cachedModule);\n        return cachedModule.exports;\n      }\n      delete relativeResolveCache[relResolveCacheIdentifier];\n    }\n  }\n\n  const filename = Module._resolveFilename(request, parent, isMain);\n\n  const cachedModule = Module._cache[filename];\n  if (cachedModule !== undefined) {\n    updateChildren(parent, cachedModule, true);\n    if (!cachedModule.loaded) {\n      const parseCachedModule = cjsParseCache.get(cachedModule);\n      if (!parseCachedModule || parseCachedModule.loaded)\n        return getExportsForCircularRequire(cachedModule);\n      parseCachedModule.loaded = true;\n    } else {\n      return cachedModule.exports;\n    }\n  }\n\n  const mod = loadNativeModule(filename, request);\n  if (mod && mod.canBeRequiredByUsers) return mod.exports;\n\n  // Don't call updateChildren(), Module constructor already does.\n  const module = cachedModule || new Module(filename, parent);\n\n  if (isMain) {\n    process.mainModule = module;\n    module.id = '.';\n  }\n\n  Module._cache[filename] = module;\n  if (parent !== undefined) {\n    relativeResolveCache[relResolveCacheIdentifier] = filename;\n  }\n\n  let threw = true;\n  try {\n    // Intercept exceptions that occur during the first tick and rekey them\n    // on error instance rather than module instance (which will immediately be\n    // garbage collected).\n    if (enableSourceMaps) {\n      try {\n        module.load(filename);\n      } catch (err) {\n        rekeySourceMap(Module._cache[filename], err);\n        throw err; /* node-do-not-add-exception-line */\n      }\n    } else {\n      module.load(filename);\n    }\n    threw = false;\n  } finally {\n    if (threw) {\n      delete Module._cache[filename];\n      if (parent !== undefined) {\n        delete relativeResolveCache[relResolveCacheIdentifier];\n        const children = parent && parent.children;\n        if (ArrayIsArray(children)) {\n          const index = children.indexOf(module);\n          if (index !== -1) {\n            children.splice(index, 1);\n          }\n        }\n      }\n    } else if (module.exports &&\n               !isProxy(module.exports) &&\n               ObjectGetPrototypeOf(module.exports) ===\n                 CircularRequirePrototypeWarningProxy) {\n      ObjectSetPrototypeOf(module.exports, PublicObjectPrototype);\n    }\n  }\n\n  return module.exports;\n};\n\nModule._resolveFilename = function(request, parent, isMain, options) {\n  if (NativeModule.canBeRequiredByUsers(request)) {\n    return request;\n  }\n\n  let paths;\n\n  if (typeof options === 'object' && options !== null) {\n    if (ArrayIsArray(options.paths)) {\n      const isRelative = request.startsWith('./') ||\n          request.startsWith('../') ||\n          ((isWindows && request.startsWith('.\\\\')) ||\n          request.startsWith('..\\\\'));\n\n      if (isRelative) {\n        paths = options.paths;\n      } else {\n        const fakeParent = new Module('', null);\n\n        paths = [];\n\n        for (let i = 0; i < options.paths.length; i++) {\n          const path = options.paths[i];\n          fakeParent.paths = Module._nodeModulePaths(path);\n          const lookupPaths = Module._resolveLookupPaths(request, fakeParent);\n\n          for (let j = 0; j < lookupPaths.length; j++) {\n            if (!paths.includes(lookupPaths[j]))\n              paths.push(lookupPaths[j]);\n          }\n        }\n      }\n    } else if (options.paths === undefined) {\n      paths = Module._resolveLookupPaths(request, parent);\n    } else {\n      throw new ERR_INVALID_OPT_VALUE('options.paths', options.paths);\n    }\n  } else {\n    paths = Module._resolveLookupPaths(request, parent);\n  }\n\n  if (parent && parent.filename) {\n    if (request[0] === '#') {\n      const pkg = readPackageScope(parent.filename) || {};\n      if (pkg.data && pkg.data.imports !== null &&\n          pkg.data.imports !== undefined) {\n        try {\n          return finalizeEsmResolution(\n            packageImportsResolve(request, pathToFileURL(parent.filename),\n                                  cjsConditions), request, parent.filename,\n            pkg.path);\n        } catch (e) {\n          if (e.code === 'ERR_MODULE_NOT_FOUND')\n            throw createEsmNotFoundErr(request);\n          throw e;\n        }\n      }\n    }\n  }\n\n  // Try module self resoultion first\n  const parentPath = trySelfParentPath(parent);\n  const selfResolved = trySelf(parentPath, request);\n  if (selfResolved) {\n    const cacheKey = request + '\\x00' +\n         (paths.length === 1 ? paths[0] : ArrayPrototypeJoin(paths, '\\x00'));\n    Module._pathCache[cacheKey] = selfResolved;\n    return selfResolved;\n  }\n\n  // Look up the filename first, since that's the cache key.\n  const filename = Module._findPath(request, paths, isMain, false);\n  if (filename) return filename;\n  const requireStack = [];\n  for (let cursor = parent;\n    cursor;\n    cursor = cursor.parent) {\n    requireStack.push(cursor.filename || cursor.id);\n  }\n  let message = `Cannot find module '${request}'`;\n  if (requireStack.length > 0) {\n    message = message + '\\nRequire stack:\\n- ' + requireStack.join('\\n- ');\n  }\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(message);\n  err.code = 'MODULE_NOT_FOUND';\n  err.requireStack = requireStack;\n  throw err;\n};\n\nfunction finalizeEsmResolution(match, request, parentPath, pkgPath) {\n  const { resolved, exact } = match;\n  if (StringPrototypeMatch(resolved, encodedSepRegEx))\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      resolved, 'must not include encoded \"/\" or \"\\\\\" characters', parentPath);\n  const filename = fileURLToPath(resolved);\n  let actual = tryFile(filename);\n  if (!exact && !actual) {\n    const exts = ObjectKeys(Module._extensions);\n    actual = tryExtensions(filename, exts, false) ||\n      tryPackage(filename, exts, false, request);\n  }\n  if (actual)\n    return actual;\n  const err = createEsmNotFoundErr(filename,\n                                   path.resolve(pkgPath, 'package.json'));\n  throw err;\n}\n\nfunction createEsmNotFoundErr(request, path) {\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(`Cannot find module '${request}'`);\n  err.code = 'MODULE_NOT_FOUND';\n  if (path)\n    err.path = path;\n  // TODO(BridgeAR): Add the requireStack as well.\n  return err;\n}\n\n// Given a file name, pass it to the proper extension handler.\nModule.prototype.load = function(filename) {\n  debug('load %j for module %j', filename, this.id);\n\n  assert(!this.loaded);\n  this.filename = filename;\n  this.paths = Module._nodeModulePaths(path.dirname(filename));\n\n  const extension = findLongestRegisteredExtension(filename);\n  // allow .mjs to be overridden\n  if (filename.endsWith('.mjs') && !Module._extensions['.mjs']) {\n    throw new ERR_REQUIRE_ESM(filename);\n  }\n  Module._extensions[extension](this, filename);\n  this.loaded = true;\n\n  const ESMLoader = asyncESM.ESMLoader;\n  // Create module entry at load time to snapshot exports correctly\n  const exports = this.exports;\n  // Preemptively cache\n  if ((module?.module === undefined ||\n       module.module.getStatus() < kEvaluated) &&\n      !ESMLoader.cjsCache.has(this))\n    ESMLoader.cjsCache.set(this, exports);\n};\n\n\n// Loads a module at the given file path. Returns that module's\n// `exports` property.\nModule.prototype.require = function(id) {\n  validateString(id, 'id');\n  if (id === '') {\n    throw new ERR_INVALID_ARG_VALUE('id', id,\n                                    'must be a non-empty string');\n  }\n  requireDepth++;\n  try {\n    return Module._load(id, this, /* isMain */ false);\n  } finally {\n    requireDepth--;\n  }\n};\n\n\n// Resolved path to process.argv[1] will be lazily placed here\n// (needed for setting breakpoint when called with --inspect-brk)\nlet resolvedArgv;\nlet hasPausedEntry = false;\n\nfunction wrapSafe(filename, content, cjsModuleInstance) {\n  if (patched) {\n    const wrapper = Module.wrap(content);\n    return vm.runInThisContext(wrapper, {\n      filename,\n      lineOffset: 0,\n      displayErrors: true,\n      importModuleDynamically: async (specifier) => {\n        const loader = asyncESM.ESMLoader;\n        return loader.import(specifier, normalizeReferrerURL(filename));\n      },\n    });\n  }\n  let compiled;\n  try {\n    compiled = compileFunction(\n      content,\n      filename,\n      0,\n      0,\n      undefined,\n      false,\n      undefined,\n      [],\n      [\n        'exports',\n        'require',\n        'module',\n        '__filename',\n        '__dirname',\n      ]\n    );\n  } catch (err) {\n    if (process.mainModule === cjsModuleInstance)\n      enrichCJSError(err);\n    throw err;\n  }\n\n  const { callbackMap } = internalBinding('module_wrap');\n  callbackMap.set(compiled.cacheKey, {\n    importModuleDynamically: async (specifier) => {\n      const loader = asyncESM.ESMLoader;\n      return loader.import(specifier, normalizeReferrerURL(filename));\n    }\n  });\n\n  return compiled.function;\n}\n\n// Run the file contents in the correct scope or sandbox. Expose\n// the correct helper variables (require, module, exports) to\n// the file.\n// Returns exception, if any.\nModule.prototype._compile = function(content, filename) {\n  let moduleURL;\n  let redirects;\n  if (policy?.manifest) {\n    moduleURL = pathToFileURL(filename);\n    redirects = policy.manifest.getDependencyMapper(moduleURL);\n    policy.manifest.assertIntegrity(moduleURL, content);\n  }\n\n  maybeCacheSourceMap(filename, content, this);\n  const compiledWrapper = wrapSafe(filename, content, this);\n\n  let inspectorWrapper = null;\n  if (getOptionValue('--inspect-brk') && process._eval == null) {\n    if (!resolvedArgv) {\n      // We enter the repl if we're not given a filename argument.\n      // process._firstFileName is used by Embedders to tell node what\n      // the first \"real\" file is when they use themselves as the entry\n      // point\n      if (process._firstFileName) {\n        resolvedArgv = process._firstFileName\n        delete process._firstFileName\n      } else\n      if (process.argv[1]) {\n        try {\n          resolvedArgv = Module._resolveFilename(process.argv[1], null, false);\n        } catch {\n          // We only expect this codepath to be reached in the case of a\n          // preloaded module (it will fail earlier with the main entry)\n          assert(ArrayIsArray(getOptionValue('--require')));\n        }\n      } else {\n        resolvedArgv = 'repl';\n      }\n    }\n\n    // Set breakpoint on module start\n    if (resolvedArgv && !hasPausedEntry && filename === resolvedArgv) {\n      hasPausedEntry = true;\n      inspectorWrapper = internalBinding('inspector').callAndPauseOnStart;\n    }\n  }\n  const dirname = path.dirname(filename);\n  const require = makeRequireFunction(this, redirects);\n  let result;\n  const exports = this.exports;\n  const thisValue = exports;\n  const module = this;\n  if (requireDepth === 0) statCache = new Map();\n  if (inspectorWrapper) {\n    result = inspectorWrapper(compiledWrapper, thisValue, exports,\n                              require, module, filename, dirname,\n                              process, localGlobal, localBuffer);\n  } else {\n    result = compiledWrapper.call(thisValue, exports, require, module,\n                                  filename, dirname, process, localGlobal,\n                                  localBuffer);\n  }\n  hasLoadedAnyUserCJSModule = true;\n  if (requireDepth === 0) statCache = null;\n  return result;\n};\n\n// Native extension for .js\nModule._extensions['.js'] = function(module, filename) {\n  if (filename.endsWith('.js')) {\n    const pkg = readPackageScope(filename);\n    // Function require shouldn't be used in ES modules.\n    if (pkg && pkg.data && pkg.data.type === 'module') {\n      const { parent } = module;\n      const parentPath = parent && parent.filename;\n      const packageJsonPath = path.resolve(pkg.path, 'package.json');\n      throw new ERR_REQUIRE_ESM(filename, parentPath, packageJsonPath);\n    }\n  }\n  // If already analyzed the source, then it will be cached.\n  const cached = cjsParseCache.get(module);\n  let content;\n  if (cached && cached.source) {\n    content = cached.source;\n    cached.source = undefined;\n  } else {\n    content = fs.readFileSync(filename, 'utf8');\n  }\n  module._compile(content, filename);\n};\n\n\n// Native extension for .json\nModule._extensions['.json'] = function(module, filename) {\n  const content = fs.readFileSync(filename, 'utf8');\n\n  if (policy?.manifest) {\n    const moduleURL = pathToFileURL(filename);\n    policy.manifest.assertIntegrity(moduleURL, content);\n  }\n\n  try {\n    module.exports = JSONParse(stripBOM(content));\n  } catch (err) {\n    err.message = filename + ': ' + err.message;\n    throw err;\n  }\n};\n\n\n// Native extension for .node\nModule._extensions['.node'] = function(module, filename) {\n  if (policy?.manifest) {\n    const content = fs.readFileSync(filename);\n    const moduleURL = pathToFileURL(filename);\n    policy.manifest.assertIntegrity(moduleURL, content);\n  }\n  // Be aware this doesn't use `content`\n  return process.dlopen(module, path.toNamespacedPath(filename));\n};\n\nfunction createRequireFromPath(filename) {\n  // Allow a directory to be passed as the filename\n  const trailingSlash =\n    filename.endsWith('/') || (isWindows && filename.endsWith('\\\\'));\n\n  const proxyPath = trailingSlash ?\n    path.join(filename, 'noop.js') :\n    filename;\n\n  const m = new Module(proxyPath);\n  m.filename = proxyPath;\n\n  m.paths = Module._nodeModulePaths(m.path);\n  return makeRequireFunction(m, null);\n}\n\nModule.createRequireFromPath = deprecate(\n  createRequireFromPath,\n  'Module.createRequireFromPath() is deprecated. ' +\n  'Use Module.createRequire() instead.',\n  'DEP0130'\n);\n\nconst createRequireError = 'must be a file URL object, file URL string, or ' +\n  'absolute path string';\n\nfunction createRequire(filename) {\n  let filepath;\n\n  if (isURLInstance(filename) ||\n      (typeof filename === 'string' && !path.isAbsolute(filename))) {\n    try {\n      filepath = fileURLToPath(filename);\n    } catch {\n      throw new ERR_INVALID_ARG_VALUE('filename', filename,\n                                      createRequireError);\n    }\n  } else if (typeof filename !== 'string') {\n    throw new ERR_INVALID_ARG_VALUE('filename', filename, createRequireError);\n  } else {\n    filepath = filename;\n  }\n  return createRequireFromPath(filepath);\n}\n\nModule.createRequire = createRequire;\n\nModule._initPaths = function() {\n  const homeDir = isWindows ? process.env.USERPROFILE : safeGetenv('HOME');\n  const nodePath = isWindows ? process.env.NODE_PATH : safeGetenv('NODE_PATH');\n\n  // process.execPath is $PREFIX/bin/node except on Windows where it is\n  // $PREFIX\\node.exe where $PREFIX is the root of the Node.js installation.\n  const prefixDir = isWindows ?\n    path.resolve(process.execPath, '..') :\n    path.resolve(process.execPath, '..', '..');\n\n  let paths = [path.resolve(prefixDir, 'lib', 'node')];\n\n  if (homeDir) {\n    paths.unshift(path.resolve(homeDir, '.node_libraries'));\n    paths.unshift(path.resolve(homeDir, '.node_modules'));\n  }\n\n  if (nodePath) {\n    paths = nodePath.split(path.delimiter).filter(function pathsFilterCB(path) {\n      return !!path;\n    }).concat(paths);\n  }\n\n  modulePaths = paths;\n\n  // clone as a shallow copy, for introspection.\n  Module.globalPaths = modulePaths;\n};\n\nModule._preloadModules = function(requests) {\n  if (!ArrayIsArray(requests))\n    return;\n\n  // Preloaded modules have a dummy parent module which is deemed to exist\n  // in the current working directory. This seeds the search path for\n  // preloaded modules.\n  const parent = new Module('internal/preload', null);\n  try {\n    parent.paths = Module._nodeModulePaths(process.cwd());\n  } catch (e) {\n    if (e.code !== 'ENOENT') {\n      throw e;\n    }\n  }\n  for (let n = 0; n < requests.length; n++)\n    parent.require(requests[n]);\n};\n\nModule.syncBuiltinESMExports = function syncBuiltinESMExports() {\n  for (const mod of NativeModule.map.values()) {\n    if (mod.canBeRequiredByUsers) {\n      mod.syncExports();\n    }\n  }\n};\n\n// Backwards compatibility\nModule.Module = Module;\n"
  },
  {
    "url": "internal/modules/esm/create_dynamic_module.js",
    "ranges": [
      {
        "start": 0,
        "end": 190
      },
      {
        "start": 215,
        "end": 219
      },
      {
        "start": 409,
        "end": 411
      },
      {
        "start": 612,
        "end": 642
      },
      {
        "start": 1715,
        "end": 1756
      }
    ],
    "text": "'use strict';\n\nconst {\n  ArrayPrototypeJoin,\n  ArrayPrototypeMap,\n  JSONStringify,\n  ObjectCreate,\n  SafeSet,\n} = primordials;\n\nlet debug = require('internal/util/debuglog').debuglog('esm', (fn) => {\n  debug = fn;\n});\n\nfunction createImport(impt, index) {\n  const imptPath = JSONStringify(impt);\n  return `import * as $import_${index} from ${imptPath};\nimport.meta.imports[${imptPath}] = $import_${index};`;\n}\n\nfunction createExport(expt) {\n  const name = `${expt}`;\n  return `let $${name};\nexport { $${name} as ${name} };\nimport.meta.exports.${name} = {\n  get: () => $${name},\n  set: (v) => $${name} = v,\n};`;\n}\n\nconst createDynamicModule = (imports, exports, url = '', evaluate) => {\n  debug('creating ESM facade for %s with exports: %j', url, exports);\n  const source = `\n${ArrayPrototypeJoin(ArrayPrototypeMap(imports, createImport), '\\n')}\n${ArrayPrototypeJoin(ArrayPrototypeMap(exports, createExport), '\\n')}\nimport.meta.done();\n`;\n  const { ModuleWrap, callbackMap } = internalBinding('module_wrap');\n  const m = new ModuleWrap(`${url}`, undefined, source, 0, 0);\n\n  const readyfns = new SafeSet();\n  const reflect = {\n    exports: ObjectCreate(null),\n    onReady: (cb) => { readyfns.add(cb); },\n  };\n\n  if (imports.length)\n    reflect.imports = ObjectCreate(null);\n\n  callbackMap.set(m, {\n    initializeImportMeta: (meta, wrap) => {\n      meta.exports = reflect.exports;\n      if (reflect.imports)\n        meta.imports = reflect.imports;\n      meta.done = () => {\n        evaluate(reflect);\n        reflect.onReady = (cb) => cb(reflect);\n        for (const fn of readyfns) {\n          readyfns.delete(fn);\n          fn(reflect);\n        }\n      };\n    },\n  });\n\n  return {\n    module: m,\n    reflect,\n  };\n};\n\nmodule.exports = createDynamicModule;\n"
  },
  {
    "url": "internal/modules/esm/get_format.js",
    "ranges": [
      {
        "start": 0,
        "end": 1131
      },
      {
        "start": 2450,
        "end": 2496
      }
    ],
    "text": "'use strict';\nconst {\n  RegExpPrototypeExec,\n  StringPrototypeStartsWith,\n} = primordials;\nconst { extname } = require('path');\nconst { getOptionValue } = require('internal/options');\n\nconst experimentalJsonModules = getOptionValue('--experimental-json-modules');\nconst experimentalSpeciferResolution =\n  getOptionValue('--experimental-specifier-resolution');\nconst experimentalWasmModules = getOptionValue('--experimental-wasm-modules');\nconst { getPackageType } = require('internal/modules/esm/resolve');\nconst { URL, fileURLToPath } = require('internal/url');\nconst { ERR_UNKNOWN_FILE_EXTENSION } = require('internal/errors').codes;\n\nconst extensionFormatMap = {\n  '__proto__': null,\n  '.cjs': 'commonjs',\n  '.js': 'module',\n  '.mjs': 'module'\n};\n\nconst legacyExtensionFormatMap = {\n  '__proto__': null,\n  '.cjs': 'commonjs',\n  '.js': 'commonjs',\n  '.json': 'commonjs',\n  '.mjs': 'module',\n  '.node': 'commonjs'\n};\n\nif (experimentalWasmModules)\n  extensionFormatMap['.wasm'] = legacyExtensionFormatMap['.wasm'] = 'wasm';\n\nif (experimentalJsonModules)\n  extensionFormatMap['.json'] = legacyExtensionFormatMap['.json'] = 'json';\n\nfunction defaultGetFormat(url, context, defaultGetFormatUnused) {\n  if (StringPrototypeStartsWith(url, 'node:')) {\n    return { format: 'builtin' };\n  }\n  const parsed = new URL(url);\n  if (parsed.protocol === 'data:') {\n    const [ , mime ] = RegExpPrototypeExec(\n      /^([^/]+\\/[^;,]+)(?:[^,]*?)(;base64)?,/,\n      parsed.pathname,\n    ) || [ null, null, null ];\n    const format = ({\n      '__proto__': null,\n      'text/javascript': 'module',\n      'application/json': experimentalJsonModules ? 'json' : null,\n      'application/wasm': experimentalWasmModules ? 'wasm' : null\n    })[mime] || null;\n    return { format };\n  } else if (parsed.protocol === 'file:') {\n    const ext = extname(parsed.pathname);\n    let format;\n    if (ext === '.js') {\n      format = getPackageType(parsed.href) === 'module' ? 'module' : 'commonjs';\n    } else {\n      format = extensionFormatMap[ext];\n    }\n    if (!format) {\n      if (experimentalSpeciferResolution === 'node') {\n        process.emitWarning(\n          'The Node.js specifier resolution in ESM is experimental.',\n          'ExperimentalWarning');\n        format = legacyExtensionFormatMap[ext];\n      } else {\n        throw new ERR_UNKNOWN_FILE_EXTENSION(ext, fileURLToPath(url));\n      }\n    }\n    return { format: format || null };\n  }\n  return { format: null };\n}\nexports.defaultGetFormat = defaultGetFormat;\n"
  },
  {
    "url": "internal/modules/esm/get_source.js",
    "ranges": [
      {
        "start": 0,
        "end": 609
      },
      {
        "start": 1261,
        "end": 1307
      }
    ],
    "text": "'use strict';\n\nconst {\n  RegExpPrototypeExec,\n} = primordials;\nconst { getOptionValue } = require('internal/options');\n// Do not eagerly grab .manifest, it may be in TDZ\nconst policy = getOptionValue('--experimental-policy') ?\n  require('internal/process/policy') :\n  null;\n\nconst { Buffer } = require('buffer');\n\nconst fs = require('internal/fs/promises').exports;\nconst { URL } = require('internal/url');\nconst {\n  ERR_INVALID_URL,\n  ERR_INVALID_URL_SCHEME,\n} = require('internal/errors').codes;\nconst readFileAsync = fs.readFile;\n\nconst DATA_URL_PATTERN = /^[^/]+\\/[^,;]+(?:[^,]*?)(;base64)?,([\\s\\S]*)$/;\n\nasync function defaultGetSource(url, { format } = {}, defaultGetSource) {\n  const parsed = new URL(url);\n  let source;\n  if (parsed.protocol === 'file:') {\n    source = await readFileAsync(parsed);\n  } else if (parsed.protocol === 'data:') {\n    const match = RegExpPrototypeExec(DATA_URL_PATTERN, parsed.pathname);\n    if (!match) {\n      throw new ERR_INVALID_URL(url);\n    }\n    const [ , base64, body ] = match;\n    source = Buffer.from(body, base64 ? 'base64' : 'utf8');\n  } else {\n    throw new ERR_INVALID_URL_SCHEME(['file', 'data']);\n  }\n  if (policy?.manifest) {\n    policy.manifest.assertIntegrity(parsed, source);\n  }\n  return { source };\n}\nexports.defaultGetSource = defaultGetSource;\n"
  },
  {
    "url": "internal/modules/esm/loader.js",
    "ranges": [
      {
        "start": 0,
        "end": 3138
      },
      {
        "start": 3761,
        "end": 3765
      },
      {
        "start": 4790,
        "end": 4794
      },
      {
        "start": 5469,
        "end": 5473
      },
      {
        "start": 5644,
        "end": 5648
      },
      {
        "start": 6609,
        "end": 6613
      },
      {
        "start": 7417,
        "end": 7421
      },
      {
        "start": 8211,
        "end": 8287
      }
    ],
    "text": "'use strict';\n\n// This is needed to avoid cycles in esm/resolve <-> cjs/loader\nrequire('internal/modules/cjs/loader');\n\nconst {\n  FunctionPrototypeBind,\n  ObjectSetPrototypeOf,\n  SafeWeakMap,\n  StringPrototypeStartsWith,\n} = primordials;\n\nconst {\n  ERR_INVALID_ARG_VALUE,\n  ERR_INVALID_RETURN_PROPERTY,\n  ERR_INVALID_RETURN_PROPERTY_VALUE,\n  ERR_INVALID_RETURN_VALUE,\n  ERR_UNKNOWN_MODULE_FORMAT\n} = require('internal/errors').codes;\nconst { URL, pathToFileURL } = require('internal/url');\nconst { validateString } = require('internal/validators');\nconst ModuleMap = require('internal/modules/esm/module_map');\nconst ModuleJob = require('internal/modules/esm/module_job');\n\nconst {\n  defaultResolve,\n  DEFAULT_CONDITIONS,\n} = require('internal/modules/esm/resolve');\nconst { defaultGetFormat } = require('internal/modules/esm/get_format');\nconst { defaultGetSource } = require(\n  'internal/modules/esm/get_source');\nconst { defaultTransformSource } = require(\n  'internal/modules/esm/transform_source');\nconst { translators } = require(\n  'internal/modules/esm/translators');\nconst { getOptionValue } = require('internal/options');\n\n/* A Loader instance is used as the main entry point for loading ES modules.\n * Currently, this is a singleton -- there is only one used for loading\n * the main module and everything in its dependency graph. */\nclass Loader {\n  constructor() {\n    // Methods which translate input code or other information\n    // into es modules\n    this.translators = translators;\n\n    // Registry of loaded modules, akin to `require.cache`\n    this.moduleMap = new ModuleMap();\n\n    // Map of already-loaded CJS modules to use\n    this.cjsCache = new SafeWeakMap();\n\n    // This hook is called before the first root module is imported. It's a\n    // function that returns a piece of code that runs as a sloppy-mode script.\n    // The script may evaluate to a function that can be called with a\n    // `getBuiltin` helper that can be used to retrieve builtins.\n    // If the hook returns `null` instead of a source string, it opts out of\n    // running any preload code.\n    // The preload code runs as soon as the hook module has finished evaluating.\n    this._getGlobalPreloadCode = null;\n    // The resolver has the signature\n    //   (specifier : string, parentURL : string, defaultResolve)\n    //       -> Promise<{ url : string }>\n    // where defaultResolve is ModuleRequest.resolve (having the same\n    // signature itself).\n    this._resolve = defaultResolve;\n    // This hook is called after the module is resolved but before a translator\n    // is chosen to load it; the format returned by this function is the name\n    // of a translator.\n    this._getFormat = defaultGetFormat;\n    // This hook is called just before the source code of an ES module file\n    // is loaded.\n    this._getSource = defaultGetSource;\n    // This hook is called just after the source code of an ES module file\n    // is loaded, but before anything is done with the string.\n    this._transformSource = defaultTransformSource;\n    // The index for assigning unique URLs to anonymous module evaluation\n    this.evalIndex = 0;\n  }\n\n  async resolve(specifier, parentURL) {\n    const isMain = parentURL === undefined;\n    if (!isMain)\n      validateString(parentURL, 'parentURL');\n\n    const resolveResponse = await this._resolve(\n      specifier, { parentURL, conditions: DEFAULT_CONDITIONS }, defaultResolve);\n    if (typeof resolveResponse !== 'object') {\n      throw new ERR_INVALID_RETURN_VALUE(\n        'object', 'loader resolve', resolveResponse);\n    }\n\n    const { url } = resolveResponse;\n    if (typeof url !== 'string') {\n      throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n        'string', 'loader resolve', 'url', url);\n    }\n    return url;\n  }\n\n  async getFormat(url) {\n    const getFormatResponse = await this._getFormat(\n      url, {}, defaultGetFormat);\n    if (typeof getFormatResponse !== 'object') {\n      throw new ERR_INVALID_RETURN_VALUE(\n        'object', 'loader getFormat', getFormatResponse);\n    }\n\n    const { format } = getFormatResponse;\n    if (typeof format !== 'string') {\n      throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n        'string', 'loader getFormat', 'format', format);\n    }\n\n    if (format === 'builtin') {\n      return format;\n    }\n\n    if (this._resolve !== defaultResolve) {\n      try {\n        new URL(url);\n      } catch {\n        throw new ERR_INVALID_RETURN_PROPERTY(\n          'url', 'loader resolve', 'url', url\n        );\n      }\n    }\n\n    if (this._resolve === defaultResolve &&\n      !StringPrototypeStartsWith(url, 'file:') &&\n      !StringPrototypeStartsWith(url, 'data:')\n    ) {\n      throw new ERR_INVALID_RETURN_PROPERTY(\n        'file: or data: url', 'loader resolve', 'url', url\n      );\n    }\n\n    return format;\n  }\n\n  async eval(\n    source,\n    url = pathToFileURL(`${process.cwd()}/[eval${++this.evalIndex}]`).href\n  ) {\n    const evalInstance = (url) => {\n      const { ModuleWrap, callbackMap } = internalBinding('module_wrap');\n      const module = new ModuleWrap(url, undefined, source, 0, 0);\n      callbackMap.set(module, {\n        importModuleDynamically: (specifier, { url }) => {\n          return this.import(specifier, url);\n        }\n      });\n\n      return module;\n    };\n    const job = new ModuleJob(this, url, evalInstance, false, false);\n    this.moduleMap.set(url, job);\n    const { module } = await job.run();\n    return {\n      namespace: module.getNamespace(),\n    };\n  }\n\n  async import(specifier, parent) {\n    const job = await this.getModuleJob(specifier, parent);\n    const { module } = await job.run();\n    return module.getNamespace();\n  }\n\n  hook(hooks) {\n    const {\n      resolve,\n      dynamicInstantiate,\n      getFormat,\n      getSource,\n      transformSource,\n      getGlobalPreloadCode,\n    } = hooks;\n\n    // Use .bind() to avoid giving access to the Loader instance when called.\n    if (resolve !== undefined)\n      this._resolve = FunctionPrototypeBind(resolve, null);\n    if (dynamicInstantiate !== undefined) {\n      process.emitWarning(\n        'The dynamicInstantiate loader hook has been removed.');\n    }\n    if (getFormat !== undefined) {\n      this._getFormat = FunctionPrototypeBind(getFormat, null);\n    }\n    if (getSource !== undefined) {\n      this._getSource = FunctionPrototypeBind(getSource, null);\n    }\n    if (transformSource !== undefined) {\n      this._transformSource = FunctionPrototypeBind(transformSource, null);\n    }\n    if (getGlobalPreloadCode !== undefined) {\n      this._getGlobalPreloadCode =\n        FunctionPrototypeBind(getGlobalPreloadCode, null);\n    }\n  }\n\n  runGlobalPreloadCode() {\n    if (!this._getGlobalPreloadCode) {\n      return;\n    }\n    const preloadCode = this._getGlobalPreloadCode();\n    if (preloadCode === null) {\n      return;\n    }\n\n    if (typeof preloadCode !== 'string') {\n      throw new ERR_INVALID_RETURN_VALUE(\n        'string', 'loader getGlobalPreloadCode', preloadCode);\n    }\n    const { compileFunction } = require('vm');\n    const preloadInit = compileFunction(preloadCode, ['getBuiltin'], {\n      filename: '<preload>',\n    });\n    const { NativeModule } = require('internal/bootstrap/loaders');\n\n    preloadInit.call(globalThis, (builtinName) => {\n      if (NativeModule.canBeRequiredByUsers(builtinName)) {\n        return require(builtinName);\n      }\n      throw new ERR_INVALID_ARG_VALUE('builtinName', builtinName);\n    });\n  }\n\n  async getModuleJob(specifier, parentURL) {\n    const url = await this.resolve(specifier, parentURL);\n    const format = await this.getFormat(url);\n    let job = this.moduleMap.get(url);\n    // CommonJS will set functions for lazy job evaluation.\n    if (typeof job === 'function')\n      this.moduleMap.set(url, job = job());\n    if (job !== undefined)\n      return job;\n\n    if (!translators.has(format))\n      throw new ERR_UNKNOWN_MODULE_FORMAT(format);\n\n    const loaderInstance = translators.get(format);\n\n    const inspectBrk = parentURL === undefined &&\n        format === 'module' && getOptionValue('--inspect-brk');\n    job = new ModuleJob(this, url, loaderInstance, parentURL === undefined,\n                        inspectBrk);\n    this.moduleMap.set(url, job);\n    return job;\n  }\n}\n\nObjectSetPrototypeOf(Loader.prototype, null);\n\nexports.Loader = Loader;\n"
  },
  {
    "url": "internal/modules/esm/module_job.js",
    "ranges": [
      {
        "start": 0,
        "end": 832
      },
      {
        "start": 2478,
        "end": 2482
      },
      {
        "start": 2627,
        "end": 2631
      },
      {
        "start": 5498,
        "end": 5502
      },
      {
        "start": 5698,
        "end": 5778
      }
    ],
    "text": "'use strict';\n\nconst {\n  ArrayPrototypeJoin,\n  ArrayPrototypeMap,\n  ArrayPrototypePush,\n  FunctionPrototype,\n  ObjectSetPrototypeOf,\n  PromiseAll,\n  PromiseResolve,\n  PromisePrototypeCatch,\n  ReflectApply,\n  SafeSet,\n  StringPrototypeIncludes,\n  StringPrototypeMatch,\n  StringPrototypeReplace,\n  StringPrototypeSplit,\n} = primordials;\n\nconst { ModuleWrap } = internalBinding('module_wrap');\n\nconst { decorateErrorStack } = require('internal/util');\nconst assert = require('internal/assert');\nconst resolvedPromise = PromiseResolve();\n\nconst noop = FunctionPrototype;\n\nlet hasPausedEntry = false;\n\n/* A ModuleJob tracks the loading of a single Module, and the ModuleJobs of\n * its dependencies, over time. */\nclass ModuleJob {\n  // `loader` is the Loader instance used for loading dependencies.\n  // `moduleProvider` is a function\n  constructor(loader, url, moduleProvider, isMain, inspectBrk) {\n    this.loader = loader;\n    this.isMain = isMain;\n    this.inspectBrk = inspectBrk;\n\n    this.module = undefined;\n    // Expose the promise to the ModuleWrap directly for linking below.\n    // `this.module` is also filled in below.\n    this.modulePromise = ReflectApply(moduleProvider, loader, [url, isMain]);\n\n    // Wait for the ModuleWrap instance being linked with all dependencies.\n    const link = async () => {\n      this.module = await this.modulePromise;\n      assert(this.module instanceof ModuleWrap);\n\n      // Explicitly keeping track of dependency jobs is needed in order\n      // to flatten out the dependency graph below in `_instantiate()`,\n      // so that circular dependencies can't cause a deadlock by two of\n      // these `link` callbacks depending on each other.\n      const dependencyJobs = [];\n      const promises = this.module.link(async (specifier) => {\n        const jobPromise = this.loader.getModuleJob(specifier, url);\n        ArrayPrototypePush(dependencyJobs, jobPromise);\n        const job = await jobPromise;\n        return job.modulePromise;\n      });\n\n      if (promises !== undefined)\n        await PromiseAll(promises);\n\n      return PromiseAll(dependencyJobs);\n    };\n    // Promise for the list of all dependencyJobs.\n    this.linked = link();\n    // This promise is awaited later anyway, so silence\n    // 'unhandled rejection' warnings.\n    PromisePrototypeCatch(this.linked, noop);\n\n    // instantiated == deep dependency jobs wrappers are instantiated,\n    // and module wrapper is instantiated.\n    this.instantiated = undefined;\n  }\n\n  instantiate() {\n    if (this.instantiated === undefined) {\n      this.instantiated = this._instantiate();\n    }\n    return this.instantiated;\n  }\n\n  async _instantiate() {\n    const jobsInGraph = new SafeSet();\n    const addJobsToDependencyGraph = async (moduleJob) => {\n      if (jobsInGraph.has(moduleJob)) {\n        return;\n      }\n      jobsInGraph.add(moduleJob);\n      const dependencyJobs = await moduleJob.linked;\n      return PromiseAll(\n        ArrayPrototypeMap(dependencyJobs, addJobsToDependencyGraph));\n    };\n    await addJobsToDependencyGraph(this);\n\n    try {\n      if (!hasPausedEntry && this.inspectBrk) {\n        hasPausedEntry = true;\n        const initWrapper = internalBinding('inspector').callAndPauseOnStart;\n        initWrapper(this.module.instantiate, this.module);\n      } else {\n        this.module.instantiate();\n      }\n    } catch (e) {\n      decorateErrorStack(e);\n      if (StringPrototypeIncludes(e.message,\n                                  ' does not provide an export named')) {\n        const splitStack = StringPrototypeSplit(e.stack, '\\n');\n        const parentFileUrl = splitStack[0];\n        const [, childSpecifier, name] = StringPrototypeMatch(e.message,\n                                                              /module '(.*)' does not provide an export named '(.+)'/);\n        const childFileURL =\n            await this.loader.resolve(childSpecifier, parentFileUrl);\n        const format = await this.loader.getFormat(childFileURL);\n        if (format === 'commonjs') {\n          const importStatement = splitStack[1];\n          // TODO(@ctavan): The original error stack only provides the single\n          // line which causes the error. For multi-line import statements we\n          // cannot generate an equivalent object descructuring assignment by\n          // just parsing the error stack.\n          const oneLineNamedImports = StringPrototypeMatch(importStatement, /{.*}/);\n          const destructuringAssignment = oneLineNamedImports &&\n              StringPrototypeReplace(oneLineNamedImports, /\\s+as\\s+/g, ': ');\n          e.message = `Named export '${name}' not found. The requested module` +\n            ` '${childSpecifier}' is a CommonJS module, which may not support` +\n            ' all module.exports as named exports.\\nCommonJS modules can ' +\n            'always be imported via the default export, for example using:' +\n            `\\n\\nimport pkg from '${childSpecifier}';\\n${\n              destructuringAssignment ?\n                `const ${destructuringAssignment} = pkg;\\n` : ''}`;\n          const newStack = StringPrototypeSplit(e.stack, '\\n');\n          newStack[3] = `SyntaxError: ${e.message}`;\n          e.stack = ArrayPrototypeJoin(newStack, '\\n');\n        }\n      }\n      throw e;\n    }\n\n    for (const dependencyJob of jobsInGraph) {\n      // Calling `this.module.instantiate()` instantiates not only the\n      // ModuleWrap in this module, but all modules in the graph.\n      dependencyJob.instantiated = resolvedPromise;\n    }\n  }\n\n  async run() {\n    await this.instantiate();\n    const timeout = -1;\n    const breakOnSigint = false;\n    await this.module.evaluate(timeout, breakOnSigint);\n    return { module: this.module };\n  }\n}\nObjectSetPrototypeOf(ModuleJob.prototype, null);\nmodule.exports = ModuleJob;\n"
  },
  {
    "url": "internal/modules/esm/module_map.js",
    "ranges": [
      {
        "start": 0,
        "end": 175
      },
      {
        "start": 200,
        "end": 419
      },
      {
        "start": 492,
        "end": 495
      },
      {
        "start": 771,
        "end": 774
      },
      {
        "start": 847,
        "end": 878
      }
    ],
    "text": "'use strict';\n\nconst ModuleJob = require('internal/modules/esm/module_job');\nconst {\n  SafeMap,\n} = primordials;\nlet debug = require('internal/util/debuglog').debuglog('esm', (fn) => {\n  debug = fn;\n});\nconst { ERR_INVALID_ARG_TYPE } = require('internal/errors').codes;\nconst { validateString } = require('internal/validators');\n\n// Tracks the state of the loader-level module cache\nclass ModuleMap extends SafeMap {\n  get(url) {\n    validateString(url, 'url');\n    return super.get(url);\n  }\n  set(url, job) {\n    validateString(url, 'url');\n    if (job instanceof ModuleJob !== true &&\n        typeof job !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE('job', 'ModuleJob', job);\n    }\n    debug(`Storing ${url} in ModuleMap`);\n    return super.set(url, job);\n  }\n  has(url) {\n    validateString(url, 'url');\n    return super.has(url);\n  }\n}\nmodule.exports = ModuleMap;\n"
  },
  {
    "url": "internal/modules/esm/resolve.js",
    "ranges": [
      {
        "start": 0,
        "end": 1873
      },
      {
        "start": 2225,
        "end": 2336
      },
      {
        "start": 2441,
        "end": 2443
      },
      {
        "start": 3781,
        "end": 3783
      },
      {
        "start": 4883,
        "end": 5139
      },
      {
        "start": 5218,
        "end": 5220
      },
      {
        "start": 6891,
        "end": 6893
      },
      {
        "start": 7024,
        "end": 7080
      },
      {
        "start": 7337,
        "end": 7339
      },
      {
        "start": 7426,
        "end": 7464
      },
      {
        "start": 8671,
        "end": 8673
      },
      {
        "start": 8888,
        "end": 8890
      },
      {
        "start": 9089,
        "end": 9091
      },
      {
        "start": 9441,
        "end": 9443
      },
      {
        "start": 9825,
        "end": 9926
      },
      {
        "start": 11589,
        "end": 11644
      },
      {
        "start": 11784,
        "end": 11786
      },
      {
        "start": 13918,
        "end": 13920
      },
      {
        "start": 14855,
        "end": 15040
      },
      {
        "start": 16923,
        "end": 16925
      },
      {
        "start": 18921,
        "end": 18923
      },
      {
        "start": 19036,
        "end": 19149
      },
      {
        "start": 21981,
        "end": 21983
      },
      {
        "start": 22093,
        "end": 22095
      },
      {
        "start": 22366,
        "end": 22368
      },
      {
        "start": 22551,
        "end": 22664
      },
      {
        "start": 23235,
        "end": 23381
      },
      {
        "start": 24789,
        "end": 24791
      },
      {
        "start": 28097,
        "end": 28247
      }
    ],
    "text": "'use strict';\n\nconst {\n  ArrayIsArray,\n  ArrayPrototypeJoin,\n  ArrayPrototypeShift,\n  JSONParse,\n  JSONStringify,\n  ObjectFreeze,\n  ObjectGetOwnPropertyNames,\n  ObjectPrototypeHasOwnProperty,\n  RegExp,\n  RegExpPrototypeTest,\n  SafeMap,\n  SafeSet,\n  String,\n  StringPrototypeEndsWith,\n  StringPrototypeIndexOf,\n  StringPrototypeReplace,\n  StringPrototypeSlice,\n  StringPrototypeSplit,\n  StringPrototypeStartsWith,\n  StringPrototypeSubstr,\n} = primordials;\nconst internalFS = require('internal/fs/utils');\nconst { NativeModule } = require('internal/bootstrap/loaders');\nconst {\n  realpathSync,\n  statSync,\n  Stats,\n} = require('fs');\nconst { getOptionValue } = require('internal/options');\n// Do not eagerly grab .manifest, it may be in TDZ\nconst policy = getOptionValue('--experimental-policy') ?\n  require('internal/process/policy') :\n  null;\nconst { sep, relative } = require('path');\nconst preserveSymlinks = getOptionValue('--preserve-symlinks');\nconst preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\nconst typeFlag = getOptionValue('--input-type');\nconst { URL, pathToFileURL, fileURLToPath } = require('internal/url');\nconst {\n  ERR_INPUT_TYPE_NOT_ALLOWED,\n  ERR_INVALID_ARG_VALUE,\n  ERR_INVALID_MODULE_SPECIFIER,\n  ERR_INVALID_PACKAGE_CONFIG,\n  ERR_INVALID_PACKAGE_TARGET,\n  ERR_MANIFEST_DEPENDENCY_MISSING,\n  ERR_MODULE_NOT_FOUND,\n  ERR_PACKAGE_IMPORT_NOT_DEFINED,\n  ERR_PACKAGE_PATH_NOT_EXPORTED,\n  ERR_UNSUPPORTED_DIR_IMPORT,\n  ERR_UNSUPPORTED_ESM_URL_SCHEME,\n} = require('internal/errors').codes;\nconst { Module: CJSModule } = require('internal/modules/cjs/loader');\n\nconst packageJsonReader = require('internal/modules/package_json_reader');\nconst userConditions = getOptionValue('--conditions');\nconst DEFAULT_CONDITIONS = ObjectFreeze(['node', 'import', ...userConditions]);\nconst DEFAULT_CONDITIONS_SET = new SafeSet(DEFAULT_CONDITIONS);\n\n\nfunction getConditionsSet(conditions) {\n  if (conditions !== undefined && conditions !== DEFAULT_CONDITIONS) {\n    if (!ArrayIsArray(conditions)) {\n      throw new ERR_INVALID_ARG_VALUE('conditions', conditions,\n                                      'expected an array');\n    }\n    return new SafeSet(conditions);\n  }\n  return DEFAULT_CONDITIONS_SET;\n}\n\nconst realpathCache = new SafeMap();\nconst packageJSONCache = new SafeMap();  /* string -> PackageConfig */\n\nfunction tryStatSync(path) {\n  try {\n    return statSync(path);\n  } catch {\n    return new Stats();\n  }\n}\n\nfunction getPackageConfig(path, specifier, base) {\n  const existing = packageJSONCache.get(path);\n  if (existing !== undefined) {\n    return existing;\n  }\n  const source = packageJsonReader.read(path).string;\n  if (source === undefined) {\n    const packageConfig = {\n      pjsonPath: path,\n      exists: false,\n      main: undefined,\n      name: undefined,\n      type: 'none',\n      exports: undefined,\n      imports: undefined,\n    };\n    packageJSONCache.set(path, packageConfig);\n    return packageConfig;\n  }\n\n  let packageJSON;\n  try {\n    packageJSON = JSONParse(source);\n  } catch (error) {\n    throw new ERR_INVALID_PACKAGE_CONFIG(\n      path,\n      (base ? `\"${specifier}\" from ` : '') + fileURLToPath(base || specifier),\n      error.message\n    );\n  }\n\n  let { imports, main, name, type } = packageJSON;\n  const { exports } = packageJSON;\n  if (typeof imports !== 'object' || imports === null) imports = undefined;\n  if (typeof main !== 'string') main = undefined;\n  if (typeof name !== 'string') name = undefined;\n  // Ignore unknown types for forwards compatibility\n  if (type !== 'module' && type !== 'commonjs') type = 'none';\n\n  const packageConfig = {\n    pjsonPath: path,\n    exists: true,\n    main,\n    name,\n    type,\n    exports,\n    imports,\n  };\n  packageJSONCache.set(path, packageConfig);\n  return packageConfig;\n}\n\nfunction getPackageScopeConfig(resolved) {\n  let packageJSONUrl = new URL('./package.json', resolved);\n  while (true) {\n    const packageJSONPath = packageJSONUrl.pathname;\n    if (StringPrototypeEndsWith(packageJSONPath, 'node_modules/package.json'))\n      break;\n    const packageConfig = getPackageConfig(fileURLToPath(packageJSONUrl),\n                                           resolved);\n    if (packageConfig.exists) return packageConfig;\n\n    const lastPackageJSONUrl = packageJSONUrl;\n    packageJSONUrl = new URL('../package.json', packageJSONUrl);\n\n    // Terminates at root where ../package.json equals ../../package.json\n    // (can't just check \"/package.json\" for Windows support).\n    if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) break;\n  }\n  const packageJSONPath = fileURLToPath(packageJSONUrl);\n  const packageConfig = {\n    pjsonPath: packageJSONPath,\n    exists: false,\n    main: undefined,\n    name: undefined,\n    type: 'none',\n    exports: undefined,\n    imports: undefined,\n  };\n  packageJSONCache.set(packageJSONPath, packageConfig);\n  return packageConfig;\n}\n\n/*\n * Legacy CommonJS main resolution:\n * 1. let M = pkg_url + (json main field)\n * 2. TRY(M, M.js, M.json, M.node)\n * 3. TRY(M/index.js, M/index.json, M/index.node)\n * 4. TRY(pkg_url/index.js, pkg_url/index.json, pkg_url/index.node)\n * 5. NOT_FOUND\n */\nfunction fileExists(url) {\n  return tryStatSync(fileURLToPath(url)).isFile();\n}\n\nfunction legacyMainResolve(packageJSONUrl, packageConfig, base) {\n  let guess;\n  if (packageConfig.main !== undefined) {\n    // Note: fs check redundances will be handled by Descriptor cache here.\n    if (fileExists(guess = new URL(`./${packageConfig.main}`,\n                                   packageJSONUrl))) {\n      return guess;\n    }\n    if (fileExists(guess = new URL(`./${packageConfig.main}.js`,\n                                   packageJSONUrl))) {\n      return guess;\n    }\n    if (fileExists(guess = new URL(`./${packageConfig.main}.json`,\n                                   packageJSONUrl))) {\n      return guess;\n    }\n    if (fileExists(guess = new URL(`./${packageConfig.main}.node`,\n                                   packageJSONUrl))) {\n      return guess;\n    }\n    if (fileExists(guess = new URL(`./${packageConfig.main}/index.js`,\n                                   packageJSONUrl))) {\n      return guess;\n    }\n    if (fileExists(guess = new URL(`./${packageConfig.main}/index.json`,\n                                   packageJSONUrl))) {\n      return guess;\n    }\n    if (fileExists(guess = new URL(`./${packageConfig.main}/index.node`,\n                                   packageJSONUrl))) {\n      return guess;\n    }\n    // Fallthrough.\n  }\n  if (fileExists(guess = new URL('./index.js', packageJSONUrl))) {\n    return guess;\n  }\n  // So fs.\n  if (fileExists(guess = new URL('./index.json', packageJSONUrl))) {\n    return guess;\n  }\n  if (fileExists(guess = new URL('./index.node', packageJSONUrl))) {\n    return guess;\n  }\n  // Not found.\n  throw new ERR_MODULE_NOT_FOUND(\n    fileURLToPath(new URL('.', packageJSONUrl)), fileURLToPath(base));\n}\n\nfunction resolveExtensionsWithTryExactName(search) {\n  if (fileExists(search)) return search;\n  return resolveExtensions(search);\n}\n\nconst extensions = ['.js', '.json', '.node', '.mjs'];\nfunction resolveExtensions(search) {\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const guess = new URL(`${search.pathname}${extension}`, search);\n    if (fileExists(guess)) return guess;\n  }\n  return undefined;\n}\n\nfunction resolveIndex(search) {\n  return resolveExtensions(new URL('index', search));\n}\n\nconst encodedSepRegEx = /%2F|%2C/i;\nfunction finalizeResolution(resolved, base) {\n  if (RegExpPrototypeTest(encodedSepRegEx, resolved.pathname))\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      resolved.pathname, 'must not include encoded \"/\" or \"\\\\\" characters',\n      fileURLToPath(base));\n\n  const path = fileURLToPath(resolved);\n  if (getOptionValue('--experimental-specifier-resolution') === 'node') {\n    let file = resolveExtensionsWithTryExactName(resolved);\n    if (file !== undefined) return file;\n    if (!StringPrototypeEndsWith(path, '/')) {\n      file = resolveIndex(new URL(`${resolved}/`));\n      if (file !== undefined) return file;\n    } else {\n      return resolveIndex(resolved) || resolved;\n    }\n    throw new ERR_MODULE_NOT_FOUND(\n      resolved.pathname, fileURLToPath(base), 'module');\n  }\n\n  const stats = tryStatSync(StringPrototypeEndsWith(path, '/') ?\n    StringPrototypeSlice(path, -1) : path);\n  if (stats.isDirectory()) {\n    const err = new ERR_UNSUPPORTED_DIR_IMPORT(path, fileURLToPath(base));\n    err.url = String(resolved);\n    throw err;\n  } else if (!stats.isFile()) {\n    throw new ERR_MODULE_NOT_FOUND(\n      path || resolved.pathname, base && fileURLToPath(base), 'module');\n  }\n\n  return resolved;\n}\n\nfunction throwImportNotDefined(specifier, packageJSONUrl, base) {\n  throw new ERR_PACKAGE_IMPORT_NOT_DEFINED(\n    specifier, packageJSONUrl && fileURLToPath(new URL('.', packageJSONUrl)),\n    fileURLToPath(base));\n}\n\nfunction throwExportsNotFound(subpath, packageJSONUrl, base) {\n  throw new ERR_PACKAGE_PATH_NOT_EXPORTED(\n    fileURLToPath(new URL('.', packageJSONUrl)), subpath,\n    base && fileURLToPath(base));\n}\n\nfunction throwInvalidSubpath(subpath, packageJSONUrl, internal, base) {\n  const reason = `request is not a valid subpath for the \"${internal ?\n    'imports' : 'exports'}\" resolution of ${fileURLToPath(packageJSONUrl)}`;\n  throw new ERR_INVALID_MODULE_SPECIFIER(subpath, reason,\n                                         base && fileURLToPath(base));\n}\n\nfunction throwInvalidPackageTarget(\n  subpath, target, packageJSONUrl, internal, base) {\n  if (typeof target === 'object' && target !== null) {\n    target = JSONStringify(target, null, '');\n  } else {\n    target = `${target}`;\n  }\n  throw new ERR_INVALID_PACKAGE_TARGET(\n    fileURLToPath(new URL('.', packageJSONUrl)), subpath, target,\n    internal, base && fileURLToPath(base));\n}\n\nconst invalidSegmentRegEx = /(^|\\\\|\\/)(\\.\\.?|node_modules)(\\\\|\\/|$)/;\nconst patternRegEx = /\\*/g;\n\nfunction resolvePackageTargetString(\n  target, subpath, match, packageJSONUrl, base, pattern, internal, conditions) {\n  if (subpath !== '' && !pattern && target[target.length - 1] !== '/')\n    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);\n\n  if (!StringPrototypeStartsWith(target, './')) {\n    if (internal && !StringPrototypeStartsWith(target, '../') &&\n        !StringPrototypeStartsWith(target, '/')) {\n      let isURL = false;\n      try {\n        new URL(target);\n        isURL = true;\n      } catch {}\n      if (!isURL) {\n        const exportTarget = pattern ?\n          StringPrototypeReplace(target, patternRegEx, subpath) :\n          target + subpath;\n        return packageResolve(exportTarget, packageJSONUrl, conditions);\n      }\n    }\n    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);\n  }\n\n  if (RegExpPrototypeTest(invalidSegmentRegEx, StringPrototypeSlice(target, 2)))\n    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);\n\n  const resolved = new URL(target, packageJSONUrl);\n  const resolvedPath = resolved.pathname;\n  const packagePath = new URL('.', packageJSONUrl).pathname;\n\n  if (!StringPrototypeStartsWith(resolvedPath, packagePath))\n    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);\n\n  if (subpath === '') return resolved;\n\n  if (RegExpPrototypeTest(invalidSegmentRegEx, subpath))\n    throwInvalidSubpath(match + subpath, packageJSONUrl, internal, base);\n\n  if (pattern)\n    return new URL(StringPrototypeReplace(resolved.href, patternRegEx,\n                                          subpath));\n  return new URL(subpath, resolved);\n}\n\n/**\n * @param {string} key\n * @returns {boolean}\n */\nfunction isArrayIndex(key) {\n  const keyNum = +key;\n  if (`${keyNum}` !== key) return false;\n  return keyNum >= 0 && keyNum < 0xFFFF_FFFF;\n}\n\nfunction resolvePackageTarget(packageJSONUrl, target, subpath, packageSubpath,\n                              base, pattern, internal, conditions) {\n  if (typeof target === 'string') {\n    return resolvePackageTargetString(\n      target, subpath, packageSubpath, packageJSONUrl, base, pattern, internal,\n      conditions);\n  } else if (ArrayIsArray(target)) {\n    if (target.length === 0)\n      return null;\n\n    let lastException;\n    for (let i = 0; i < target.length; i++) {\n      const targetItem = target[i];\n      let resolved;\n      try {\n        resolved = resolvePackageTarget(\n          packageJSONUrl, targetItem, subpath, packageSubpath, base, pattern,\n          internal, conditions);\n      } catch (e) {\n        lastException = e;\n        if (e.code === 'ERR_INVALID_PACKAGE_TARGET')\n          continue;\n        throw e;\n      }\n      if (resolved === undefined)\n        continue;\n      if (resolved === null) {\n        lastException = null;\n        continue;\n      }\n      return resolved;\n    }\n    if (lastException === undefined || lastException === null)\n      return lastException;\n    throw lastException;\n  } else if (typeof target === 'object' && target !== null) {\n    const keys = ObjectGetOwnPropertyNames(target);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (isArrayIndex(key)) {\n        throw new ERR_INVALID_PACKAGE_CONFIG(\n          fileURLToPath(packageJSONUrl), base,\n          '\"exports\" cannot contain numeric property keys.');\n      }\n    }\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (key === 'default' || conditions.has(key)) {\n        const conditionalTarget = target[key];\n        const resolved = resolvePackageTarget(\n          packageJSONUrl, conditionalTarget, subpath, packageSubpath, base,\n          pattern, internal, conditions);\n        if (resolved === undefined)\n          continue;\n        return resolved;\n      }\n    }\n    return undefined;\n  } else if (target === null) {\n    return null;\n  }\n  throwInvalidPackageTarget(packageSubpath, target, packageJSONUrl, internal,\n                            base);\n}\n\nfunction isConditionalExportsMainSugar(exports, packageJSONUrl, base) {\n  if (typeof exports === 'string' || ArrayIsArray(exports)) return true;\n  if (typeof exports !== 'object' || exports === null) return false;\n\n  const keys = ObjectGetOwnPropertyNames(exports);\n  let isConditionalSugar = false;\n  let i = 0;\n  for (let j = 0; j < keys.length; j++) {\n    const key = keys[j];\n    const curIsConditionalSugar = key === '' || key[0] !== '.';\n    if (i++ === 0) {\n      isConditionalSugar = curIsConditionalSugar;\n    } else if (isConditionalSugar !== curIsConditionalSugar) {\n      throw new ERR_INVALID_PACKAGE_CONFIG(\n        fileURLToPath(packageJSONUrl), base,\n        '\"exports\" cannot contain some keys starting with \\'.\\' and some not.' +\n        ' The exports object must either be an object of package subpath keys' +\n        ' or an object of main entry condition name keys only.');\n    }\n  }\n  return isConditionalSugar;\n}\n\n/**\n * @param {URL} packageJSONUrl\n * @param {string} packageSubpath\n * @param {object} packageConfig\n * @param {string} base\n * @param {Set<string>} conditions\n * @returns {URL}\n */\nfunction packageExportsResolve(\n  packageJSONUrl, packageSubpath, packageConfig, base, conditions) {\n  let exports = packageConfig.exports;\n  if (isConditionalExportsMainSugar(exports, packageJSONUrl, base))\n    exports = { '.': exports };\n\n  if (ObjectPrototypeHasOwnProperty(exports, packageSubpath)) {\n    const target = exports[packageSubpath];\n    const resolved = resolvePackageTarget(\n      packageJSONUrl, target, '', packageSubpath, base, false, false, conditions\n    );\n    if (resolved === null || resolved === undefined)\n      throwExportsNotFound(packageSubpath, packageJSONUrl, base);\n    return { resolved, exact: true };\n  }\n\n  let bestMatch = '';\n  const keys = ObjectGetOwnPropertyNames(exports);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (key[key.length - 1] === '*' &&\n        StringPrototypeStartsWith(packageSubpath,\n                                  StringPrototypeSlice(key, 0, -1)) &&\n        packageSubpath.length >= key.length &&\n        key.length > bestMatch.length) {\n      bestMatch = key;\n    } else if (key[key.length - 1] === '/' &&\n      StringPrototypeStartsWith(packageSubpath, key) &&\n      key.length > bestMatch.length) {\n      bestMatch = key;\n    }\n  }\n\n  if (bestMatch) {\n    const target = exports[bestMatch];\n    const pattern = bestMatch[bestMatch.length - 1] === '*';\n    const subpath = StringPrototypeSubstr(packageSubpath, bestMatch.length -\n      (pattern ? 1 : 0));\n    const resolved = resolvePackageTarget(packageJSONUrl, target, subpath,\n                                          bestMatch, base, pattern, false,\n                                          conditions);\n    if (resolved === null || resolved === undefined)\n      throwExportsNotFound(packageSubpath, packageJSONUrl, base);\n    return { resolved, exact: pattern };\n  }\n\n  throwExportsNotFound(packageSubpath, packageJSONUrl, base);\n}\n\nfunction packageImportsResolve(name, base, conditions) {\n  if (name === '#' || StringPrototypeStartsWith(name, '#/')) {\n    const reason = 'is not a valid internal imports specifier name';\n    throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, fileURLToPath(base));\n  }\n  let packageJSONUrl;\n  const packageConfig = getPackageScopeConfig(base);\n  if (packageConfig.exists) {\n    packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);\n    const imports = packageConfig.imports;\n    if (imports) {\n      if (ObjectPrototypeHasOwnProperty(imports, name)) {\n        const resolved = resolvePackageTarget(\n          packageJSONUrl, imports[name], '', name, base, false, true, conditions\n        );\n        if (resolved !== null)\n          return { resolved, exact: true };\n      } else {\n        let bestMatch = '';\n        const keys = ObjectGetOwnPropertyNames(imports);\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          if (key[key.length - 1] === '*' &&\n              StringPrototypeStartsWith(name,\n                                        StringPrototypeSlice(key, 0, -1)) &&\n              name.length >= key.length &&\n              key.length > bestMatch.length) {\n            bestMatch = key;\n          } else if (key[key.length - 1] === '/' &&\n            StringPrototypeStartsWith(name, key) &&\n            key.length > bestMatch.length) {\n            bestMatch = key;\n          }\n        }\n\n        if (bestMatch) {\n          const target = imports[bestMatch];\n          const pattern = bestMatch[bestMatch.length - 1] === '*';\n          const subpath = StringPrototypeSubstr(name, bestMatch.length -\n            (pattern ? 1 : 0));\n          const resolved = resolvePackageTarget(\n            packageJSONUrl, target, subpath, bestMatch, base, pattern, true,\n            conditions);\n          if (resolved !== null)\n            return { resolved, exact: pattern };\n        }\n      }\n    }\n  }\n  throwImportNotDefined(name, packageJSONUrl, base);\n}\n\nfunction getPackageType(url) {\n  const packageConfig = getPackageScopeConfig(url);\n  return packageConfig.type;\n}\n\n/**\n * @param {string} specifier\n * @param {URL} base\n * @param {Set<string>} conditions\n * @returns {URL}\n */\nfunction packageResolve(specifier, base, conditions) {\n  let separatorIndex = StringPrototypeIndexOf(specifier, '/');\n  let validPackageName = true;\n  let isScoped = false;\n  if (specifier[0] === '@') {\n    isScoped = true;\n    if (separatorIndex === -1 || specifier.length === 0) {\n      validPackageName = false;\n    } else {\n      separatorIndex = StringPrototypeIndexOf(\n        specifier, '/', separatorIndex + 1);\n    }\n  }\n\n  const packageName = separatorIndex === -1 ?\n    specifier : StringPrototypeSlice(specifier, 0, separatorIndex);\n\n  // Package name cannot have leading . and cannot have percent-encoding or\n  // separators.\n  for (let i = 0; i < packageName.length; i++) {\n    if (packageName[i] === '%' || packageName[i] === '\\\\') {\n      validPackageName = false;\n      break;\n    }\n  }\n\n  if (!validPackageName) {\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      specifier, 'is not a valid package name', fileURLToPath(base));\n  }\n\n  const packageSubpath = '.' + (separatorIndex === -1 ? '' :\n    StringPrototypeSlice(specifier, separatorIndex));\n\n  // ResolveSelf\n  const packageConfig = getPackageScopeConfig(base);\n  if (packageConfig.exists) {\n    const packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);\n    if (packageConfig.name === packageName &&\n        packageConfig.exports !== undefined && packageConfig.exports !== null) {\n      return packageExportsResolve(\n        packageJSONUrl, packageSubpath, packageConfig, base, conditions\n      ).resolved;\n    }\n  }\n\n  let packageJSONUrl =\n    new URL('./node_modules/' + packageName + '/package.json', base);\n  let packageJSONPath = fileURLToPath(packageJSONUrl);\n  let lastPath;\n  do {\n    const stat = tryStatSync(StringPrototypeSlice(packageJSONPath, 0,\n                                                  packageJSONPath.length - 13));\n    if (!stat.isDirectory()) {\n      lastPath = packageJSONPath;\n      packageJSONUrl = new URL((isScoped ?\n        '../../../../node_modules/' : '../../../node_modules/') +\n        packageName + '/package.json', packageJSONUrl);\n      packageJSONPath = fileURLToPath(packageJSONUrl);\n      continue;\n    }\n\n    // Package match.\n    const packageConfig = getPackageConfig(packageJSONPath, specifier, base);\n    if (packageConfig.exports !== undefined && packageConfig.exports !== null)\n      return packageExportsResolve(\n        packageJSONUrl, packageSubpath, packageConfig, base, conditions\n      ).resolved;\n    if (packageSubpath === '.')\n      return legacyMainResolve(packageJSONUrl, packageConfig, base);\n    return new URL(packageSubpath, packageJSONUrl);\n    // Cross-platform root check.\n  } while (packageJSONPath.length !== lastPath.length);\n\n  // eslint can't handle the above code.\n  // eslint-disable-next-line no-unreachable\n  throw new ERR_MODULE_NOT_FOUND(packageName, fileURLToPath(base));\n}\n\nfunction isBareSpecifier(specifier) {\n  return specifier[0] && specifier[0] !== '/' && specifier[0] !== '.';\n}\n\nfunction isRelativeSpecifier(specifier) {\n  if (specifier[0] === '.') {\n    if (specifier.length === 1 || specifier[1] === '/') return true;\n    if (specifier[1] === '.') {\n      if (specifier.length === 2 || specifier[2] === '/') return true;\n    }\n  }\n  return false;\n}\n\nfunction shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {\n  if (specifier === '') return false;\n  if (specifier[0] === '/') return true;\n  return isRelativeSpecifier(specifier);\n}\n\n/**\n * @param {string} specifier\n * @param {URL} base\n * @param {Set<string>} conditions\n * @returns {URL}\n */\nfunction moduleResolve(specifier, base, conditions) {\n  // Order swapped from spec for minor perf gain.\n  // Ok since relative URLs cannot parse as URLs.\n  let resolved;\n  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n    resolved = new URL(specifier, base);\n  } else if (specifier[0] === '#') {\n    ({ resolved } = packageImportsResolve(specifier, base, conditions));\n  } else {\n    try {\n      resolved = new URL(specifier);\n    } catch {\n      resolved = packageResolve(specifier, base, conditions);\n    }\n  }\n  return finalizeResolution(resolved, base);\n}\n\n/**\n * Try to resolve an import as a CommonJS module\n * @param {string} specifier\n * @param {string} parentURL\n * @returns {boolean|string}\n */\nfunction resolveAsCommonJS(specifier, parentURL) {\n  try {\n    const parent = fileURLToPath(parentURL);\n    const tmpModule = new CJSModule(parent, null);\n    tmpModule.paths = CJSModule._nodeModulePaths(parent);\n\n    let found = CJSModule._resolveFilename(specifier, tmpModule, false);\n\n    // If it is a relative specifier return the relative path\n    // to the parent\n    if (isRelativeSpecifier(specifier)) {\n      found = relative(parent, found);\n      // Add '.separator if the path does not start with '..separator'\n      // This should be a safe assumption because when loading\n      // esm modules there should be always a file specified so\n      // there should not be a specifier like '..' or '.'\n      if (!StringPrototypeStartsWith(found, `..${sep}`)) {\n        found = `.${sep}${found}`;\n      }\n    } else if (isBareSpecifier(specifier)) {\n      // If it is a bare specifier return the relative path within the\n      // module\n      const pkg = StringPrototypeSplit(specifier, '/')[0];\n      const index = StringPrototypeIndexOf(found, pkg);\n      if (index !== -1) {\n        found = StringPrototypeSlice(found, index);\n      }\n    }\n    // Normalize the path separator to give a valid suggestion\n    // on Windows\n    if (process.platform === 'win32') {\n      found = StringPrototypeReplace(found, new RegExp(`\\\\${sep}`, 'g'), '/');\n    }\n    return found;\n  } catch {\n    return false;\n  }\n}\n\nfunction defaultResolve(specifier, context = {}, defaultResolveUnused) {\n  let { parentURL, conditions } = context;\n  if (parentURL && policy?.manifest) {\n    const redirects = policy.manifest.getDependencyMapper(parentURL);\n    if (redirects) {\n      const { resolve, reaction } = redirects;\n      const destination = resolve(specifier, new SafeSet(conditions));\n      let missing = true;\n      if (destination === true) {\n        missing = false;\n      } else if (destination) {\n        const href = destination.href;\n        return { url: href };\n      }\n      if (missing) {\n        reaction(new ERR_MANIFEST_DEPENDENCY_MISSING(\n          parentURL,\n          specifier,\n          ArrayPrototypeJoin([...conditions], ', '))\n        );\n      }\n    }\n  }\n  let parsed;\n  try {\n    parsed = new URL(specifier);\n    if (parsed.protocol === 'data:') {\n      return {\n        url: specifier\n      };\n    }\n  } catch {}\n  if (parsed && parsed.protocol === 'node:')\n    return { url: specifier };\n  if (parsed && parsed.protocol !== 'file:' && parsed.protocol !== 'data:')\n    throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(parsed);\n  if (NativeModule.canBeRequiredByUsers(specifier)) {\n    return {\n      url: 'node:' + specifier\n    };\n  }\n  if (parentURL && StringPrototypeStartsWith(parentURL, 'data:')) {\n    // This is gonna blow up, we want the error\n    new URL(specifier, parentURL);\n  }\n\n  const isMain = parentURL === undefined;\n  if (isMain) {\n    parentURL = pathToFileURL(`${process.cwd()}/`).href;\n\n    // This is the initial entry point to the program, and --input-type has\n    // been passed as an option; but --input-type can only be used with\n    // --eval, --print or STDIN string input. It is not allowed with file\n    // input, to avoid user confusion over how expansive the effect of the\n    // flag should be (i.e. entry point only, package scope surrounding the\n    // entry point, etc.).\n    if (typeFlag)\n      throw new ERR_INPUT_TYPE_NOT_ALLOWED();\n  }\n\n  conditions = getConditionsSet(conditions);\n  let url;\n  try {\n    url = moduleResolve(specifier, parentURL, conditions);\n  } catch (error) {\n    // Try to give the user a hint of what would have been the\n    // resolved CommonJS module\n    if (error.code === 'ERR_MODULE_NOT_FOUND' ||\n        error.code === 'ERR_UNSUPPORTED_DIR_IMPORT') {\n      if (StringPrototypeStartsWith(specifier, 'file://')) {\n        specifier = fileURLToPath(specifier);\n      }\n      const found = resolveAsCommonJS(specifier, parentURL);\n      if (found) {\n        // Modify the stack and message string to include the hint\n        const lines = StringPrototypeSplit(error.stack, '\\n');\n        const hint = `Did you mean to import ${found}?`;\n        error.stack =\n          ArrayPrototypeShift(lines) + '\\n' +\n          hint + '\\n' +\n          ArrayPrototypeJoin(lines, '\\n');\n        error.message += `\\n${hint}`;\n      }\n    }\n    throw error;\n  }\n\n  if (isMain ? !preserveSymlinksMain : !preserveSymlinks) {\n    const urlPath = fileURLToPath(url);\n    const real = realpathSync(urlPath, {\n      [internalFS.realpathCacheKey]: realpathCache\n    });\n    const old = url;\n    url = pathToFileURL(\n      real + (StringPrototypeEndsWith(urlPath, sep) ? '/' : ''));\n    url.search = old.search;\n    url.hash = old.hash;\n  }\n\n  return { url: `${url}` };\n}\n\nmodule.exports = {\n  DEFAULT_CONDITIONS,\n  defaultResolve,\n  encodedSepRegEx,\n  getPackageType,\n  packageExportsResolve,\n  packageImportsResolve\n};\n"
  },
  {
    "url": "internal/modules/esm/transform_source.js",
    "ranges": [
      {
        "start": 0,
        "end": 15
      },
      {
        "start": 157,
        "end": 215
      }
    ],
    "text": "'use strict';\n\nfunction defaultTransformSource(source, { url, format } = {},\n                                defaultTransformSource) {\n  return { source };\n}\nexports.defaultTransformSource = defaultTransformSource;\n"
  },
  {
    "url": "internal/modules/esm/translators.js",
    "ranges": [
      {
        "start": 0,
        "end": 416
      },
      {
        "start": 528,
        "end": 1202
      },
      {
        "start": 1227,
        "end": 1860
      },
      {
        "start": 2152,
        "end": 2286
      },
      {
        "start": 2706,
        "end": 2708
      },
      {
        "start": 2926,
        "end": 2928
      },
      {
        "start": 3073,
        "end": 3075
      },
      {
        "start": 3189,
        "end": 3191
      },
      {
        "start": 3539,
        "end": 3541
      },
      {
        "start": 3711,
        "end": 3793
      },
      {
        "start": 4374,
        "end": 4378
      },
      {
        "start": 5277,
        "end": 5435
      },
      {
        "start": 6741,
        "end": 6745
      },
      {
        "start": 8189,
        "end": 8313
      },
      {
        "start": 8701,
        "end": 8765
      },
      {
        "start": 10884,
        "end": 10950
      },
      {
        "start": 12045,
        "end": 12048
      }
    ],
    "text": "'use strict';\n\n/* global WebAssembly */\n\nconst {\n  ArrayPrototypeMap,\n  Boolean,\n  JSONParse,\n  ObjectGetPrototypeOf,\n  ObjectPrototypeHasOwnProperty,\n  ObjectKeys,\n  PromisePrototypeCatch,\n  PromiseReject,\n  RegExpPrototypeTest,\n  SafeMap,\n  SafeSet,\n  StringPrototypeReplace,\n  StringPrototypeSlice,\n  StringPrototypeSplit,\n  StringPrototypeStartsWith,\n  SyntaxErrorPrototype,\n} = primordials;\n\nlet _TYPES = null;\nfunction lazyTypes() {\n  if (_TYPES !== null) return _TYPES;\n  return _TYPES = require('internal/util/types');\n}\n\nconst { readFileSync } = require('fs');\nconst { extname, isAbsolute } = require('path');\nconst {\n  stripBOM,\n  loadNativeModule\n} = require('internal/modules/cjs/helpers');\nconst {\n  Module: CJSModule,\n  cjsParseCache\n} = require('internal/modules/cjs/loader');\nconst internalURLModule = require('internal/url');\nconst { defaultGetSource } = require(\n  'internal/modules/esm/get_source');\nconst { defaultTransformSource } = require(\n  'internal/modules/esm/transform_source');\nconst createDynamicModule = require(\n  'internal/modules/esm/create_dynamic_module');\nconst { fileURLToPath, URL } = require('url');\nlet debug = require('internal/util/debuglog').debuglog('esm', (fn) => {\n  debug = fn;\n});\nconst { emitExperimentalWarning } = require('internal/util');\nconst {\n  ERR_UNKNOWN_BUILTIN_MODULE,\n  ERR_INVALID_RETURN_PROPERTY_VALUE\n} = require('internal/errors').codes;\nconst { maybeCacheSourceMap } = require('internal/source_map/source_map_cache');\nconst moduleWrap = internalBinding('module_wrap');\nconst { ModuleWrap } = moduleWrap;\nconst { getOptionValue } = require('internal/options');\nconst experimentalImportMetaResolve =\n    getOptionValue('--experimental-import-meta-resolve');\nconst asyncESM = require('internal/process/esm_loader');\nconst { emitWarningSync } = require('internal/process/warning');\n\nlet cjsParse;\nasync function initCJSParse() {\n  if (typeof WebAssembly === 'undefined') {\n    cjsParse = require('internal/deps/cjs-module-lexer/lexer').parse;\n  } else {\n    const { parse, init } =\n        require('internal/deps/cjs-module-lexer/dist/lexer');\n    await init();\n    cjsParse = parse;\n  }\n}\n\nconst translators = new SafeMap();\nexports.translators = translators;\nexports.enrichCJSError = enrichCJSError;\n\nlet DECODER = null;\nfunction assertBufferSource(body, allowString, hookName) {\n  if (allowString && typeof body === 'string') {\n    return;\n  }\n  const { isArrayBufferView, isAnyArrayBuffer } = lazyTypes();\n  if (isArrayBufferView(body) || isAnyArrayBuffer(body)) {\n    return;\n  }\n  throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n    `${allowString ? 'string, ' : ''}array buffer, or typed array`,\n    hookName,\n    'source',\n    body\n  );\n}\n\nfunction stringify(body) {\n  if (typeof body === 'string') return body;\n  assertBufferSource(body, false, 'transformSource');\n  DECODER = DECODER === null ? new TextDecoder() : DECODER;\n  return DECODER.decode(body);\n}\n\nfunction errPath(url) {\n  const parsed = new URL(url);\n  if (parsed.protocol === 'file:') {\n    return fileURLToPath(parsed);\n  }\n  return url;\n}\n\nasync function importModuleDynamically(specifier, { url }) {\n  return asyncESM.ESMLoader.import(specifier, url);\n}\n\nfunction createImportMetaResolve(defaultParentUrl) {\n  return async function resolve(specifier, parentUrl = defaultParentUrl) {\n    return PromisePrototypeCatch(\n      asyncESM.ESMLoader.resolve(specifier, parentUrl),\n      (error) => (\n        error.code === 'ERR_UNSUPPORTED_DIR_IMPORT' ?\n          error.url : PromiseReject(error))\n    );\n  };\n}\n\nfunction initializeImportMeta(meta, { url }) {\n  // Alphabetical\n  if (experimentalImportMetaResolve)\n    meta.resolve = createImportMetaResolve(url);\n  meta.url = url;\n}\n\n// Strategy for loading a standard JavaScript module.\ntranslators.set('module', async function moduleStrategy(url) {\n  let { source } = await this._getSource(\n    url, { format: 'module' }, defaultGetSource);\n  assertBufferSource(source, true, 'getSource');\n  ({ source } = await this._transformSource(\n    source, { url, format: 'module' }, defaultTransformSource));\n  source = stringify(source);\n  maybeCacheSourceMap(url, source);\n  debug(`Translating StandardModule ${url}`);\n  const module = new ModuleWrap(url, undefined, source, 0, 0);\n  moduleWrap.callbackMap.set(module, {\n    initializeImportMeta,\n    importModuleDynamically,\n  });\n  return module;\n});\n\nfunction enrichCJSError(err) {\n  if (err == null || ObjectGetPrototypeOf(err) !== SyntaxErrorPrototype) {\n    return;\n  }\n  const stack = StringPrototypeSplit(err.stack, '\\n');\n  /*\n  * The regular expression below targets the most common import statement\n  * usage. However, some cases are not matching, cases like import statement\n  * after a comment block and/or after a variable definition.\n  */\n  if (StringPrototypeStartsWith(err.message, 'Unexpected token \\'export\\'') ||\n    RegExpPrototypeTest(/^\\s*import(?=[ {'\"*])\\s*(?![ (])/, stack[1])) {\n    // Emit the warning synchronously because we are in the middle of handling\n    // a SyntaxError that will throw and likely terminate the process before an\n    // asynchronous warning would be emitted.\n    emitWarningSync(\n      'To load an ES module, set \"type\": \"module\" in the package.json or use ' +\n      'the .mjs extension.'\n    );\n  }\n}\n\n// Strategy for loading a node-style CommonJS module\nconst isWindows = process.platform === 'win32';\nconst winSepRegEx = /\\//g;\ntranslators.set('commonjs', async function commonjsStrategy(url, isMain) {\n  debug(`Translating CJSModule ${url}`);\n\n  let filename = internalURLModule.fileURLToPath(new URL(url));\n  if (isWindows)\n    filename = StringPrototypeReplace(filename, winSepRegEx, '\\\\');\n\n  if (!cjsParse) await initCJSParse();\n  const { module, exportNames } = cjsPreparseModuleExports(filename);\n  const namesWithDefault = exportNames.has('default') ?\n    [...exportNames] : ['default', ...exportNames];\n\n  return new ModuleWrap(url, undefined, namesWithDefault, function() {\n    debug(`Loading CJSModule ${url}`);\n\n    let exports;\n    if (asyncESM.ESMLoader.cjsCache.has(module)) {\n      exports = asyncESM.ESMLoader.cjsCache.get(module);\n      asyncESM.ESMLoader.cjsCache.delete(module);\n    } else {\n      try {\n        exports = CJSModule._load(filename, undefined, isMain);\n      } catch (err) {\n        enrichCJSError(err);\n        throw err;\n      }\n    }\n\n    for (const exportName of exportNames) {\n      if (!ObjectPrototypeHasOwnProperty(exports, exportName) ||\n          exportName === 'default')\n        continue;\n      // We might trigger a getter -> dont fail.\n      let value;\n      try {\n        value = exports[exportName];\n      } catch {}\n      this.setExport(exportName, value);\n    }\n    this.setExport('default', exports);\n  });\n});\n\nfunction cjsPreparseModuleExports(filename) {\n  let module = CJSModule._cache[filename];\n  if (module) {\n    const cached = cjsParseCache.get(module);\n    if (cached)\n      return { module, exportNames: cached.exportNames };\n  }\n  const loaded = Boolean(module);\n  if (!loaded) {\n    module = new CJSModule(filename);\n    module.filename = filename;\n    module.paths = CJSModule._nodeModulePaths(module.path);\n    CJSModule._cache[filename] = module;\n  }\n\n  let source;\n  try {\n    source = readFileSync(filename, 'utf8');\n  } catch {}\n\n  let exports, reexports;\n  try {\n    ({ exports, reexports } = cjsParse(source || ''));\n  } catch {\n    exports = [];\n    reexports = [];\n  }\n\n  const exportNames = new SafeSet(exports);\n\n  // Set first for cycles.\n  cjsParseCache.set(module, { source, exportNames, loaded });\n\n  if (reexports.length) {\n    module.filename = filename;\n    module.paths = CJSModule._nodeModulePaths(module.path);\n  }\n  for (const reexport of reexports) {\n    let resolved;\n    try {\n      resolved = CJSModule._resolveFilename(reexport, module);\n    } catch {\n      continue;\n    }\n    const ext = extname(resolved);\n    if ((ext === '.js' || ext === '.cjs' || !CJSModule._extensions[ext]) &&\n        isAbsolute(resolved)) {\n      const { exportNames: reexportNames } = cjsPreparseModuleExports(resolved);\n      for (const name of reexportNames)\n        exportNames.add(name);\n    }\n  }\n\n  return { module, exportNames };\n}\n\n// Strategy for loading a node builtin CommonJS module that isn't\n// through normal resolution\ntranslators.set('builtin', async function builtinStrategy(url) {\n  debug(`Translating BuiltinModule ${url}`);\n  // Slice 'node:' scheme\n  const id = StringPrototypeSlice(url, 5);\n  const module = loadNativeModule(id, url, true);\n  if (!StringPrototypeStartsWith(url, 'node:') || !module) {\n    throw new ERR_UNKNOWN_BUILTIN_MODULE(url);\n  }\n  debug(`Loading BuiltinModule ${url}`);\n  return module.getESMFacade();\n});\n\n// Strategy for loading a JSON file\ntranslators.set('json', async function jsonStrategy(url) {\n  emitExperimentalWarning('Importing JSON modules');\n  debug(`Translating JSONModule ${url}`);\n  debug(`Loading JSONModule ${url}`);\n  const pathname = StringPrototypeStartsWith(url, 'file:') ?\n    fileURLToPath(url) : null;\n  let modulePath;\n  let module;\n  if (pathname) {\n    modulePath = isWindows ?\n      StringPrototypeReplace(pathname, winSepRegEx, '\\\\') : pathname;\n    module = CJSModule._cache[modulePath];\n    if (module && module.loaded) {\n      const exports = module.exports;\n      return new ModuleWrap(url, undefined, ['default'], function() {\n        this.setExport('default', exports);\n      });\n    }\n  }\n  let { source } = await this._getSource(\n    url, { format: 'json' }, defaultGetSource);\n  assertBufferSource(source, true, 'getSource');\n  ({ source } = await this._transformSource(\n    source, { url, format: 'json' }, defaultTransformSource));\n  source = stringify(source);\n  if (pathname) {\n    // A require call could have been called on the same file during loading and\n    // that resolves synchronously. To make sure we always return the identical\n    // export, we have to check again if the module already exists or not.\n    module = CJSModule._cache[modulePath];\n    if (module && module.loaded) {\n      const exports = module.exports;\n      return new ModuleWrap(url, undefined, ['default'], function() {\n        this.setExport('default', exports);\n      });\n    }\n  }\n  try {\n    const exports = JSONParse(stripBOM(source));\n    module = {\n      exports,\n      loaded: true\n    };\n  } catch (err) {\n    // TODO (BridgeAR): We could add a NodeCore error that wraps the JSON\n    // parse error instead of just manipulating the original error message.\n    // That would allow to add further properties and maybe additional\n    // debugging information.\n    err.message = errPath(url) + ': ' + err.message;\n    throw err;\n  }\n  if (pathname) {\n    CJSModule._cache[modulePath] = module;\n  }\n  return new ModuleWrap(url, undefined, ['default'], function() {\n    debug(`Parsing JSONModule ${url}`);\n    this.setExport('default', module.exports);\n  });\n});\n\n// Strategy for loading a wasm module\ntranslators.set('wasm', async function(url) {\n  emitExperimentalWarning('Importing Web Assembly modules');\n  let { source } = await this._getSource(\n    url, { format: 'wasm' }, defaultGetSource);\n  assertBufferSource(source, false, 'getSource');\n  ({ source } = await this._transformSource(\n    source, { url, format: 'wasm' }, defaultTransformSource));\n  assertBufferSource(source, false, 'transformSource');\n  debug(`Translating WASMModule ${url}`);\n  let compiled;\n  try {\n    compiled = await WebAssembly.compile(source);\n  } catch (err) {\n    err.message = errPath(url) + ': ' + err.message;\n    throw err;\n  }\n\n  const imports =\n      ArrayPrototypeMap(WebAssembly.Module.imports(compiled),\n                        ({ module }) => module);\n  const exports =\n    ArrayPrototypeMap(WebAssembly.Module.exports(compiled),\n                      ({ name }) => name);\n\n  return createDynamicModule(imports, exports, url, (reflect) => {\n    const { exports } = new WebAssembly.Instance(compiled, reflect.imports);\n    for (const expt of ObjectKeys(exports))\n      reflect.exports[expt].set(exports[expt]);\n  }).module;\n});\n"
  },
  {
    "url": "internal/modules/package_json_reader.js",
    "ranges": [
      {
        "start": 0,
        "end": 270
      },
      {
        "start": 955,
        "end": 984
      }
    ],
    "text": "'use strict';\n\nconst { SafeMap } = primordials;\nconst internalFsBinding = internalBinding('fs');\nconst { pathToFileURL } = require('url');\nconst { toNamespacedPath } = require('path');\n\nconst cache = new SafeMap();\n\nlet manifest;\n\n/**\n *\n * @param {string} jsonPath\n */\nfunction read(jsonPath) {\n  if (cache.has(jsonPath)) {\n    return cache.get(jsonPath);\n  }\n\n  const [string, containsKeys] = internalFsBinding.internalModuleReadJSON(\n    toNamespacedPath(jsonPath)\n  );\n  const result = { string, containsKeys };\n  const { getOptionValue } = require('internal/options');\n  if (string !== undefined) {\n    if (manifest === undefined) {\n      manifest = getOptionValue('--experimental-policy') ?\n        require('internal/process/policy').manifest :\n        null;\n    }\n    if (manifest !== null) {\n      const jsonURL = pathToFileURL(jsonPath);\n      manifest.assertIntegrity(jsonURL, string);\n    }\n  }\n  cache.set(jsonPath, result);\n  return result;\n}\n\nmodule.exports = { read };\n"
  },
  {
    "url": "internal/modules/run_main.js",
    "ranges": [
      {
        "start": 0,
        "end": 1217
      },
      {
        "start": 1552,
        "end": 1554
      },
      {
        "start": 1991,
        "end": 2582
      }
    ],
    "text": "'use strict';\n\nconst CJSLoader = require('internal/modules/cjs/loader');\nconst { Module, toRealPath, readPackageScope } = CJSLoader;\nconst { getOptionValue } = require('internal/options');\nconst path = require('path');\n\nfunction resolveMainPath(main) {\n  // Note extension resolution for the main entry point can be deprecated in a\n  // future major.\n  // Module._findPath is monkey-patchable here.\n  let mainPath = Module._findPath(path.resolve(main), null, true);\n  if (!mainPath)\n    return;\n\n  const preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\n  if (!preserveSymlinksMain)\n    mainPath = toRealPath(mainPath);\n\n  return mainPath;\n}\n\nfunction shouldUseESMLoader(mainPath) {\n  const userLoader = getOptionValue('--experimental-loader');\n  if (userLoader)\n    return true;\n  const esModuleSpecifierResolution =\n    getOptionValue('--experimental-specifier-resolution');\n  if (esModuleSpecifierResolution === 'node')\n    return true;\n  // Determine the module format of the main\n  if (mainPath && mainPath.endsWith('.mjs'))\n    return true;\n  if (!mainPath || mainPath.endsWith('.cjs'))\n    return false;\n  const pkg = readPackageScope(mainPath);\n  return pkg && pkg.data.type === 'module';\n}\n\nfunction runMainESM(mainPath) {\n  const esmLoader = require('internal/process/esm_loader');\n  const { pathToFileURL } = require('internal/url');\n  handleMainPromise(esmLoader.loadESM((ESMLoader) => {\n    const main = path.isAbsolute(mainPath) ?\n      pathToFileURL(mainPath).href : mainPath;\n    return ESMLoader.import(main);\n  }));\n}\n\nfunction handleMainPromise(promise) {\n  // Handle a Promise from running code that potentially does Top-Level Await.\n  // In that case, it makes sense to set the exit code to a specific non-zero\n  // value if the main code never finishes running.\n  function handler() {\n    if (process.exitCode === undefined)\n      process.exitCode = 13;\n  }\n  process.on('exit', handler);\n  return promise.finally(() => process.off('exit', handler));\n}\n\n// For backwards compatibility, we have to run a bunch of\n// monkey-patchable code that belongs to the CJS loader (exposed by\n// `require('module')`) even when the entry point is ESM.\nfunction executeUserEntryPoint(main = process.argv[1]) {\n  const resolvedMain = resolveMainPath(main);\n  const useESMLoader = shouldUseESMLoader(resolvedMain);\n  if (useESMLoader) {\n    runMainESM(resolvedMain || main);\n  } else {\n    // Module._load is the monkey-patchable CJS module loader.\n    Module._load(main, null, true);\n  }\n}\n\nmodule.exports = {\n  executeUserEntryPoint,\n  handleMainPromise,\n};\n"
  },
  {
    "url": "internal/options.js",
    "ranges": [
      {
        "start": 0,
        "end": 316
      },
      {
        "start": 781,
        "end": 898
      }
    ],
    "text": "'use strict';\n\nconst { getOptions, shouldNotRegisterESMLoader } = internalBinding('options');\nconst { options, aliases } = getOptions();\n\nlet warnOnAllowUnauthorized = true;\n\nfunction getOptionValue(option) {\n  const result = options.get(option);\n  if (!result) {\n    return undefined;\n  }\n  return result.value;\n}\n\nfunction getAllowUnauthorized() {\n  const allowUnauthorized = process.env.NODE_TLS_REJECT_UNAUTHORIZED === '0';\n\n  if (allowUnauthorized && warnOnAllowUnauthorized) {\n    warnOnAllowUnauthorized = false;\n    process.emitWarning(\n      'Setting the NODE_TLS_REJECT_UNAUTHORIZED ' +\n      'environment variable to \\'0\\' makes TLS connections ' +\n      'and HTTPS requests insecure by disabling ' +\n      'certificate verification.');\n  }\n  return allowUnauthorized;\n}\n\nmodule.exports = {\n  options,\n  aliases,\n  getOptionValue,\n  getAllowUnauthorized,\n  shouldNotRegisterESMLoader\n};\n"
  },
  {
    "url": "internal/per_context/domexception.js",
    "ranges": [
      {
        "start": 0,
        "end": 205
      },
      {
        "start": 277,
        "end": 281
      },
      {
        "start": 322,
        "end": 541
      },
      {
        "start": 790,
        "end": 829
      },
      {
        "start": 1002,
        "end": 1006
      },
      {
        "start": 1211,
        "end": 1215
      },
      {
        "start": 1426,
        "end": 1430
      },
      {
        "start": 1702,
        "end": 3645
      }
    ],
    "text": "'use strict';\n\nconst {\n  Error,\n  ObjectDefineProperties,\n  ObjectDefineProperty,\n  SafeWeakMap,\n  SafeMap,\n  SymbolToStringTag,\n  TypeError,\n} = primordials;\n\nclass ERR_INVALID_THIS extends TypeError {\n  constructor(type) {\n    super('Value of \"this\" must be of ' + type);\n  }\n\n  get code() { return 'ERR_INVALID_THIS'; }\n}\n\nlet internalsMap;\nlet nameToCodeMap;\nlet isInitialized = false;\n\n// We need to instantiate the maps lazily because they render\n// the snapshot non-rehashable.\n// https://bugs.chromium.org/p/v8/issues/detail?id=6593\nfunction ensureInitialized() {\n  if (isInitialized) {\n    return;\n  }\n  internalsMap = new SafeWeakMap();\n  nameToCodeMap = new SafeMap();\n  forEachCode((name, codeName, value) => {\n    nameToCodeMap.set(name, value);\n  });\n  isInitialized = true;\n}\n\nclass DOMException extends Error {\n  constructor(message = '', name = 'Error') {\n    ensureInitialized();\n    super();\n    internalsMap.set(this, {\n      message: `${message}`,\n      name: `${name}`\n    });\n  }\n\n  get name() {\n    ensureInitialized();\n    const internals = internalsMap.get(this);\n    if (internals === undefined) {\n      throw new ERR_INVALID_THIS('DOMException');\n    }\n    return internals.name;\n  }\n\n  get message() {\n    ensureInitialized();\n    const internals = internalsMap.get(this);\n    if (internals === undefined) {\n      throw new ERR_INVALID_THIS('DOMException');\n    }\n    return internals.message;\n  }\n\n  get code() {\n    ensureInitialized();\n    const internals = internalsMap.get(this);\n    if (internals === undefined) {\n      throw new ERR_INVALID_THIS('DOMException');\n    }\n    const code = nameToCodeMap.get(internals.name);\n    return code === undefined ? 0 : code;\n  }\n}\n\nObjectDefineProperties(DOMException.prototype, {\n  [SymbolToStringTag]: { configurable: true, value: 'DOMException' },\n  name: { enumerable: true, configurable: true },\n  message: { enumerable: true, configurable: true },\n  code: { enumerable: true, configurable: true }\n});\n\nfunction forEachCode(fn) {\n  fn('IndexSizeError', 'INDEX_SIZE_ERR', 1);\n  fn('DOMStringSizeError', 'DOMSTRING_SIZE_ERR', 2);\n  fn('HierarchyRequestError', 'HIERARCHY_REQUEST_ERR', 3);\n  fn('WrongDocumentError', 'WRONG_DOCUMENT_ERR', 4);\n  fn('InvalidCharacterError', 'INVALID_CHARACTER_ERR', 5);\n  fn('NoDataAllowedError', 'NO_DATA_ALLOWED_ERR', 6);\n  fn('NoModificationAllowedError', 'NO_MODIFICATION_ALLOWED_ERR', 7);\n  fn('NotFoundError', 'NOT_FOUND_ERR', 8);\n  fn('NotSupportedError', 'NOT_SUPPORTED_ERR', 9);\n  fn('InUseAttributeError', 'INUSE_ATTRIBUTE_ERR', 10);\n  fn('InvalidStateError', 'INVALID_STATE_ERR', 11);\n  fn('SyntaxError', 'SYNTAX_ERR', 12);\n  fn('InvalidModificationError', 'INVALID_MODIFICATION_ERR', 13);\n  fn('NamespaceError', 'NAMESPACE_ERR', 14);\n  fn('InvalidAccessError', 'INVALID_ACCESS_ERR', 15);\n  fn('ValidationError', 'VALIDATION_ERR', 16);\n  fn('TypeMismatchError', 'TYPE_MISMATCH_ERR', 17);\n  fn('SecurityError', 'SECURITY_ERR', 18);\n  fn('NetworkError', 'NETWORK_ERR', 19);\n  fn('AbortError', 'ABORT_ERR', 20);\n  fn('URLMismatchError', 'URL_MISMATCH_ERR', 21);\n  fn('QuotaExceededError', 'QUOTA_EXCEEDED_ERR', 22);\n  fn('TimeoutError', 'TIMEOUT_ERR', 23);\n  fn('InvalidNodeTypeError', 'INVALID_NODE_TYPE_ERR', 24);\n  fn('DataCloneError', 'DATA_CLONE_ERR', 25);\n  // There are some more error names, but since they don't have codes assigned,\n  // we don't need to care about them.\n}\n\nforEachCode((name, codeName, value) => {\n  const desc = { enumerable: true, value };\n  ObjectDefineProperty(DOMException, codeName, desc);\n  ObjectDefineProperty(DOMException.prototype, codeName, desc);\n});\n\nexports.DOMException = DOMException;\n"
  },
  {
    "url": "internal/per_context/messageport.js",
    "ranges": [
      {
        "start": 0,
        "end": 76
      },
      {
        "start": 183,
        "end": 280
      },
      {
        "start": 724,
        "end": 726
      }
    ],
    "text": "'use strict';\nconst {\n  SymbolFor,\n} = primordials;\n\nclass MessageEvent {\n  constructor(data, target, type) {\n    this.data = data;\n    this.target = target;\n    this.type = type;\n  }\n}\n\nconst kHybridDispatch = SymbolFor('nodejs.internal.kHybridDispatch');\n\nexports.emitMessage = function(data, type) {\n  if (typeof this[kHybridDispatch] === 'function') {\n    this[kHybridDispatch](data, type, undefined);\n    return;\n  }\n\n  const event = new MessageEvent(data, this, type);\n  if (type === 'message') {\n    if (typeof this.onmessage === 'function')\n      this.onmessage(event);\n  } else {\n    // eslint-disable-next-line no-lonely-if\n    if (typeof this.onmessageerror === 'function')\n      this.onmessageerror(event);\n  }\n};\n"
  },
  {
    "url": "internal/per_context/primordials.js",
    "ranges": [
      {
        "start": 0,
        "end": 1038
      },
      {
        "start": 0,
        "end": 1093
      },
      {
        "start": 0,
        "end": 4529
      }
    ],
    "text": "'use strict';\n\n/* eslint-disable no-restricted-globals */\n\n// This file subclasses and stores the JS builtins that come from the VM\n// so that Node.js's builtin modules do not need to later look these up from\n// the global proxy, which can be mutated by users.\n\n// TODO(joyeecheung): we can restrict access to these globals in builtin\n// modules through the JS linter, for example: ban access such as `Object`\n// (which falls back to a lookup in the global proxy) in favor of\n// `primordials.Object` where `primordials` is a lexical variable passed\n// by the native module compiler.\n\nconst ReflectApply = Reflect.apply;\n\n// This function is borrowed from the function with the same name on V8 Extras'\n// `utils` object. V8 implements Reflect.apply very efficiently in conjunction\n// with the spread syntax, such that no additional special case is needed for\n// function calls w/o arguments.\n// Refs: https://github.com/v8/v8/blob/d6ead37d265d7215cf9c5f768f279e21bd170212/src/js/prologue.js#L152-L156\nfunction uncurryThis(func) {\n  return (thisArg, ...args) => ReflectApply(func, thisArg, args);\n}\n\nprimordials.uncurryThis = uncurryThis;\n\nfunction copyProps(src, dest) {\n  for (const key of Reflect.ownKeys(src)) {\n    if (!Reflect.getOwnPropertyDescriptor(dest, key)) {\n      Reflect.defineProperty(\n        dest,\n        key,\n        Reflect.getOwnPropertyDescriptor(src, key));\n    }\n  }\n}\n\nfunction copyPropsRenamed(src, dest, prefix) {\n  for (const key of Reflect.ownKeys(src)) {\n    if (typeof key === 'string') {\n      Reflect.defineProperty(\n        dest,\n        `${prefix}${key[0].toUpperCase()}${key.slice(1)}`,\n        Reflect.getOwnPropertyDescriptor(src, key));\n    }\n  }\n}\n\nfunction copyPropsRenamedBound(src, dest, prefix) {\n  for (const key of Reflect.ownKeys(src)) {\n    if (typeof key === 'string') {\n      const desc = Reflect.getOwnPropertyDescriptor(src, key);\n      if (typeof desc.value === 'function') {\n        desc.value = desc.value.bind(src);\n      }\n      Reflect.defineProperty(\n        dest,\n        `${prefix}${key[0].toUpperCase()}${key.slice(1)}`,\n        desc\n      );\n    }\n  }\n}\n\nfunction copyPrototype(src, dest, prefix) {\n  for (const key of Reflect.ownKeys(src)) {\n    if (typeof key === 'string') {\n      const desc = Reflect.getOwnPropertyDescriptor(src, key);\n      if (typeof desc.value === 'function') {\n        desc.value = uncurryThis(desc.value);\n      }\n      Reflect.defineProperty(\n        dest,\n        `${prefix}${key[0].toUpperCase()}${key.slice(1)}`,\n        desc);\n    }\n  }\n}\n\nfunction makeSafe(unsafe, safe) {\n  copyProps(unsafe.prototype, safe.prototype);\n  copyProps(unsafe, safe);\n  Object.setPrototypeOf(safe.prototype, null);\n  Object.freeze(safe.prototype);\n  Object.freeze(safe);\n  return safe;\n}\n\n// Subclass the constructors because we need to use their prototype\n// methods later.\nprimordials.SafeMap = makeSafe(\n  Map,\n  class SafeMap extends Map {}\n);\nprimordials.SafeWeakMap = makeSafe(\n  WeakMap,\n  class SafeWeakMap extends WeakMap {}\n);\nprimordials.SafeSet = makeSafe(\n  Set,\n  class SafeSet extends Set {}\n);\nprimordials.SafePromise = makeSafe(\n  Promise,\n  class SafePromise extends Promise {}\n);\n\n// Create copies of the namespace objects\n[\n  'JSON',\n  'Math',\n  'Reflect'\n].forEach((name) => {\n  copyPropsRenamed(global[name], primordials, name);\n});\n\n// Create copies of intrinsic objects\n[\n  'Array',\n  'ArrayBuffer',\n  'BigInt',\n  'BigInt64Array',\n  'BigUint64Array',\n  'Boolean',\n  'Date',\n  'Error',\n  'EvalError',\n  'Float32Array',\n  'Float64Array',\n  'Function',\n  'Int16Array',\n  'Int32Array',\n  'Int8Array',\n  'Map',\n  'Number',\n  'Object',\n  'RangeError',\n  'ReferenceError',\n  'RegExp',\n  'Set',\n  'String',\n  'Symbol',\n  'SyntaxError',\n  'TypeError',\n  'URIError',\n  'Uint16Array',\n  'Uint32Array',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'WeakMap',\n  'WeakSet',\n].forEach((name) => {\n  const original = global[name];\n  primordials[name] = original;\n  copyPropsRenamed(original, primordials, name);\n  copyPrototype(original.prototype, primordials, `${name}Prototype`);\n});\n\n// Create copies of intrinsic objects that require a valid `this` to call\n// static methods.\n// Refs: https://www.ecma-international.org/ecma-262/#sec-promise.all\n[\n  'Promise',\n].forEach((name) => {\n  const original = global[name];\n  primordials[name] = original;\n  copyPropsRenamedBound(original, primordials, name);\n  copyPrototype(original.prototype, primordials, `${name}Prototype`);\n});\n\nObject.setPrototypeOf(primordials, null);\nObject.freeze(primordials);\n"
  },
  {
    "url": "internal/priority_queue.js",
    "ranges": [
      {
        "start": 0,
        "end": 815
      },
      {
        "start": 855,
        "end": 859
      },
      {
        "start": 1044,
        "end": 1048
      },
      {
        "start": 1087,
        "end": 1091
      },
      {
        "start": 1759,
        "end": 1763
      },
      {
        "start": 2254,
        "end": 2258
      },
      {
        "start": 2591,
        "end": 2595
      },
      {
        "start": 2761,
        "end": 2765
      },
      {
        "start": 2920,
        "end": 2924
      }
    ],
    "text": "'use strict';\n\nconst {\n  Array,\n  Symbol,\n} = primordials;\n\nconst kCompare = Symbol('compare');\nconst kHeap = Symbol('heap');\nconst kSetPosition = Symbol('setPosition');\nconst kSize = Symbol('size');\n\n// The PriorityQueue is a basic implementation of a binary heap that accepts\n// a custom sorting function via its constructor. This function is passed\n// the two nodes to compare, similar to the native Array#sort. Crucially\n// this enables priority queues that are based on a comparison of more than\n// just a single criteria.\n\nmodule.exports = class PriorityQueue {\n  constructor(comparator, setPosition) {\n    if (comparator !== undefined)\n      this[kCompare] = comparator;\n    if (setPosition !== undefined)\n      this[kSetPosition] = setPosition;\n\n    this[kHeap] = new Array(64);\n    this[kSize] = 0;\n  }\n\n  [kCompare](a, b) {\n    return a - b;\n  }\n\n  insert(value) {\n    const heap = this[kHeap];\n    const pos = ++this[kSize];\n    heap[pos] = value;\n\n    if (heap.length === pos)\n      heap.length *= 2;\n\n    this.percolateUp(pos);\n  }\n\n  peek() {\n    return this[kHeap][1];\n  }\n\n  percolateDown(pos) {\n    const compare = this[kCompare];\n    const setPosition = this[kSetPosition];\n    const heap = this[kHeap];\n    const size = this[kSize];\n    const item = heap[pos];\n\n    while (pos * 2 <= size) {\n      let childIndex = pos * 2 + 1;\n      if (childIndex > size || compare(heap[pos * 2], heap[childIndex]) < 0)\n        childIndex = pos * 2;\n      const child = heap[childIndex];\n      if (compare(item, child) <= 0)\n        break;\n      if (setPosition !== undefined)\n        setPosition(child, pos);\n      heap[pos] = child;\n      pos = childIndex;\n    }\n    heap[pos] = item;\n    if (setPosition !== undefined)\n      setPosition(item, pos);\n  }\n\n  percolateUp(pos) {\n    const heap = this[kHeap];\n    const compare = this[kCompare];\n    const setPosition = this[kSetPosition];\n    const item = heap[pos];\n\n    while (pos > 1) {\n      const parent = heap[pos / 2 | 0];\n      if (compare(parent, item) <= 0)\n        break;\n      heap[pos] = parent;\n      if (setPosition !== undefined)\n        setPosition(parent, pos);\n      pos = pos / 2 | 0;\n    }\n    heap[pos] = item;\n    if (setPosition !== undefined)\n      setPosition(item, pos);\n  }\n\n  removeAt(pos) {\n    const heap = this[kHeap];\n    const size = --this[kSize];\n    heap[pos] = heap[size + 1];\n    heap[size + 1] = undefined;\n\n    if (size > 0 && pos <= size) {\n      if (pos > 1 && this[kCompare](heap[pos / 2 | 0], heap[pos]) > 0)\n        this.percolateUp(pos);\n      else\n        this.percolateDown(pos);\n    }\n  }\n\n  remove(value) {\n    const heap = this[kHeap];\n    const pos = heap.indexOf(value);\n    if (pos < 1)\n      return false;\n\n    this.removeAt(pos);\n\n    return true;\n  }\n\n  shift() {\n    const heap = this[kHeap];\n    const value = heap[1];\n    if (value === undefined)\n      return;\n\n    this.removeAt(1);\n\n    return value;\n  }\n};\n"
  },
  {
    "url": "internal/process/esm_loader.js",
    "ranges": [
      {
        "start": 0,
        "end": 405
      },
      {
        "start": 701,
        "end": 746
      },
      {
        "start": 1137,
        "end": 1202
      },
      {
        "start": 1969,
        "end": 1989
      },
      {
        "start": 2324,
        "end": 2326
      }
    ],
    "text": "'use strict';\n\nconst {\n  ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING,\n} = require('internal/errors').codes;\nconst { Loader } = require('internal/modules/esm/loader');\nconst {\n  hasUncaughtExceptionCaptureCallback,\n} = require('internal/process/execution');\nconst { pathToFileURL } = require('internal/url');\nconst {\n  getModuleFromWrap,\n} = require('internal/vm/module');\n\nexports.initializeImportMetaObject = function(wrap, meta) {\n  const { callbackMap } = internalBinding('module_wrap');\n  if (callbackMap.has(wrap)) {\n    const { initializeImportMeta } = callbackMap.get(wrap);\n    if (initializeImportMeta !== undefined) {\n      initializeImportMeta(meta, getModuleFromWrap(wrap) || wrap);\n    }\n  }\n};\n\nexports.importModuleDynamicallyCallback = async function(wrap, specifier) {\n  const { callbackMap } = internalBinding('module_wrap');\n  if (callbackMap.has(wrap)) {\n    const { importModuleDynamically } = callbackMap.get(wrap);\n    if (importModuleDynamically !== undefined) {\n      return importModuleDynamically(\n        specifier, getModuleFromWrap(wrap) || wrap);\n    }\n  }\n  throw new ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING();\n};\n\nlet ESMLoader = new Loader();\nexports.ESMLoader = ESMLoader;\n\nasync function initializeLoader() {\n  const { getOptionValue } = require('internal/options');\n  const userLoader = getOptionValue('--experimental-loader');\n  if (!userLoader)\n    return;\n  let cwd;\n  try {\n    cwd = process.cwd() + '/';\n  } catch {\n    cwd = 'file:///';\n  }\n  // If --experimental-loader is specified, create a loader with user hooks.\n  // Otherwise create the default loader.\n  const { emitExperimentalWarning } = require('internal/util');\n  emitExperimentalWarning('--experimental-loader');\n  return (async () => {\n    const hooks =\n        await ESMLoader.import(userLoader, pathToFileURL(cwd).href);\n    ESMLoader = new Loader();\n    ESMLoader.hook(hooks);\n    ESMLoader.runGlobalPreloadCode();\n    return exports.ESMLoader = ESMLoader;\n  })();\n}\n\nexports.loadESM = async function loadESM(callback) {\n  try {\n    await initializeLoader();\n    await callback(ESMLoader);\n  } catch (err) {\n    if (hasUncaughtExceptionCaptureCallback()) {\n      process._fatalException(err);\n      return;\n    }\n    internalBinding('errors').triggerUncaughtException(\n      err,\n      true /* fromPromise */\n    );\n  }\n};\n"
  },
  {
    "url": "internal/process/execution.js",
    "ranges": [
      {
        "start": 0,
        "end": 526
      },
      {
        "start": 856,
        "end": 858
      },
      {
        "start": 1298,
        "end": 1300
      },
      {
        "start": 2682,
        "end": 2759
      },
      {
        "start": 3453,
        "end": 3455
      },
      {
        "start": 3556,
        "end": 3558
      },
      {
        "start": 3576,
        "end": 4388
      },
      {
        "start": 6515,
        "end": 6520
      },
      {
        "start": 6725,
        "end": 6944
      }
    ],
    "text": "'use strict';\n\nconst path = require('path');\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_UNCAUGHT_EXCEPTION_CAPTURE_ALREADY_SET,\n    ERR_EVAL_ESM_CANNOT_PRINT,\n  },\n} = require('internal/errors');\n\nconst {\n  executionAsyncId,\n  clearDefaultTriggerAsyncId,\n  clearAsyncIdStack,\n  hasAsyncIdStack,\n  afterHooksExist,\n  emitAfter\n} = require('internal/async_hooks');\n\n// shouldAbortOnUncaughtToggle is a typed array for faster\n// communication with JS.\nconst { shouldAbortOnUncaughtToggle } = internalBinding('util');\n\nfunction tryGetCwd() {\n  try {\n    return process.cwd();\n  } catch {\n    // getcwd(3) can fail if the current working directory has been deleted.\n    // Fall back to the directory name of the (absolute) executable path.\n    // It's not really correct but what are the alternatives?\n    return path.dirname(process.execPath);\n  }\n}\n\nfunction evalModule(source, print) {\n  if (print) {\n    throw new ERR_EVAL_ESM_CANNOT_PRINT();\n  }\n  const { log } = require('internal/console/global');\n  const { loadESM } = require('internal/process/esm_loader');\n  const { handleMainPromise } = require('internal/modules/run_main');\n  return handleMainPromise(loadESM(async (loader) => {\n    const { result } = await loader.eval(source);\n    if (print) {\n      log(result);\n    }\n  }));\n}\n\nfunction evalScript(name, body, breakFirstLine, print) {\n  const CJSModule = require('internal/modules/cjs/loader').Module;\n  const { kVmBreakFirstLineSymbol } = require('internal/util');\n  const { pathToFileURL } = require('url');\n\n  const cwd = tryGetCwd();\n  const origModule = globalThis.module;  // Set e.g. when called from the REPL.\n\n  const module = new CJSModule(name);\n  module.filename = path.join(cwd, name);\n  module.paths = CJSModule._nodeModulePaths(cwd);\n\n  const asyncESM = require('internal/process/esm_loader');\n  const baseUrl = pathToFileURL(module.filename).href;\n\n  // Create wrapper for cache entry\n  const script = `\n    globalThis.module = module;\n    globalThis.exports = exports;\n    globalThis.__dirname = __dirname;\n    globalThis.require = require;\n    return (main) => main();\n  `;\n  globalThis.__filename = name;\n  const result = module._compile(script, `${name}-wrapper`)(() =>\n    require('vm').runInThisContext(body, {\n      filename: name,\n      displayErrors: true,\n      [kVmBreakFirstLineSymbol]: !!breakFirstLine,\n      async importModuleDynamically(specifier) {\n        const loader = await asyncESM.ESMLoader;\n        return loader.import(specifier, baseUrl);\n      }\n    }));\n  if (print) {\n    const { log } = require('internal/console/global');\n    log(result);\n  }\n\n  if (origModule !== undefined)\n    globalThis.module = origModule;\n}\n\nconst exceptionHandlerState = {\n  captureFn: null,\n  reportFlag: false\n};\n\nfunction setUncaughtExceptionCaptureCallback(fn) {\n  if (fn === null) {\n    exceptionHandlerState.captureFn = fn;\n    shouldAbortOnUncaughtToggle[0] = 1;\n    process.report.reportOnUncaughtException = exceptionHandlerState.reportFlag;\n    return;\n  }\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'null'], fn);\n  }\n  if (exceptionHandlerState.captureFn !== null) {\n    throw new ERR_UNCAUGHT_EXCEPTION_CAPTURE_ALREADY_SET();\n  }\n  exceptionHandlerState.captureFn = fn;\n  shouldAbortOnUncaughtToggle[0] = 0;\n  exceptionHandlerState.reportFlag =\n    process.report.reportOnUncaughtException === true;\n  process.report.reportOnUncaughtException = false;\n}\n\nfunction hasUncaughtExceptionCaptureCallback() {\n  return exceptionHandlerState.captureFn !== null;\n}\n\nfunction noop() {}\n\n// XXX(joyeecheung): for some reason this cannot be defined at the top-level\n// and exported to be written to process._fatalException, it has to be\n// returned as an *anonymous function* wrapped inside a factory function,\n// otherwise it breaks the test-timers.setInterval async hooks test -\n// this may indicate that node::errors::TriggerUncaughtException() should\n// fix up the callback scope before calling into process._fatalException,\n// or this function should take extra care of the async hooks before it\n// schedules a setImmediate.\nfunction createOnGlobalUncaughtException() {\n  // The C++ land node::errors::TriggerUncaughtException() will\n  // exit the process if it returns false, and continue execution if it\n  // returns true (which indicates that the exception is handled by the user).\n  return (er, fromPromise) => {\n    // It's possible that defaultTriggerAsyncId was set for a constructor\n    // call that threw and was never cleared. So clear it now.\n    clearDefaultTriggerAsyncId();\n\n    // If diagnostic reporting is enabled, call into its handler to see\n    // whether it is interested in handling the situation.\n    // Ignore if the error is scoped inside a domain.\n    // use == in the checks as we want to allow for null and undefined\n    if (er == null || er.domain == null) {\n      try {\n        const report = internalBinding('report');\n        if (report != null && report.shouldReportOnUncaughtException()) {\n          report.writeReport(er ? er.message : 'Exception',\n                             'Exception',\n                             null,\n                             er ? er : {});\n        }\n      } catch {}  // Ignore the exception. Diagnostic reporting is unavailable.\n    }\n\n    const type = fromPromise ? 'unhandledRejection' : 'uncaughtException';\n    process.emit('uncaughtExceptionMonitor', er, type);\n    if (exceptionHandlerState.captureFn !== null) {\n      exceptionHandlerState.captureFn(er);\n    } else if (!process.emit('uncaughtException', er, type)) {\n      // If someone handled it, then great. Otherwise, die in C++ land\n      // since that means that we'll exit the process, emit the 'exit' event.\n      try {\n        if (!process._exiting) {\n          process._exiting = true;\n          process.exitCode = 1;\n          process.emit('exit', 1);\n        }\n      } catch {\n        // Nothing to be done about it at this point.\n      }\n      return false;\n    }\n\n    // If we handled an error, then make sure any ticks get processed\n    // by ensuring that the next Immediate cycle isn't empty.\n    require('timers').setImmediate(noop);\n\n    // Emit the after() hooks now that the exception has been handled.\n    if (afterHooksExist()) {\n      do {\n        emitAfter(executionAsyncId());\n      } while (hasAsyncIdStack());\n    }\n    // And completely empty the id stack, including anything that may be\n    // cached on the native side.\n    clearAsyncIdStack();\n\n    return true;\n  };\n}\n\nfunction readStdin(callback) {\n  process.stdin.setEncoding('utf8');\n\n  let code = '';\n  process.stdin.on('data', (d) => {\n    code += d;\n  });\n\n  process.stdin.on('end', () => {\n    callback(code);\n  });\n}\n\nmodule.exports = {\n  readStdin,\n  tryGetCwd,\n  evalModule,\n  evalScript,\n  onGlobalUncaughtException: createOnGlobalUncaughtException(),\n  setUncaughtExceptionCaptureCallback,\n  hasUncaughtExceptionCaptureCallback\n};\n"
  },
  {
    "url": "internal/process/per_thread.js",
    "ranges": [
      {
        "start": 0,
        "end": 796
      },
      {
        "start": 884,
        "end": 1173
      },
      {
        "start": 1255,
        "end": 1466
      },
      {
        "start": 3025,
        "end": 3178
      },
      {
        "start": 3315,
        "end": 3539
      },
      {
        "start": 4142,
        "end": 4329
      },
      {
        "start": 4423,
        "end": 4468
      },
      {
        "start": 4694,
        "end": 4698
      },
      {
        "start": 5136,
        "end": 5140
      },
      {
        "start": 5785,
        "end": 5836
      },
      {
        "start": 6569,
        "end": 6914
      },
      {
        "start": 9974,
        "end": 10598
      }
    ],
    "text": "'use strict';\n\n// This files contains process bootstrappers that can be\n// run when setting up each thread, including the main\n// thread and the worker threads.\n\nconst {\n  ArrayIsArray,\n  BigUint64Array,\n  Float64Array,\n  NumberMAX_SAFE_INTEGER,\n  ObjectDefineProperties,\n  ObjectDefineProperty,\n  ObjectFreeze,\n  ObjectGetOwnPropertyDescriptors,\n  RegExpPrototypeTest,\n  Set,\n  SetPrototype,\n  SetPrototypeHas,\n  StringPrototypeReplace,\n  Uint32Array,\n} = primordials;\n\nconst {\n  errnoException,\n  codes: {\n    ERR_ASSERTION,\n    ERR_CPU_USAGE,\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_OPT_VALUE,\n    ERR_OUT_OF_RANGE,\n    ERR_UNKNOWN_SIGNAL\n  }\n} = require('internal/errors');\nconst format = require('internal/util/inspect').format;\nconst constants = internalBinding('constants').os.signals;\n\nfunction assert(x, msg) {\n  if (!x) throw new ERR_ASSERTION(msg || 'assertion error');\n}\n\n// The execution of this function itself should not cause any side effects.\nfunction wrapProcessMethods(binding) {\n  const {\n    hrtime: _hrtime,\n    hrtimeBigInt: _hrtimeBigInt,\n    cpuUsage: _cpuUsage,\n    memoryUsage: _memoryUsage,\n    resourceUsage: _resourceUsage\n  } = binding;\n\n  function _rawDebug(...args) {\n    binding._rawDebug(format.apply(null, args));\n  }\n\n  // Create the argument array that will be passed to the native function.\n  const cpuValues = new Float64Array(2);\n\n  // Replace the native function with the JS version that calls the native\n  // function.\n  function cpuUsage(prevValue) {\n    // If a previous value was passed in, ensure it has the correct shape.\n    if (prevValue) {\n      if (!previousValueIsValid(prevValue.user)) {\n        if (typeof prevValue !== 'object')\n          throw new ERR_INVALID_ARG_TYPE('prevValue', 'object', prevValue);\n\n        if (typeof prevValue.user !== 'number') {\n          throw new ERR_INVALID_ARG_TYPE('prevValue.user',\n                                         'number', prevValue.user);\n        }\n        throw new ERR_INVALID_OPT_VALUE.RangeError('prevValue.user',\n                                                   prevValue.user);\n      }\n\n      if (!previousValueIsValid(prevValue.system)) {\n        if (typeof prevValue.system !== 'number') {\n          throw new ERR_INVALID_ARG_TYPE('prevValue.system',\n                                         'number', prevValue.system);\n        }\n        throw new ERR_INVALID_OPT_VALUE.RangeError('prevValue.system',\n                                                   prevValue.system);\n      }\n    }\n\n    // Call the native function to get the current values.\n    const errmsg = _cpuUsage(cpuValues);\n    if (errmsg) {\n      throw new ERR_CPU_USAGE(errmsg);\n    }\n\n    // If a previous value was passed in, return diff of current from previous.\n    if (prevValue) {\n      return {\n        user: cpuValues[0] - prevValue.user,\n        system: cpuValues[1] - prevValue.system\n      };\n    }\n\n    // If no previous value passed in, return current value.\n    return {\n      user: cpuValues[0],\n      system: cpuValues[1]\n    };\n  }\n\n  // Ensure that a previously passed in value is valid. Currently, the native\n  // implementation always returns numbers <= Number.MAX_SAFE_INTEGER.\n  function previousValueIsValid(num) {\n    return typeof num === 'number' &&\n        num <= NumberMAX_SAFE_INTEGER &&\n        num >= 0;\n  }\n\n  // The 3 entries filled in by the original process.hrtime contains\n  // the upper/lower 32 bits of the second part of the value,\n  // and the remaining nanoseconds of the value.\n  const hrValues = new Uint32Array(3);\n\n  function hrtime(time) {\n    _hrtime(hrValues);\n\n    if (time !== undefined) {\n      if (!ArrayIsArray(time)) {\n        throw new ERR_INVALID_ARG_TYPE('time', 'Array', time);\n      }\n      if (time.length !== 2) {\n        throw new ERR_OUT_OF_RANGE('time', 2, time.length);\n      }\n\n      const sec = (hrValues[0] * 0x100000000 + hrValues[1]) - time[0];\n      const nsec = hrValues[2] - time[1];\n      const needsBorrow = nsec < 0;\n      return [needsBorrow ? sec - 1 : sec, needsBorrow ? nsec + 1e9 : nsec];\n    }\n\n    return [\n      hrValues[0] * 0x100000000 + hrValues[1],\n      hrValues[2]\n    ];\n  }\n\n  // Use a BigUint64Array in the closure because this is actually a bit\n  // faster than simply returning a BigInt from C++ in V8 7.1.\n  const hrBigintValues = new BigUint64Array(1);\n  function hrtimeBigInt() {\n    _hrtimeBigInt(hrBigintValues);\n    return hrBigintValues[0];\n  }\n\n  const memValues = new Float64Array(5);\n  function memoryUsage() {\n    _memoryUsage(memValues);\n    return {\n      rss: memValues[0],\n      heapTotal: memValues[1],\n      heapUsed: memValues[2],\n      external: memValues[3],\n      arrayBuffers: memValues[4]\n    };\n  }\n\n  function exit(code) {\n    if (code || code === 0)\n      process.exitCode = code;\n\n    if (!process._exiting) {\n      process._exiting = true;\n      process.emit('exit', process.exitCode || 0);\n    }\n    // FIXME(joyeecheung): This is an undocumented API that gets monkey-patched\n    // in the user land. Either document it, or deprecate it in favor of a\n    // better public alternative.\n    process.reallyExit(process.exitCode || 0);\n  }\n\n  function kill(pid, sig) {\n    let err;\n\n    // eslint-disable-next-line eqeqeq\n    if (pid != (pid | 0)) {\n      throw new ERR_INVALID_ARG_TYPE('pid', 'number', pid);\n    }\n\n    // Preserve null signal\n    if (sig === (sig | 0)) {\n      // XXX(joyeecheung): we have to use process._kill here because\n      // it's monkey-patched by tests.\n      err = process._kill(pid, sig);\n    } else {\n      sig = sig || 'SIGTERM';\n      if (constants[sig]) {\n        err = process._kill(pid, constants[sig]);\n      } else {\n        throw new ERR_UNKNOWN_SIGNAL(sig);\n      }\n    }\n\n    if (err)\n      throw errnoException(err, 'kill');\n\n    return true;\n  }\n\n  const resourceValues = new Float64Array(16);\n  function resourceUsage() {\n    _resourceUsage(resourceValues);\n    return {\n      userCPUTime: resourceValues[0],\n      systemCPUTime: resourceValues[1],\n      maxRSS: resourceValues[2],\n      sharedMemorySize: resourceValues[3],\n      unsharedDataSize: resourceValues[4],\n      unsharedStackSize: resourceValues[5],\n      minorPageFault: resourceValues[6],\n      majorPageFault: resourceValues[7],\n      swappedOut: resourceValues[8],\n      fsRead: resourceValues[9],\n      fsWrite: resourceValues[10],\n      ipcSent: resourceValues[11],\n      ipcReceived: resourceValues[12],\n      signalsCount: resourceValues[13],\n      voluntaryContextSwitches: resourceValues[14],\n      involuntaryContextSwitches: resourceValues[15]\n    };\n  }\n\n\n  return {\n    _rawDebug,\n    hrtime,\n    hrtimeBigInt,\n    cpuUsage,\n    resourceUsage,\n    memoryUsage,\n    kill,\n    exit\n  };\n}\n\nconst replaceUnderscoresRegex = /_/g;\nconst leadingDashesRegex = /^--?/;\nconst trailingValuesRegex = /=.*$/;\n\n// This builds the initial process.allowedNodeEnvironmentFlags\n// from data in the config binding.\nfunction buildAllowedFlags() {\n  const {\n    envSettings: { kAllowedInEnvironment }\n  } = internalBinding('options');\n  const { options, aliases } = require('internal/options');\n\n  const allowedNodeEnvironmentFlags = [];\n  for (const [name, info] of options) {\n    if (info.envVarSettings === kAllowedInEnvironment) {\n      allowedNodeEnvironmentFlags.push(name);\n    }\n  }\n\n  for (const [ from, expansion ] of aliases) {\n    let isAccepted = true;\n    for (const to of expansion) {\n      if (!to.startsWith('-') || to === '--') continue;\n      const recursiveExpansion = aliases.get(to);\n      if (recursiveExpansion) {\n        if (recursiveExpansion[0] === to)\n          recursiveExpansion.splice(0, 1);\n        expansion.push(...recursiveExpansion);\n        continue;\n      }\n      isAccepted = options.get(to).envVarSettings === kAllowedInEnvironment;\n      if (!isAccepted) break;\n    }\n    if (isAccepted) {\n      let canonical = from;\n      if (canonical.endsWith('='))\n        canonical = canonical.substr(0, canonical.length - 1);\n      if (canonical.endsWith(' <arg>'))\n        canonical = canonical.substr(0, canonical.length - 4);\n      allowedNodeEnvironmentFlags.push(canonical);\n    }\n  }\n\n  const trimLeadingDashes =\n    (flag) => StringPrototypeReplace(flag, leadingDashesRegex, '');\n\n  // Save these for comparison against flags provided to\n  // process.allowedNodeEnvironmentFlags.has() which lack leading dashes.\n  // Avoid interference w/ user code by flattening `Set.prototype` into\n  // each object.\n  const nodeFlags = ObjectDefineProperties(\n    new Set(allowedNodeEnvironmentFlags.map(trimLeadingDashes)),\n    ObjectGetOwnPropertyDescriptors(SetPrototype)\n  );\n\n  class NodeEnvironmentFlagsSet extends Set {\n    constructor(...args) {\n      super(...args);\n\n      // The super constructor consumes `add`, but\n      // disallow any future adds.\n      ObjectDefineProperty(this, 'add', {\n        value: () => this\n      });\n    }\n\n    delete() {\n      // No-op, `Set` API compatible\n      return false;\n    }\n\n    clear() {\n      // No-op\n    }\n\n    has(key) {\n      // This will return `true` based on various possible\n      // permutations of a flag, including present/missing leading\n      // dash(es) and/or underscores-for-dashes.\n      // Strips any values after `=`, inclusive.\n      // TODO(addaleax): It might be more flexible to run the option parser\n      // on a dummy option set and see whether it rejects the argument or\n      // not.\n      if (typeof key === 'string') {\n        key = StringPrototypeReplace(key, replaceUnderscoresRegex, '-');\n        if (RegExpPrototypeTest(leadingDashesRegex, key)) {\n          key = StringPrototypeReplace(key, trailingValuesRegex, '');\n          return SetPrototypeHas(this, key);\n        }\n        return SetPrototypeHas(nodeFlags, key);\n      }\n      return false;\n    }\n  }\n\n  ObjectFreeze(NodeEnvironmentFlagsSet.prototype.constructor);\n  ObjectFreeze(NodeEnvironmentFlagsSet.prototype);\n\n  return ObjectFreeze(new NodeEnvironmentFlagsSet(\n    allowedNodeEnvironmentFlags\n  ));\n}\n\n// Lazy load internal/trace_events_async_hooks only if the async_hooks\n// trace event category is enabled.\nlet traceEventsAsyncHook;\n// Dynamically enable/disable the traceEventsAsyncHook\nfunction toggleTraceCategoryState(asyncHooksEnabled) {\n  if (asyncHooksEnabled) {\n    if (!traceEventsAsyncHook) {\n      traceEventsAsyncHook =\n        require('internal/trace_events_async_hooks').createHook();\n    }\n    traceEventsAsyncHook.enable();\n  } else if (traceEventsAsyncHook) {\n    traceEventsAsyncHook.disable();\n  }\n}\n\nmodule.exports = {\n  toggleTraceCategoryState,\n  assert,\n  buildAllowedFlags,\n  wrapProcessMethods\n};\n"
  },
  {
    "url": "internal/process/promises.js",
    "ranges": [
      {
        "start": 0,
        "end": 1918
      },
      {
        "start": 2008,
        "end": 2010
      },
      {
        "start": 2089,
        "end": 2091
      },
      {
        "start": 2626,
        "end": 2628
      },
      {
        "start": 3197,
        "end": 3199
      },
      {
        "start": 3449,
        "end": 3451
      },
      {
        "start": 3745,
        "end": 3747
      },
      {
        "start": 4563,
        "end": 4635
      },
      {
        "start": 5531,
        "end": 5564
      },
      {
        "start": 5849,
        "end": 6022
      },
      {
        "start": 8506,
        "end": 8508
      },
      {
        "start": 8926,
        "end": 8928
      },
      {
        "start": 9398,
        "end": 9605
      }
    ],
    "text": "'use strict';\n\nconst {\n  Error,\n  ObjectDefineProperty,\n  WeakMap,\n} = primordials;\n\nconst {\n  tickInfo,\n  promiseRejectEvents: {\n    kPromiseRejectWithNoHandler,\n    kPromiseHandlerAddedAfterReject,\n    kPromiseResolveAfterResolved,\n    kPromiseRejectAfterResolved\n  },\n  setPromiseRejectCallback\n} = internalBinding('task_queue');\n\nconst {\n  noSideEffectsToString,\n  triggerUncaughtException\n} = internalBinding('errors');\n\n// *Must* match Environment::TickInfo::Fields in src/env.h.\nconst kHasRejectionToWarn = 1;\n\nconst maybeUnhandledPromises = new WeakMap();\nconst pendingUnhandledRejections = [];\nconst asyncHandledRejections = [];\nlet lastPromiseId = 0;\n\n// --unhandled-rejections=none:\n// Emit 'unhandledRejection', but do not emit any warning.\nconst kIgnoreUnhandledRejections = 0;\n\n// --unhandled-rejections=warn:\n// Emit 'unhandledRejection', then emit 'UnhandledPromiseRejectionWarning'.\nconst kAlwaysWarnUnhandledRejections = 1;\n\n// --unhandled-rejections=strict:\n// Emit 'uncaughtException'. If it's not handled, print the error to stderr\n// and exit the process.\n// Otherwise, emit 'unhandledRejection'. If 'unhandledRejection' is not\n// handled, emit 'UnhandledPromiseRejectionWarning'.\nconst kStrictUnhandledRejections = 2;\n\n// --unhandled-rejections=throw:\n// Emit 'unhandledRejection', if it's unhandled, emit\n// 'uncaughtException'. If it's not handled, print the error to stderr\n// and exit the process.\nconst kThrowUnhandledRejections = 3;\n\n// --unhandled-rejections=warn-with-error-code:\n// Emit 'unhandledRejection', if it's unhandled, emit\n// 'UnhandledPromiseRejectionWarning', then set process exit code to 1.\n\nconst kWarnWithErrorCodeUnhandledRejections = 4;\n\n// --unhandled-rejections is unset:\n// Emit 'unhandledRejection', if it's unhandled, emit\n// 'UnhandledPromiseRejectionWarning', then emit deprecation warning.\nconst kDefaultUnhandledRejections = 5;\n\nlet unhandledRejectionsMode;\n\nfunction setHasRejectionToWarn(value) {\n  tickInfo[kHasRejectionToWarn] = value ? 1 : 0;\n}\n\nfunction hasRejectionToWarn() {\n  return tickInfo[kHasRejectionToWarn] === 1;\n}\n\nfunction getUnhandledRejectionsMode() {\n  const { getOptionValue } = require('internal/options');\n  switch (getOptionValue('--unhandled-rejections')) {\n    case 'none':\n      return kIgnoreUnhandledRejections;\n    case 'warn':\n      return kAlwaysWarnUnhandledRejections;\n    case 'strict':\n      return kStrictUnhandledRejections;\n    case 'throw':\n      return kThrowUnhandledRejections;\n    case 'warn-with-error-code':\n      return kWarnWithErrorCodeUnhandledRejections;\n    default:\n      return kDefaultUnhandledRejections;\n  }\n}\n\nfunction promiseRejectHandler(type, promise, reason) {\n  if (unhandledRejectionsMode === undefined) {\n    unhandledRejectionsMode = getUnhandledRejectionsMode();\n  }\n  switch (type) {\n    case kPromiseRejectWithNoHandler:\n      unhandledRejection(promise, reason);\n      break;\n    case kPromiseHandlerAddedAfterReject:\n      handledRejection(promise);\n      break;\n    case kPromiseResolveAfterResolved:\n      resolveError('resolve', promise, reason);\n      break;\n    case kPromiseRejectAfterResolved:\n      resolveError('reject', promise, reason);\n      break;\n  }\n}\n\nfunction resolveError(type, promise, reason) {\n  // We have to wrap this in a next tick. Otherwise the error could be caught by\n  // the executed promise.\n  process.nextTick(() => {\n    process.emit('multipleResolves', type, promise, reason);\n  });\n}\n\nfunction unhandledRejection(promise, reason) {\n  maybeUnhandledPromises.set(promise, {\n    reason,\n    uid: ++lastPromiseId,\n    warned: false\n  });\n  // This causes the promise to be referenced at least for one tick.\n  pendingUnhandledRejections.push(promise);\n  setHasRejectionToWarn(true);\n}\n\nfunction handledRejection(promise) {\n  const promiseInfo = maybeUnhandledPromises.get(promise);\n  if (promiseInfo !== undefined) {\n    maybeUnhandledPromises.delete(promise);\n    if (promiseInfo.warned) {\n      const { uid } = promiseInfo;\n      // Generate the warning object early to get a good stack trace.\n      // eslint-disable-next-line no-restricted-syntax\n      const warning = new Error('Promise rejection was handled ' +\n                                `asynchronously (rejection id: ${uid})`);\n      warning.name = 'PromiseRejectionHandledWarning';\n      warning.id = uid;\n      asyncHandledRejections.push({ promise, warning });\n      setHasRejectionToWarn(true);\n      return;\n    }\n  }\n  if (maybeUnhandledPromises.size === 0 && asyncHandledRejections.length === 0)\n    setHasRejectionToWarn(false);\n}\n\nconst unhandledRejectionErrName = 'UnhandledPromiseRejectionWarning';\nfunction emitUnhandledRejectionWarning(uid, reason) {\n  const warning = getErrorWithoutStack(\n    unhandledRejectionErrName,\n    'Unhandled promise rejection. This error originated either by ' +\n      'throwing inside of an async function without a catch block, ' +\n      'or by rejecting a promise which was not handled with .catch(). ' +\n      'To terminate the node process on unhandled promise ' +\n      'rejection, use the CLI flag `--unhandled-rejections=strict` (see ' +\n      'https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode). ' +\n      `(rejection id: ${uid})`\n  );\n  try {\n    if (reason instanceof Error) {\n      warning.stack = reason.stack;\n      process.emitWarning(reason.stack, unhandledRejectionErrName);\n    } else {\n      process.emitWarning(\n        noSideEffectsToString(reason), unhandledRejectionErrName);\n    }\n  } catch {}\n\n  process.emitWarning(warning);\n}\n\nlet deprecationWarned = false;\nfunction emitDeprecationWarning() {\n  process.emitWarning(\n    'Unhandled promise rejections are deprecated. In the future, ' +\n    'promise rejections that are not handled will terminate the ' +\n    'Node.js process with a non-zero exit code.',\n    'DeprecationWarning', 'DEP0018');\n}\n\n// If this method returns true, we've executed user code or triggered\n// a warning to be emitted which requires the microtask and next tick\n// queues to be drained again.\nfunction processPromiseRejections() {\n  let maybeScheduledTicksOrMicrotasks = asyncHandledRejections.length > 0;\n\n  while (asyncHandledRejections.length > 0) {\n    const { promise, warning } = asyncHandledRejections.shift();\n    if (!process.emit('rejectionHandled', promise)) {\n      process.emitWarning(warning);\n    }\n  }\n\n  let len = pendingUnhandledRejections.length;\n  while (len--) {\n    const promise = pendingUnhandledRejections.shift();\n    const promiseInfo = maybeUnhandledPromises.get(promise);\n    if (promiseInfo === undefined) {\n      continue;\n    }\n    promiseInfo.warned = true;\n    const { reason, uid } = promiseInfo;\n    switch (unhandledRejectionsMode) {\n      case kStrictUnhandledRejections: {\n        const err = reason instanceof Error ?\n          reason : generateUnhandledRejectionError(reason);\n        triggerUncaughtException(err, true /* fromPromise */);\n        const handled = process.emit('unhandledRejection', reason, promise);\n        if (!handled) emitUnhandledRejectionWarning(uid, reason);\n        break;\n      }\n      case kIgnoreUnhandledRejections: {\n        process.emit('unhandledRejection', reason, promise);\n        break;\n      }\n      case kAlwaysWarnUnhandledRejections: {\n        process.emit('unhandledRejection', reason, promise);\n        emitUnhandledRejectionWarning(uid, reason);\n        break;\n      }\n      case kThrowUnhandledRejections: {\n        const handled = process.emit('unhandledRejection', reason, promise);\n        if (!handled) {\n          const err = reason instanceof Error ?\n            reason : generateUnhandledRejectionError(reason);\n          triggerUncaughtException(err, true /* fromPromise */);\n        }\n        break;\n      }\n      case kWarnWithErrorCodeUnhandledRejections: {\n        const handled = process.emit('unhandledRejection', reason, promise);\n        if (!handled) {\n          emitUnhandledRejectionWarning(uid, reason);\n          process.exitCode = 1;\n        }\n        break;\n      }\n      case kDefaultUnhandledRejections: {\n        const handled = process.emit('unhandledRejection', reason, promise);\n        if (!handled) {\n          emitUnhandledRejectionWarning(uid, reason);\n          if (!deprecationWarned) {\n            emitDeprecationWarning();\n            deprecationWarned = true;\n          }\n        }\n        break;\n      }\n    }\n    maybeScheduledTicksOrMicrotasks = true;\n  }\n  return maybeScheduledTicksOrMicrotasks ||\n         pendingUnhandledRejections.length !== 0;\n}\n\nfunction getErrorWithoutStack(name, message) {\n  // Reset the stack to prevent any overhead.\n  const tmp = Error.stackTraceLimit;\n  Error.stackTraceLimit = 0;\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(message);\n  Error.stackTraceLimit = tmp;\n  ObjectDefineProperty(err, 'name', {\n    value: name,\n    enumerable: false,\n    writable: true,\n    configurable: true,\n  });\n  return err;\n}\n\nfunction generateUnhandledRejectionError(reason) {\n  const message =\n    'This error originated either by ' +\n    'throwing inside of an async function without a catch block, ' +\n    'or by rejecting a promise which was not handled with .catch().' +\n    ' The promise rejected with the reason ' +\n    `\"${noSideEffectsToString(reason)}\".`;\n\n  const err = getErrorWithoutStack('UnhandledPromiseRejection', message);\n  err.code = 'ERR_UNHANDLED_REJECTION';\n  return err;\n}\n\nfunction listenForRejections() {\n  setPromiseRejectCallback(promiseRejectHandler);\n}\n\nmodule.exports = {\n  hasRejectionToWarn,\n  setHasRejectionToWarn,\n  listenForRejections,\n  processPromiseRejections\n};\n"
  },
  {
    "url": "internal/process/report.js",
    "ranges": [
      {
        "start": 0,
        "end": 298
      },
      {
        "start": 805,
        "end": 809
      },
      {
        "start": 1045,
        "end": 1049
      },
      {
        "start": 1100,
        "end": 1104
      },
      {
        "start": 1192,
        "end": 1196
      },
      {
        "start": 1245,
        "end": 1249
      },
      {
        "start": 1337,
        "end": 1341
      },
      {
        "start": 1388,
        "end": 1392
      },
      {
        "start": 1469,
        "end": 1473
      },
      {
        "start": 1518,
        "end": 1522
      },
      {
        "start": 1659,
        "end": 1663
      },
      {
        "start": 1735,
        "end": 1739
      },
      {
        "start": 1923,
        "end": 1927
      },
      {
        "start": 1991,
        "end": 1995
      },
      {
        "start": 2222,
        "end": 2226
      },
      {
        "start": 2312,
        "end": 2316
      },
      {
        "start": 2514,
        "end": 2692
      },
      {
        "start": 2816,
        "end": 2818
      },
      {
        "start": 2892,
        "end": 2945
      }
    ],
    "text": "'use strict';\nconst {\n  ERR_INVALID_ARG_TYPE,\n  ERR_SYNTHETIC\n} = require('internal/errors').codes;\nconst {\n  validateSignalName,\n  validateString,\n  validateBoolean,\n} = require('internal/validators');\nconst nr = internalBinding('report');\nconst {\n  JSONParse,\n} = primordials;\nconst report = {\n  writeReport(file, err) {\n    if (typeof file === 'object' && file !== null) {\n      err = file;\n      file = undefined;\n    } else if (file !== undefined && typeof file !== 'string') {\n      throw new ERR_INVALID_ARG_TYPE('file', 'String', file);\n    } else if (err === undefined) {\n      err = new ERR_SYNTHETIC();\n    } else if (err === null || typeof err !== 'object') {\n      throw new ERR_INVALID_ARG_TYPE('err', 'Object', err);\n    }\n\n    return nr.writeReport('JavaScript API', 'API', file, err);\n  },\n  getReport(err) {\n    if (err === undefined)\n      err = new ERR_SYNTHETIC();\n    else if (err === null || typeof err !== 'object')\n      throw new ERR_INVALID_ARG_TYPE('err', 'Object', err);\n\n    return JSONParse(nr.getReport(err));\n  },\n  get directory() {\n    return nr.getDirectory();\n  },\n  set directory(dir) {\n    validateString(dir, 'directory');\n    nr.setDirectory(dir);\n  },\n  get filename() {\n    return nr.getFilename();\n  },\n  set filename(name) {\n    validateString(name, 'filename');\n    nr.setFilename(name);\n  },\n  get compact() {\n    return nr.getCompact();\n  },\n  set compact(b) {\n    validateBoolean(b, 'compact');\n    nr.setCompact(b);\n  },\n  get signal() {\n    return nr.getSignal();\n  },\n  set signal(sig) {\n    validateSignalName(sig, 'signal');\n    removeSignalHandler();\n    addSignalHandler(sig);\n    nr.setSignal(sig);\n  },\n  get reportOnFatalError() {\n    return nr.shouldReportOnFatalError();\n  },\n  set reportOnFatalError(trigger) {\n    if (typeof trigger !== 'boolean')\n      throw new ERR_INVALID_ARG_TYPE('trigger', 'boolean', trigger);\n\n    nr.setReportOnFatalError(trigger);\n  },\n  get reportOnSignal() {\n    return nr.shouldReportOnSignal();\n  },\n  set reportOnSignal(trigger) {\n    if (typeof trigger !== 'boolean')\n      throw new ERR_INVALID_ARG_TYPE('trigger', 'boolean', trigger);\n\n    nr.setReportOnSignal(trigger);\n    removeSignalHandler();\n    addSignalHandler();\n  },\n  get reportOnUncaughtException() {\n    return nr.shouldReportOnUncaughtException();\n  },\n  set reportOnUncaughtException(trigger) {\n    if (typeof trigger !== 'boolean')\n      throw new ERR_INVALID_ARG_TYPE('trigger', 'boolean', trigger);\n\n    nr.setReportOnUncaughtException(trigger);\n  }\n};\n\nfunction addSignalHandler(sig) {\n  if (nr.shouldReportOnSignal()) {\n    if (typeof sig !== 'string')\n      sig = nr.getSignal();\n\n    process.on(sig, signalHandler);\n  }\n}\n\nfunction removeSignalHandler() {\n  const sig = nr.getSignal();\n\n  if (sig)\n    process.removeListener(sig, signalHandler);\n}\n\nfunction signalHandler(sig) {\n  nr.writeReport(sig, 'Signal', null, '');\n}\n\nmodule.exports = {\n  addSignalHandler,\n  report\n};\n"
  },
  {
    "url": "internal/process/signal.js",
    "ranges": [
      {
        "start": 0,
        "end": 855
      },
      {
        "start": 1050,
        "end": 1124
      }
    ],
    "text": "'use strict';\n\nconst {\n  Map,\n} = primordials;\n\nconst {\n  errnoException,\n} = require('internal/errors');\n\nconst { signals } = internalBinding('constants').os;\n\nlet Signal;\nconst signalWraps = new Map();\n\nfunction isSignal(event) {\n  return typeof event === 'string' && signals[event] !== undefined;\n}\n\n// Detect presence of a listener for the special signal types\nfunction startListeningIfSignal(type) {\n  if (isSignal(type) && !signalWraps.has(type)) {\n    if (Signal === undefined)\n      Signal = internalBinding('signal_wrap').Signal;\n    const wrap = new Signal();\n\n    wrap.unref();\n\n    wrap.onsignal = process.emit.bind(process, type, type);\n\n    const signum = signals[type];\n    const err = wrap.start(signum);\n    if (err) {\n      wrap.close();\n      throw errnoException(err, 'uv_signal_start');\n    }\n\n    signalWraps.set(type, wrap);\n  }\n}\n\nfunction stopListeningIfSignal(type) {\n  const wrap = signalWraps.get(type);\n  if (wrap !== undefined && process.listenerCount(type) === 0) {\n    wrap.close();\n    signalWraps.delete(type);\n  }\n}\n\nmodule.exports = {\n  startListeningIfSignal,\n  stopListeningIfSignal\n};\n"
  },
  {
    "url": "internal/process/task_queues.js",
    "ranges": [
      {
        "start": 0,
        "end": 956
      },
      {
        "start": 1031,
        "end": 1033
      },
      {
        "start": 1119,
        "end": 1221
      },
      {
        "start": 1417,
        "end": 1419
      },
      {
        "start": 2387,
        "end": 2531
      },
      {
        "start": 3446,
        "end": 3536
      },
      {
        "start": 3782,
        "end": 3784
      },
      {
        "start": 3960,
        "end": 3962
      },
      {
        "start": 4275,
        "end": 4577
      }
    ],
    "text": "'use strict';\n\nconst {\n  Array,\n  FunctionPrototypeBind,\n} = primordials;\n\nconst {\n  // For easy access to the nextTick state in the C++ land,\n  // and to avoid unnecessary calls into JS land.\n  tickInfo,\n  // Used to run V8's micro task queue.\n  runMicrotasks,\n  setTickCallback,\n  enqueueMicrotask\n} = internalBinding('task_queue');\n\nconst {\n  setHasRejectionToWarn,\n  hasRejectionToWarn,\n  listenForRejections,\n  processPromiseRejections\n} = require('internal/process/promises');\n\nconst {\n  getDefaultTriggerAsyncId,\n  newAsyncId,\n  initHooksExist,\n  destroyHooksExist,\n  emitInit,\n  emitBefore,\n  emitAfter,\n  emitDestroy,\n  symbols: { async_id_symbol, trigger_async_id_symbol }\n} = require('internal/async_hooks');\nconst {\n  ERR_INVALID_CALLBACK,\n  ERR_INVALID_ARG_TYPE\n} = require('internal/errors').codes;\nconst FixedQueue = require('internal/fixed_queue');\n\n// *Must* match Environment::TickInfo::Fields in src/env.h.\nconst kHasTickScheduled = 0;\n\nfunction hasTickScheduled() {\n  return tickInfo[kHasTickScheduled] === 1;\n}\n\nfunction setHasTickScheduled(value) {\n  tickInfo[kHasTickScheduled] = value ? 1 : 0;\n}\n\nconst queue = new FixedQueue();\n\n// Should be in sync with RunNextTicksNative in node_task_queue.cc\nfunction runNextTicks() {\n  if (!hasTickScheduled() && !hasRejectionToWarn())\n    runMicrotasks();\n  if (!hasTickScheduled() && !hasRejectionToWarn())\n    return;\n\n  processTicksAndRejections();\n}\n\nfunction processTicksAndRejections() {\n  let tock;\n  do {\n    while (tock = queue.shift()) {\n      const asyncId = tock[async_id_symbol];\n      emitBefore(asyncId, tock[trigger_async_id_symbol], tock);\n\n      try {\n        const callback = tock.callback;\n        if (tock.args === undefined) {\n          callback();\n        } else {\n          const args = tock.args;\n          switch (args.length) {\n            case 1: callback(args[0]); break;\n            case 2: callback(args[0], args[1]); break;\n            case 3: callback(args[0], args[1], args[2]); break;\n            case 4: callback(args[0], args[1], args[2], args[3]); break;\n            default: callback(...args);\n          }\n        }\n      } finally {\n        if (destroyHooksExist())\n          emitDestroy(asyncId);\n      }\n\n      emitAfter(asyncId);\n    }\n    runMicrotasks();\n  } while (!queue.isEmpty() || processPromiseRejections());\n  setHasTickScheduled(false);\n  setHasRejectionToWarn(false);\n}\n\n// `nextTick()` will not enqueue any callback when the process is about to\n// exit since the callback would not have a chance to be executed.\nfunction nextTick(callback) {\n  if (typeof callback !== 'function')\n    throw new ERR_INVALID_CALLBACK(callback);\n\n  if (process._exiting)\n    return;\n\n  let args;\n  switch (arguments.length) {\n    case 1: break;\n    case 2: args = [arguments[1]]; break;\n    case 3: args = [arguments[1], arguments[2]]; break;\n    case 4: args = [arguments[1], arguments[2], arguments[3]]; break;\n    default:\n      args = new Array(arguments.length - 1);\n      for (let i = 1; i < arguments.length; i++)\n        args[i - 1] = arguments[i];\n  }\n\n  if (queue.isEmpty())\n    setHasTickScheduled(true);\n  const asyncId = newAsyncId();\n  const triggerAsyncId = getDefaultTriggerAsyncId();\n  const tickObject = {\n    [async_id_symbol]: asyncId,\n    [trigger_async_id_symbol]: triggerAsyncId,\n    callback,\n    args\n  };\n  if (initHooksExist())\n    emitInit(asyncId, 'TickObject', triggerAsyncId, tickObject);\n  queue.push(tickObject);\n}\n\nlet AsyncResource;\nconst defaultMicrotaskResourceOpts = { requireManualDestroy: true };\nfunction createMicrotaskResource() {\n  // Lazy load the async_hooks module\n  if (AsyncResource === undefined) {\n    AsyncResource = require('async_hooks').AsyncResource;\n  }\n  return new AsyncResource('Microtask', defaultMicrotaskResourceOpts);\n}\n\nfunction runMicrotask() {\n  this.runInAsyncScope(() => {\n    const callback = this.callback;\n    try {\n      callback();\n    } finally {\n      this.emitDestroy();\n    }\n  });\n}\n\nfunction queueMicrotask(callback) {\n  if (typeof callback !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('callback', 'function', callback);\n  }\n\n  const asyncResource = createMicrotaskResource();\n  asyncResource.callback = callback;\n\n  enqueueMicrotask(FunctionPrototypeBind(runMicrotask, asyncResource));\n}\n\nmodule.exports = {\n  setupTaskQueue() {\n    // Sets the per-isolate promise rejection callback\n    listenForRejections();\n    // Sets the callback to be run in every tick.\n    setTickCallback(processTicksAndRejections);\n    return {\n      nextTick,\n      runNextTicks\n    };\n  },\n  queueMicrotask\n};\n"
  },
  {
    "url": "internal/process/warning.js",
    "ranges": [
      {
        "start": 0,
        "end": 277
      },
      {
        "start": 831,
        "end": 932
      },
      {
        "start": 1054,
        "end": 1056
      },
      {
        "start": 1440,
        "end": 1442
      },
      {
        "start": 1513,
        "end": 1552
      },
      {
        "start": 2730,
        "end": 2853
      },
      {
        "start": 3997,
        "end": 3999
      },
      {
        "start": 4093,
        "end": 4095
      },
      {
        "start": 4762,
        "end": 4833
      }
    ],
    "text": "'use strict';\n\nconst {\n  ArrayIsArray,\n  Error,\n  ErrorCaptureStackTrace,\n  String,\n} = primordials;\n\nconst assert = require('internal/assert');\nconst { ERR_INVALID_ARG_TYPE } = require('internal/errors').codes;\n\n// Lazily loaded\nlet fs;\nlet fd;\nlet warningFile;\nlet options;\n\nfunction lazyOption() {\n  // This will load `warningFile` only once. If the flag is not set,\n  // `warningFile` will be set to an empty string.\n  if (warningFile === undefined) {\n    options = require('internal/options');\n    if (options.getOptionValue('--diagnostic-dir') !== '') {\n      warningFile = options.getOptionValue('--diagnostic-dir');\n    }\n    if (options.getOptionValue('--redirect-warnings') !== '') {\n      warningFile = options.getOptionValue('--redirect-warnings');\n    } else {\n      warningFile = '';\n    }\n  }\n  return warningFile;\n}\n\n// If we can't write to stderr, we'd like to make this a noop,\n// so use console.error.\nlet error;\nfunction writeOut(message) {\n  if (!error) {\n    error = require('internal/console/global').error;\n  }\n  error(message);\n}\n\nfunction writeToFile(message) {\n  if (fd === undefined) {\n    fs = require('fs');\n    try {\n      fd = fs.openSync(warningFile, 'a');\n    } catch {\n      return writeOut(message);\n    }\n    process.on('exit', () => {\n      try {\n        fs.closeSync(fd);\n      } catch {}\n    });\n  }\n  fs.appendFile(fd, `${message}\\n`, (err) => {\n    if (err) {\n      writeOut(message);\n    }\n  });\n}\n\nfunction doEmitWarning(warning) {\n  process.emit('warning', warning);\n}\n\nlet traceWarningHelperShown = false;\nfunction onWarning(warning) {\n  if (!(warning instanceof Error)) return;\n  const isDeprecation = warning.name === 'DeprecationWarning';\n  if (isDeprecation && process.noDeprecation) return;\n  const trace = process.traceProcessWarnings ||\n                (isDeprecation && process.traceDeprecation);\n  let msg = `(${process.release.name}:${process.pid}) `;\n  if (warning.code)\n    msg += `[${warning.code}] `;\n  if (trace && warning.stack) {\n    msg += `${warning.stack}`;\n  } else {\n    const toString =\n      typeof warning.toString === 'function' ?\n        warning.toString : Error.prototype.toString;\n    msg += `${toString.apply(warning)}`;\n  }\n  if (typeof warning.detail === 'string') {\n    msg += `\\n${warning.detail}`;\n  }\n  if (!trace && !traceWarningHelperShown) {\n    const flag = isDeprecation ? '--trace-deprecation' : '--trace-warnings';\n    const argv0 = require('path').basename(process.argv0 || 'node', '.exe');\n    msg += `\\n(Use \\`${argv0} ${flag} ...\\` to show where the warning ` +\n           'was created)';\n    traceWarningHelperShown = true;\n  }\n  const warningFile = lazyOption();\n  if (warningFile) {\n    return writeToFile(msg);\n  }\n  writeOut(msg);\n}\n\n// process.emitWarning(error)\n// process.emitWarning(str[, type[, code]][, ctor])\n// process.emitWarning(str[, options])\nfunction emitWarning(warning, type, code, ctor) {\n  let detail;\n  if (type !== null && typeof type === 'object' && !ArrayIsArray(type)) {\n    ctor = type.ctor;\n    code = type.code;\n    if (typeof type.detail === 'string')\n      detail = type.detail;\n    type = type.type || 'Warning';\n  } else if (typeof type === 'function') {\n    ctor = type;\n    code = undefined;\n    type = 'Warning';\n  }\n  if (type !== undefined && typeof type !== 'string') {\n    throw new ERR_INVALID_ARG_TYPE('type', 'string', type);\n  }\n  if (typeof code === 'function') {\n    ctor = code;\n    code = undefined;\n  } else if (code !== undefined && typeof code !== 'string') {\n    throw new ERR_INVALID_ARG_TYPE('code', 'string', code);\n  }\n  if (typeof warning === 'string') {\n    warning = createWarningObject(warning, type, code, ctor, detail);\n  } else if (!(warning instanceof Error)) {\n    throw new ERR_INVALID_ARG_TYPE('warning', ['Error', 'string'], warning);\n  }\n  if (warning.name === 'DeprecationWarning') {\n    if (process.noDeprecation)\n      return;\n    if (process.throwDeprecation)\n      throw warning;\n  }\n  process.nextTick(doEmitWarning, warning);\n}\n\nfunction emitWarningSync(warning) {\n  process.emit('warning', createWarningObject(warning));\n}\n\nfunction createWarningObject(warning, type, code, ctor, detail) {\n  assert(typeof warning === 'string');\n  // Improve error creation performance by skipping the error frames.\n  // They are added in the `captureStackTrace()` function below.\n  const tmpStackLimit = Error.stackTraceLimit;\n  Error.stackTraceLimit = 0;\n  // eslint-disable-next-line no-restricted-syntax\n  warning = new Error(warning);\n  Error.stackTraceLimit = tmpStackLimit;\n  warning.name = String(type || 'Warning');\n  if (code !== undefined) warning.code = code;\n  if (detail !== undefined) warning.detail = detail;\n  ErrorCaptureStackTrace(warning, ctor || process.emitWarning);\n  return warning;\n}\n\nmodule.exports = {\n  emitWarning,\n  emitWarningSync,\n  onWarning,\n};\n"
  },
  {
    "url": "internal/querystring.js",
    "ranges": [
      {
        "start": 0,
        "end": 1218
      },
      {
        "start": 2841,
        "end": 2903
      }
    ],
    "text": "'use strict';\n\nconst {\n  Array,\n  Int8Array,\n} = primordials;\n\nconst { ERR_INVALID_URI } = require('internal/errors').codes;\n\nconst hexTable = new Array(256);\nfor (let i = 0; i < 256; ++i)\n  hexTable[i] = '%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase();\n\nconst isHexTable = new Int8Array([\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n  0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 64 - 79\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 80 - 95\n  0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 96 - 111\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 112 - 127\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 128 ...\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  // ... 256\n]);\n\nfunction encodeStr(str, noEscapeTable, hexTable) {\n  const len = str.length;\n  if (len === 0)\n    return '';\n\n  let out = '';\n  let lastPos = 0;\n  let i = 0;\n\n  outer:\n  for (; i < len; i++) {\n    let c = str.charCodeAt(i);\n\n    // ASCII\n    while (c < 0x80) {\n      if (noEscapeTable[c] !== 1) {\n        if (lastPos < i)\n          out += str.slice(lastPos, i);\n        lastPos = i + 1;\n        out += hexTable[c];\n      }\n\n      if (++i === len)\n        break outer;\n\n      c = str.charCodeAt(i);\n    }\n\n    if (lastPos < i)\n      out += str.slice(lastPos, i);\n\n    // Multi-byte characters ...\n    if (c < 0x800) {\n      lastPos = i + 1;\n      out += hexTable[0xC0 | (c >> 6)] +\n             hexTable[0x80 | (c & 0x3F)];\n      continue;\n    }\n    if (c < 0xD800 || c >= 0xE000) {\n      lastPos = i + 1;\n      out += hexTable[0xE0 | (c >> 12)] +\n             hexTable[0x80 | ((c >> 6) & 0x3F)] +\n             hexTable[0x80 | (c & 0x3F)];\n      continue;\n    }\n    // Surrogate pair\n    ++i;\n\n    // This branch should never happen because all URLSearchParams entries\n    // should already be converted to USVString. But, included for\n    // completion's sake anyway.\n    if (i >= len)\n      throw new ERR_INVALID_URI();\n\n    const c2 = str.charCodeAt(i) & 0x3FF;\n\n    lastPos = i + 1;\n    c = 0x10000 + (((c & 0x3FF) << 10) | c2);\n    out += hexTable[0xF0 | (c >> 18)] +\n           hexTable[0x80 | ((c >> 12) & 0x3F)] +\n           hexTable[0x80 | ((c >> 6) & 0x3F)] +\n           hexTable[0x80 | (c & 0x3F)];\n  }\n  if (lastPos === 0)\n    return str;\n  if (lastPos < len)\n    return out + str.slice(lastPos);\n  return out;\n}\n\nmodule.exports = {\n  encodeStr,\n  hexTable,\n  isHexTable\n};\n"
  },
  {
    "url": "internal/source_map/source_map.js",
    "ranges": [
      {
        "start": 0,
        "end": 3884
      },
      {
        "start": 3960,
        "end": 3998
      },
      {
        "start": 4060,
        "end": 4098
      },
      {
        "start": 4158,
        "end": 4197
      },
      {
        "start": 4261,
        "end": 4506
      },
      {
        "start": 8432,
        "end": 8490
      },
      {
        "start": 8559,
        "end": 8649
      },
      {
        "start": 9582,
        "end": 9649
      },
      {
        "start": 9996,
        "end": 10191
      },
      {
        "start": 10454,
        "end": 10490
      }
    ],
    "text": "// This file is a modified version of:\n// https://cs.chromium.org/chromium/src/v8/tools/SourceMap.js?rcl=dd10454c1d\n// from the V8 codebase. Logic specific to WebInspector is removed and linting\n// is made to match the Node.js style guide.\n\n// Copyright 2013 the V8 project authors. All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n//       copyright notice, this list of conditions and the following\n//       disclaimer in the documentation and/or other materials provided\n//       with the distribution.\n//     * Neither the name of Google Inc. nor the names of its\n//       contributors may be used to endorse or promote products derived\n//       from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// This is a copy from blink dev tools, see:\n// http://src.chromium.org/viewvc/blink/trunk/Source/devtools/front_end/SourceMap.js\n// revision: 153407\n\n/*\n * Copyright (C) 2012 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n'use strict';\n\nconst {\n  ArrayIsArray\n} = primordials;\n\nconst {\n  ERR_INVALID_ARG_TYPE\n} = require('internal/errors').codes;\n\nlet base64Map;\n\nconst VLQ_BASE_SHIFT = 5;\nconst VLQ_BASE_MASK = (1 << 5) - 1;\nconst VLQ_CONTINUATION_MASK = 1 << 5;\n\nclass StringCharIterator {\n  /**\n   * @constructor\n   * @param {string} string\n   */\n  constructor(string) {\n    this._string = string;\n    this._position = 0;\n  }\n\n  /**\n   * @return {string}\n   */\n  next() {\n    return this._string.charAt(this._position++);\n  }\n\n  /**\n   * @return {string}\n   */\n  peek() {\n    return this._string.charAt(this._position);\n  }\n\n  /**\n   * @return {boolean}\n   */\n  hasNext() {\n    return this._position < this._string.length;\n  }\n}\n\n/**\n * Implements Source Map V3 model.\n * See https://github.com/google/closure-compiler/wiki/Source-Maps\n * for format description.\n * @constructor\n * @param {string} sourceMappingURL\n * @param {SourceMapV3} payload\n */\nclass SourceMap {\n  #payload;\n  #mappings = [];\n  #sources = {};\n  #sourceContentByURL = {};\n\n  /**\n   * @constructor\n   * @param {SourceMapV3} payload\n   */\n  constructor(payload) {\n    if (!base64Map) {\n      const base64Digits =\n             'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n      base64Map = {};\n      for (let i = 0; i < base64Digits.length; ++i)\n        base64Map[base64Digits[i]] = i;\n    }\n    this.#payload = cloneSourceMapV3(payload);\n    this.#parseMappingPayload();\n  }\n\n  /**\n   * @return {Object} raw source map v3 payload.\n   */\n  get payload() {\n    return cloneSourceMapV3(this.#payload);\n  }\n\n  /**\n   * @param {SourceMapV3} mappingPayload\n   */\n  #parseMappingPayload = () => {\n    if (this.#payload.sections) {\n      this.#parseSections(this.#payload.sections);\n    } else {\n      this.#parseMap(this.#payload, 0, 0);\n    }\n    this.#mappings.sort(compareSourceMapEntry);\n  }\n\n  /**\n   * @param {Array.<SourceMapV3.Section>} sections\n   */\n  #parseSections = (sections) => {\n    for (let i = 0; i < sections.length; ++i) {\n      const section = sections[i];\n      this.#parseMap(section.map, section.offset.line, section.offset.column);\n    }\n  }\n\n  /**\n   * @param {number} lineNumber in compiled resource\n   * @param {number} columnNumber in compiled resource\n   * @return {?Array}\n   */\n  findEntry(lineNumber, columnNumber) {\n    let first = 0;\n    let count = this.#mappings.length;\n    while (count > 1) {\n      const step = count >> 1;\n      const middle = first + step;\n      const mapping = this.#mappings[middle];\n      if (lineNumber < mapping[0] ||\n          (lineNumber === mapping[0] && columnNumber < mapping[1])) {\n        count = step;\n      } else {\n        first = middle;\n        count -= step;\n      }\n    }\n    const entry = this.#mappings[first];\n    if (!first && entry && (lineNumber < entry[0] ||\n        (lineNumber === entry[0] && columnNumber < entry[1]))) {\n      return {};\n    } else if (!entry) {\n      return {};\n    }\n    return {\n      generatedLine: entry[0],\n      generatedColumn: entry[1],\n      originalSource: entry[2],\n      originalLine: entry[3],\n      originalColumn: entry[4]\n    };\n  }\n\n  /**\n   * @override\n   */\n  #parseMap = (map, lineNumber, columnNumber) => {\n    let sourceIndex = 0;\n    let sourceLineNumber = 0;\n    let sourceColumnNumber = 0;\n\n    const sources = [];\n    const originalToCanonicalURLMap = {};\n    for (let i = 0; i < map.sources.length; ++i) {\n      const url = map.sources[i];\n      originalToCanonicalURLMap[url] = url;\n      sources.push(url);\n      this.#sources[url] = true;\n\n      if (map.sourcesContent && map.sourcesContent[i])\n        this.#sourceContentByURL[url] = map.sourcesContent[i];\n    }\n\n    const stringCharIterator = new StringCharIterator(map.mappings);\n    let sourceURL = sources[sourceIndex];\n\n    while (true) {\n      if (stringCharIterator.peek() === ',')\n        stringCharIterator.next();\n      else {\n        while (stringCharIterator.peek() === ';') {\n          lineNumber += 1;\n          columnNumber = 0;\n          stringCharIterator.next();\n        }\n        if (!stringCharIterator.hasNext())\n          break;\n      }\n\n      columnNumber += decodeVLQ(stringCharIterator);\n      if (isSeparator(stringCharIterator.peek())) {\n        this.#mappings.push([lineNumber, columnNumber]);\n        continue;\n      }\n\n      const sourceIndexDelta = decodeVLQ(stringCharIterator);\n      if (sourceIndexDelta) {\n        sourceIndex += sourceIndexDelta;\n        sourceURL = sources[sourceIndex];\n      }\n      sourceLineNumber += decodeVLQ(stringCharIterator);\n      sourceColumnNumber += decodeVLQ(stringCharIterator);\n      if (!isSeparator(stringCharIterator.peek()))\n        // Unused index into the names list.\n        decodeVLQ(stringCharIterator);\n\n      this.#mappings.push([lineNumber, columnNumber, sourceURL,\n                           sourceLineNumber, sourceColumnNumber]);\n    }\n  };\n}\n\n/**\n * @param {string} char\n * @return {boolean}\n */\nfunction isSeparator(char) {\n  return char === ',' || char === ';';\n}\n\n/**\n * @param {SourceMap.StringCharIterator} stringCharIterator\n * @return {number}\n */\nfunction decodeVLQ(stringCharIterator) {\n  // Read unsigned value.\n  let result = 0;\n  let shift = 0;\n  let digit;\n  do {\n    digit = base64Map[stringCharIterator.next()];\n    result += (digit & VLQ_BASE_MASK) << shift;\n    shift += VLQ_BASE_SHIFT;\n  } while (digit & VLQ_CONTINUATION_MASK);\n\n  // Fix the sign.\n  const negative = result & 1;\n  // Use unsigned right shift, so that the 32nd bit is properly shifted to the\n  // 31st, and the 32nd becomes unset.\n  result >>>= 1;\n  if (!negative) {\n    return result;\n  }\n\n  // We need to OR here to ensure the 32nd bit (the sign bit in an Int32) is\n  // always set for negative numbers. If `result` were 1, (meaning `negate` is\n  // true and all other bits were zeros), `result` would now be 0. But -0\n  // doesn't flip the 32nd bit as intended. All other numbers will successfully\n  // set the 32nd bit without issue, so doing this is a noop for them.\n  return -result | (1 << 31);\n}\n\n/**\n * @param {SourceMapV3} payload\n * @return {SourceMapV3}\n */\nfunction cloneSourceMapV3(payload) {\n  if (typeof payload !== 'object') {\n    throw new ERR_INVALID_ARG_TYPE('payload', ['Object'], payload);\n  }\n  payload = { ...payload };\n  for (const key in payload) {\n    if (payload.hasOwnProperty(key) && ArrayIsArray(payload[key])) {\n      payload[key] = payload[key].slice(0);\n    }\n  }\n  return payload;\n}\n\n/**\n * @param {Array} entry1 source map entry [lineNumber, columnNumber, sourceURL,\n *  sourceLineNumber, sourceColumnNumber]\n * @param {Array} entry2 source map entry.\n * @return {number}\n */\nfunction compareSourceMapEntry(entry1, entry2) {\n  const [lineNumber1, columnNumber1] = entry1;\n  const [lineNumber2, columnNumber2] = entry2;\n  if (lineNumber1 !== lineNumber2) {\n    return lineNumber1 - lineNumber2;\n  }\n  return columnNumber1 - columnNumber2;\n}\n\nmodule.exports = {\n  SourceMap\n};\n"
  },
  {
    "url": "internal/source_map/source_map_cache.js",
    "ranges": [
      {
        "start": 0,
        "end": 305
      },
      {
        "start": 483,
        "end": 665
      },
      {
        "start": 690,
        "end": 1287
      },
      {
        "start": 2534,
        "end": 2536
      },
      {
        "start": 3068,
        "end": 3258
      },
      {
        "start": 3566,
        "end": 3568
      },
      {
        "start": 3839,
        "end": 3933
      },
      {
        "start": 4568,
        "end": 4753
      },
      {
        "start": 5203,
        "end": 5272
      },
      {
        "start": 5467,
        "end": 5905
      },
      {
        "start": 6274,
        "end": 6513
      },
      {
        "start": 7168,
        "end": 7386
      },
      {
        "start": 8111,
        "end": 8219
      }
    ],
    "text": "'use strict';\n\nconst {\n  JSONParse,\n  ObjectCreate,\n  ObjectKeys,\n  ObjectGetOwnPropertyDescriptor,\n  ObjectPrototypeHasOwnProperty,\n  Map,\n  MapPrototypeEntries,\n  WeakMap,\n  WeakMapPrototypeGet,\n  uncurryThis,\n} = primordials;\n\nconst MapIteratorNext = uncurryThis(MapPrototypeEntries(new Map()).next);\n\nfunction ObjectGetValueSafe(obj, key) {\n  const desc = ObjectGetOwnPropertyDescriptor(obj, key);\n  return ObjectPrototypeHasOwnProperty(desc, 'value') ? desc.value : undefined;\n}\n\n// See https://sourcemaps.info/spec.html for SourceMap V3 specification.\nconst { Buffer } = require('buffer');\nlet debug = require('internal/util/debuglog').debuglog('source_map', (fn) => {\n  debug = fn;\n});\nconst { dirname, resolve } = require('path');\nconst fs = require('fs');\nconst { getOptionValue } = require('internal/options');\nconst {\n  normalizeReferrerURL,\n} = require('internal/modules/cjs/helpers');\n// For cjs, since Module._cache is exposed to users, we use a WeakMap\n// keyed on module, facilitating garbage collection.\nconst cjsSourceMapCache = new WeakMap();\n// The esm cache is not exposed to users, so we can use a Map keyed\n// on filenames.\nconst esmSourceMapCache = new Map();\nconst { fileURLToPath, URL } = require('url');\nlet Module;\nlet SourceMap;\n\nlet experimentalSourceMaps;\nfunction maybeCacheSourceMap(filename, content, cjsModuleInstance) {\n  if (experimentalSourceMaps === undefined) {\n    experimentalSourceMaps = getOptionValue('--enable-source-maps');\n  }\n  if (!(process.env.NODE_V8_COVERAGE || experimentalSourceMaps)) return;\n  let basePath;\n  try {\n    filename = normalizeReferrerURL(filename);\n    basePath = dirname(fileURLToPath(filename));\n  } catch (err) {\n    // This is most likely an [eval]-wrapper, which is currently not\n    // supported.\n    debug(err.stack);\n    return;\n  }\n\n  const match = content.match(/\\/[*/]#\\s+sourceMappingURL=(?<sourceMappingURL>[^\\s]+)/);\n  if (match) {\n    const data = dataFromUrl(basePath, match.groups.sourceMappingURL);\n    const url = data ? null : match.groups.sourceMappingURL;\n    if (cjsModuleInstance) {\n      if (!Module) Module = require('internal/modules/cjs/loader').Module;\n      cjsSourceMapCache.set(cjsModuleInstance, {\n        filename,\n        lineLengths: lineLengths(content),\n        data,\n        url\n      });\n    } else {\n      // If there is no cjsModuleInstance assume we are in a\n      // \"modules/esm\" context.\n      esmSourceMapCache.set(filename, {\n        lineLengths: lineLengths(content),\n        data,\n        url\n      });\n    }\n  }\n}\n\nfunction dataFromUrl(basePath, sourceMappingURL) {\n  try {\n    const url = new URL(sourceMappingURL);\n    switch (url.protocol) {\n      case 'data:':\n        return sourceMapFromDataUrl(basePath, url.pathname);\n      default:\n        debug(`unknown protocol ${url.protocol}`);\n        return null;\n    }\n  } catch (err) {\n    debug(err.stack);\n    // If no scheme is present, we assume we are dealing with a file path.\n    const sourceMapFile = resolve(basePath, sourceMappingURL);\n    return sourceMapFromFile(sourceMapFile);\n  }\n}\n\n// Cache the length of each line in the file that a source map was extracted\n// from. This allows translation from byte offset V8 coverage reports,\n// to line/column offset Source Map V3.\nfunction lineLengths(content) {\n  // We purposefully keep \\r as part of the line-length calculation, in\n  // cases where there is a \\r\\n separator, so that this can be taken into\n  // account in coverage calculations.\n  return content.split(/\\n|\\u2028|\\u2029/).map((line) => {\n    return line.length;\n  });\n}\n\nfunction sourceMapFromFile(sourceMapFile) {\n  try {\n    const content = fs.readFileSync(sourceMapFile, 'utf8');\n    const data = JSONParse(content);\n    return sourcesToAbsolute(dirname(sourceMapFile), data);\n  } catch (err) {\n    debug(err.stack);\n    return null;\n  }\n}\n\n// data:[<mediatype>][;base64],<data> see:\n// https://tools.ietf.org/html/rfc2397#section-2\nfunction sourceMapFromDataUrl(basePath, url) {\n  const [format, data] = url.split(',');\n  const splitFormat = format.split(';');\n  const contentType = splitFormat[0];\n  const base64 = splitFormat[splitFormat.length - 1] === 'base64';\n  if (contentType === 'application/json') {\n    const decodedData = base64 ?\n      Buffer.from(data, 'base64').toString('utf8') : data;\n    try {\n      const parsedData = JSONParse(decodedData);\n      return sourcesToAbsolute(basePath, parsedData);\n    } catch (err) {\n      debug(err.stack);\n      return null;\n    }\n  } else {\n    debug(`unknown content-type ${contentType}`);\n    return null;\n  }\n}\n\n// If the sources are not absolute URLs after prepending of the \"sourceRoot\",\n// the sources are resolved relative to the SourceMap (like resolving script\n// src in a html document).\nfunction sourcesToAbsolute(base, data) {\n  data.sources = data.sources.map((source) => {\n    source = (data.sourceRoot || '') + source;\n    if (!/^[\\\\/]/.test(source[0])) {\n      source = resolve(base, source);\n    }\n    if (!source.startsWith('file://')) source = `file://${source}`;\n    return source;\n  });\n  // The sources array is now resolved to absolute URLs, sourceRoot should\n  // be updated to noop.\n  data.sourceRoot = '';\n  return data;\n}\n\n// Move source map from garbage collected module to alternate key.\nfunction rekeySourceMap(cjsModuleInstance, newInstance) {\n  const sourceMap = cjsSourceMapCache.get(cjsModuleInstance);\n  if (sourceMap) {\n    cjsSourceMapCache.set(newInstance, sourceMap);\n  }\n}\n\n// WARNING: The `sourceMapCacheToObject` and `appendCJSCache` run during\n// shutdown. In particular, they also run when Workers are terminated, making\n// it important that they do not call out to any user-provided code, including\n// built-in prototypes that might have been tampered with.\n\n// Get serialized representation of source-map cache, this is used\n// to persist a cache of source-maps to disk when NODE_V8_COVERAGE is enabled.\nfunction sourceMapCacheToObject() {\n  const obj = ObjectCreate(null);\n\n  const it = MapPrototypeEntries(esmSourceMapCache);\n  let entry;\n  while (!(entry = MapIteratorNext(it)).done) {\n    const k = entry.value[0];\n    const v = entry.value[1];\n    obj[k] = v;\n  }\n\n  appendCJSCache(obj);\n\n  if (ObjectKeys(obj).length === 0) {\n    return undefined;\n  }\n  return obj;\n}\n\n// Since WeakMap can't be iterated over, we use Module._cache's\n// keys to facilitate Source Map serialization.\n//\n// TODO(bcoe): this means we don't currently serialize source-maps attached\n// to error instances, only module instances.\nfunction appendCJSCache(obj) {\n  if (!Module) return;\n  const cjsModuleCache = ObjectGetValueSafe(Module, '_cache');\n  const cjsModules = ObjectKeys(cjsModuleCache);\n  for (let i = 0; i < cjsModules.length; i++) {\n    const key = cjsModules[i];\n    const module = ObjectGetValueSafe(cjsModuleCache, key);\n    const value = WeakMapPrototypeGet(cjsSourceMapCache, module);\n    if (value) {\n      // This is okay because `obj` has a null prototype.\n      obj[`file://${key}`] = {\n        lineLengths: ObjectGetValueSafe(value, 'lineLengths'),\n        data: ObjectGetValueSafe(value, 'data'),\n        url: ObjectGetValueSafe(value, 'url')\n      };\n    }\n  }\n}\n\n// Attempt to lookup a source map, which is either attached to a file URI, or\n// keyed on an error instance.\n// TODO(bcoe): once WeakRefs are available in Node.js, refactor to drop\n// requirement of error parameter.\nfunction findSourceMap(uri, error) {\n  if (!Module) Module = require('internal/modules/cjs/loader').Module;\n  if (!SourceMap) {\n    SourceMap = require('internal/source_map/source_map').SourceMap;\n  }\n  let sourceMap = cjsSourceMapCache.get(Module._cache[uri]);\n  if (!uri.startsWith('file://')) uri = normalizeReferrerURL(uri);\n  if (sourceMap === undefined) {\n    sourceMap = esmSourceMapCache.get(uri);\n  }\n  if (sourceMap === undefined) {\n    const candidateSourceMap = cjsSourceMapCache.get(error);\n    if (candidateSourceMap && uri === candidateSourceMap.filename) {\n      sourceMap = candidateSourceMap;\n    }\n  }\n  if (sourceMap && sourceMap.data) {\n    return new SourceMap(sourceMap.data);\n  }\n  return undefined;\n}\n\nmodule.exports = {\n  findSourceMap,\n  maybeCacheSourceMap,\n  rekeySourceMap,\n  sourceMapCacheToObject,\n};\n"
  },
  {
    "url": "internal/timers.js",
    "ranges": [
      {
        "start": 0,
        "end": 4376
      },
      {
        "start": 4401,
        "end": 5344
      },
      {
        "start": 5622,
        "end": 5707
      },
      {
        "start": 6704,
        "end": 6817
      },
      {
        "start": 6988,
        "end": 7019
      },
      {
        "start": 7117,
        "end": 7146
      },
      {
        "start": 7274,
        "end": 7301
      },
      {
        "start": 7429,
        "end": 7459
      },
      {
        "start": 7496,
        "end": 7499
      },
      {
        "start": 7799,
        "end": 7915
      },
      {
        "start": 8086,
        "end": 8391
      },
      {
        "start": 8558,
        "end": 8736
      },
      {
        "start": 9091,
        "end": 9094
      },
      {
        "start": 9170,
        "end": 9172
      },
      {
        "start": 9249,
        "end": 9332
      },
      {
        "start": 9386,
        "end": 9533
      },
      {
        "start": 9593,
        "end": 9814
      },
      {
        "start": 10330,
        "end": 10332
      },
      {
        "start": 10983,
        "end": 10985
      },
      {
        "start": 11291,
        "end": 11358
      },
      {
        "start": 11880,
        "end": 11882
      },
      {
        "start": 12087,
        "end": 12089
      },
      {
        "start": 12160,
        "end": 12474
      },
      {
        "start": 14275,
        "end": 14280
      },
      {
        "start": 14754,
        "end": 14758
      },
      {
        "start": 17200,
        "end": 17730
      }
    ],
    "text": "'use strict';\n\n// HOW and WHY the timers implementation works the way it does.\n//\n// Timers are crucial to Node.js. Internally, any TCP I/O connection creates a\n// timer so that we can time out of connections. Additionally, many user\n// libraries and applications also use timers. As such there may be a\n// significantly large amount of timeouts scheduled at any given time.\n// Therefore, it is very important that the timers implementation is performant\n// and efficient.\n//\n// Note: It is suggested you first read through the lib/internal/linkedlist.js\n// linked list implementation, since timers depend on it extensively. It can be\n// somewhat counter-intuitive at first, as it is not actually a class. Instead,\n// it is a set of helpers that operate on an existing object.\n//\n// In order to be as performant as possible, the architecture and data\n// structures are designed so that they are optimized to handle the following\n// use cases as efficiently as possible:\n\n// - Adding a new timer. (insert)\n// - Removing an existing timer. (remove)\n// - Handling a timer timing out. (timeout)\n//\n// Whenever possible, the implementation tries to make the complexity of these\n// operations as close to constant-time as possible.\n// (So that performance is not impacted by the number of scheduled timers.)\n//\n// Object maps are kept which contain linked lists keyed by their duration in\n// milliseconds.\n//\n/* eslint-disable node-core/non-ascii-character */\n//\n//  > Object Map\n// \n// \n//  lists: { '40': { }, '320': { etc } } (keys of millisecond duration)\n//           \n//              \n//           \n//  TimersList { _idleNext: { }, _idlePrev: (self) }\n//          \n//                                     ^\n//         { _idleNext: { },  _idlePrev: { }, _onTimeout: (callback) }\n//           \n//                                             ^\n//           { _idleNext: { etc },  _idlePrev: { }, _onTimeout: (callback) }\n//   \n//     \n//      >  Actual JavaScript timeouts\n// \n//  > Linked List\n//\n/* eslint-enable node-core/non-ascii-character */\n//\n// With this, virtually constant-time insertion (append), removal, and timeout\n// is possible in the JavaScript layer. Any one list of timers is able to be\n// sorted by just appending to it because all timers within share the same\n// duration. Therefore, any timer added later will always have been scheduled to\n// timeout later, thus only needing to be appended.\n// Removal from an object-property linked list is also virtually constant-time\n// as can be seen in the lib/internal/linkedlist.js implementation.\n// Timeouts only need to process any timers currently due to expire, which will\n// always be at the beginning of the list for reasons stated above. Any timers\n// after the first one encountered that does not yet need to timeout will also\n// always be due to timeout at a later time.\n//\n// Less-than constant time operations are thus contained in two places:\n// The PriorityQueue  an efficient binary heap implementation that does all\n// operations in worst-case O(log n) time  which manages the order of expiring\n// Timeout lists and the object map lookup of a specific list by the duration of\n// timers within (or creation of a new list). However, these operations combined\n// have shown to be trivial in comparison to other timers architectures.\n\nconst {\n  MathMax,\n  MathTrunc,\n  NumberMIN_SAFE_INTEGER,\n  ObjectCreate,\n  Symbol,\n} = primordials;\n\nconst {\n  scheduleTimer,\n  toggleTimerRef,\n  getLibuvNow,\n  immediateInfo\n} = internalBinding('timers');\n\nconst {\n  getDefaultTriggerAsyncId,\n  newAsyncId,\n  initHooksExist,\n  destroyHooksExist,\n  // The needed emit*() functions.\n  emitInit,\n  emitBefore,\n  emitAfter,\n  emitDestroy,\n} = require('internal/async_hooks');\n\n// Symbols for storing async id state.\nconst async_id_symbol = Symbol('asyncId');\nconst trigger_async_id_symbol = Symbol('triggerId');\n\nconst kHasPrimitive = Symbol('kHasPrimitive');\n\nconst {\n  ERR_INVALID_CALLBACK,\n  ERR_OUT_OF_RANGE\n} = require('internal/errors').codes;\nconst { validateNumber } = require('internal/validators');\n\nconst L = require('internal/linkedlist');\nconst PriorityQueue = require('internal/priority_queue');\n\nconst { inspect } = require('internal/util/inspect');\nlet debug = require('internal/util/debuglog').debuglog('timer', (fn) => {\n  debug = fn;\n});\n\n// *Must* match Environment::ImmediateInfo::Fields in src/env.h.\nconst kCount = 0;\nconst kRefCount = 1;\nconst kHasOutstanding = 2;\n\n// Timeout values > TIMEOUT_MAX are set to 1.\nconst TIMEOUT_MAX = 2 ** 31 - 1;\n\nlet timerListId = NumberMIN_SAFE_INTEGER;\n\nconst kRefed = Symbol('refed');\n\n// Create a single linked list instance only once at startup\nconst immediateQueue = new ImmediateList();\n\nlet nextExpiry = Infinity;\nlet refCount = 0;\n\n// This is a priority queue with a custom sorting function that first compares\n// the expiry times of two lists and if they're the same then compares their\n// individual IDs to determine which list was created first.\nconst timerListQueue = new PriorityQueue(compareTimersLists, setPosition);\n\n// Object map containing linked lists of timers, keyed and sorted by their\n// duration in milliseconds.\n//\n// - key = time in milliseconds\n// - value = linked list\nconst timerListMap = ObjectCreate(null);\n\nfunction initAsyncResource(resource, type) {\n  const asyncId = resource[async_id_symbol] = newAsyncId();\n  const triggerAsyncId =\n    resource[trigger_async_id_symbol] = getDefaultTriggerAsyncId();\n  if (initHooksExist())\n    emitInit(asyncId, type, triggerAsyncId, resource);\n}\n\n// Timer constructor function.\n// The entire prototype is defined in lib/timers.js\nfunction Timeout(callback, after, args, isRepeat, isRefed) {\n  after *= 1; // Coalesce to number or NaN\n  if (!(after >= 1 && after <= TIMEOUT_MAX)) {\n    if (after > TIMEOUT_MAX) {\n      process.emitWarning(`${after} does not fit into` +\n                          ' a 32-bit signed integer.' +\n                          '\\nTimeout duration was set to 1.',\n                          'TimeoutOverflowWarning');\n    }\n    after = 1; // Schedule on next tick, follows browser behavior\n  }\n\n  this._idleTimeout = after;\n  this._idlePrev = this;\n  this._idleNext = this;\n  this._idleStart = null;\n  // This must be set to null first to avoid function tracking\n  // on the hidden class, revisit in V8 versions after 6.2\n  this._onTimeout = null;\n  this._onTimeout = callback;\n  this._timerArgs = args;\n  this._repeat = isRepeat ? after : null;\n  this._destroyed = false;\n\n  if (isRefed)\n    incRefCount();\n  this[kRefed] = isRefed;\n  this[kHasPrimitive] = false;\n\n  initAsyncResource(this, 'Timeout');\n}\n\n// Make sure the linked list only shows the minimal necessary information.\nTimeout.prototype[inspect.custom] = function(_, options) {\n  return inspect(this, {\n    ...options,\n    // Only inspect one level.\n    depth: 0,\n    // It should not recurse.\n    customInspect: false\n  });\n};\n\nTimeout.prototype.refresh = function() {\n  if (this[kRefed])\n    active(this);\n  else\n    unrefActive(this);\n\n  return this;\n};\n\nTimeout.prototype.unref = function() {\n  if (this[kRefed]) {\n    this[kRefed] = false;\n    if (!this._destroyed)\n      decRefCount();\n  }\n  return this;\n};\n\nTimeout.prototype.ref = function() {\n  if (!this[kRefed]) {\n    this[kRefed] = true;\n    if (!this._destroyed)\n      incRefCount();\n  }\n  return this;\n};\n\nTimeout.prototype.hasRef = function() {\n  return this[kRefed];\n};\n\nfunction TimersList(expiry, msecs) {\n  this._idleNext = this; // Create the list with the linkedlist properties to\n  this._idlePrev = this; // Prevent any unnecessary hidden class changes.\n  this.expiry = expiry;\n  this.id = timerListId++;\n  this.msecs = msecs;\n  this.priorityQueuePosition = null;\n}\n\n// Make sure the linked list only shows the minimal necessary information.\nTimersList.prototype[inspect.custom] = function(_, options) {\n  return inspect(this, {\n    ...options,\n    // Only inspect one level.\n    depth: 0,\n    // It should not recurse.\n    customInspect: false\n  });\n};\n\n// A linked list for storing `setImmediate()` requests\nfunction ImmediateList() {\n  this.head = null;\n  this.tail = null;\n}\n\n// Appends an item to the end of the linked list, adjusting the current tail's\n// next pointer and the item's previous pointer where applicable\nImmediateList.prototype.append = function(item) {\n  if (this.tail !== null) {\n    this.tail._idleNext = item;\n    item._idlePrev = this.tail;\n  } else {\n    this.head = item;\n  }\n  this.tail = item;\n};\n\n// Removes an item from the linked list, adjusting the pointers of adjacent\n// items and the linked list's head or tail pointers as necessary\nImmediateList.prototype.remove = function(item) {\n  if (item._idleNext !== null) {\n    item._idleNext._idlePrev = item._idlePrev;\n  }\n\n  if (item._idlePrev !== null) {\n    item._idlePrev._idleNext = item._idleNext;\n  }\n\n  if (item === this.head)\n    this.head = item._idleNext;\n  if (item === this.tail)\n    this.tail = item._idlePrev;\n\n  item._idleNext = null;\n  item._idlePrev = null;\n};\n\nfunction incRefCount() {\n  if (refCount++ === 0)\n    toggleTimerRef(true);\n}\n\nfunction decRefCount() {\n  if (--refCount === 0)\n    toggleTimerRef(false);\n}\n\n// Schedule or re-schedule a timer.\n// The item must have been enroll()'d first.\nfunction active(item) {\n  insertGuarded(item, true);\n}\n\n// Internal APIs that need timeouts should use `unrefActive()` instead of\n// `active()` so that they do not unnecessarily keep the process open.\nfunction unrefActive(item) {\n  insertGuarded(item, false);\n}\n\n// The underlying logic for scheduling or re-scheduling a timer.\n//\n// Appends a timer onto the end of an existing timers list, or creates a new\n// list if one does not already exist for the specified timeout duration.\nfunction insertGuarded(item, refed, start) {\n  const msecs = item._idleTimeout;\n  if (msecs < 0 || msecs === undefined)\n    return;\n\n  insert(item, msecs, start);\n\n  const isDestroyed = item._destroyed;\n  if (isDestroyed || !item[async_id_symbol]) {\n    item._destroyed = false;\n    initAsyncResource(item, 'Timeout');\n  }\n\n  if (isDestroyed) {\n    if (refed)\n      incRefCount();\n  } else if (refed === !item[kRefed]) {\n    if (refed)\n      incRefCount();\n    else\n      decRefCount();\n  }\n  item[kRefed] = refed;\n}\n\nfunction insert(item, msecs, start = getLibuvNow()) {\n  // Truncate so that accuracy of sub-millisecond timers is not assumed.\n  msecs = MathTrunc(msecs);\n  item._idleStart = start;\n\n  // Use an existing list if there is one, otherwise we need to make a new one.\n  let list = timerListMap[msecs];\n  if (list === undefined) {\n    debug('no %d list was found in insert, creating a new one', msecs);\n    const expiry = start + msecs;\n    timerListMap[msecs] = list = new TimersList(expiry, msecs);\n    timerListQueue.insert(list);\n\n    if (nextExpiry > expiry) {\n      scheduleTimer(msecs);\n      nextExpiry = expiry;\n    }\n  }\n\n  L.append(list, item);\n}\n\nfunction setUnrefTimeout(callback, after) {\n  // Type checking identical to setTimeout()\n  if (typeof callback !== 'function') {\n    throw new ERR_INVALID_CALLBACK(callback);\n  }\n\n  const timer = new Timeout(callback, after, undefined, false, false);\n  insert(timer, timer._idleTimeout);\n\n  return timer;\n}\n\n// Type checking used by timers.enroll() and Socket#setTimeout()\nfunction getTimerDuration(msecs, name) {\n  validateNumber(msecs, name);\n  if (msecs < 0 || !isFinite(msecs)) {\n    throw new ERR_OUT_OF_RANGE(name, 'a non-negative finite number', msecs);\n  }\n\n  // Ensure that msecs fits into signed int32\n  if (msecs > TIMEOUT_MAX) {\n    process.emitWarning(`${msecs} does not fit into a 32-bit signed integer.` +\n                        `\\nTimer duration was truncated to ${TIMEOUT_MAX}.`,\n                        'TimeoutOverflowWarning');\n    return TIMEOUT_MAX;\n  }\n\n  return msecs;\n}\n\nfunction compareTimersLists(a, b) {\n  const expiryDiff = a.expiry - b.expiry;\n  if (expiryDiff === 0) {\n    if (a.id < b.id)\n      return -1;\n    if (a.id > b.id)\n      return 1;\n  }\n  return expiryDiff;\n}\n\nfunction setPosition(node, pos) {\n  node.priorityQueuePosition = pos;\n}\n\nfunction getTimerCallbacks(runNextTicks) {\n  // If an uncaught exception was thrown during execution of immediateQueue,\n  // this queue will store all remaining Immediates that need to run upon\n  // resolution of all error handling (if process is still alive).\n  const outstandingQueue = new ImmediateList();\n\n  function processImmediate() {\n    const queue = outstandingQueue.head !== null ?\n      outstandingQueue : immediateQueue;\n    let immediate = queue.head;\n\n    // Clear the linked list early in case new `setImmediate()`\n    // calls occur while immediate callbacks are executed\n    if (queue !== outstandingQueue) {\n      queue.head = queue.tail = null;\n      immediateInfo[kHasOutstanding] = 1;\n    }\n\n    let prevImmediate;\n    let ranAtLeastOneImmediate = false;\n    while (immediate !== null) {\n      if (ranAtLeastOneImmediate)\n        runNextTicks();\n      else\n        ranAtLeastOneImmediate = true;\n\n      // It's possible for this current Immediate to be cleared while executing\n      // the next tick queue above, which means we need to use the previous\n      // Immediate's _idleNext which is guaranteed to not have been cleared.\n      if (immediate._destroyed) {\n        outstandingQueue.head = immediate = prevImmediate._idleNext;\n        continue;\n      }\n\n      immediate._destroyed = true;\n\n      immediateInfo[kCount]--;\n      if (immediate[kRefed])\n        immediateInfo[kRefCount]--;\n      immediate[kRefed] = null;\n\n      prevImmediate = immediate;\n\n      const asyncId = immediate[async_id_symbol];\n      emitBefore(asyncId, immediate[trigger_async_id_symbol], immediate);\n\n      try {\n        const argv = immediate._argv;\n        if (!argv)\n          immediate._onImmediate();\n        else\n          immediate._onImmediate(...argv);\n      } finally {\n        immediate._onImmediate = null;\n\n        if (destroyHooksExist())\n          emitDestroy(asyncId);\n\n        outstandingQueue.head = immediate = immediate._idleNext;\n      }\n\n      emitAfter(asyncId);\n    }\n\n    if (queue === outstandingQueue)\n      outstandingQueue.head = null;\n    immediateInfo[kHasOutstanding] = 0;\n  }\n\n\n  function processTimers(now) {\n    debug('process timer lists %d', now);\n    nextExpiry = Infinity;\n\n    let list;\n    let ranAtLeastOneList = false;\n    while (list = timerListQueue.peek()) {\n      if (list.expiry > now) {\n        nextExpiry = list.expiry;\n        return refCount > 0 ? nextExpiry : -nextExpiry;\n      }\n      if (ranAtLeastOneList)\n        runNextTicks();\n      else\n        ranAtLeastOneList = true;\n      listOnTimeout(list, now);\n    }\n    return 0;\n  }\n\n  function listOnTimeout(list, now) {\n    const msecs = list.msecs;\n\n    debug('timeout callback %d', msecs);\n\n    let ranAtLeastOneTimer = false;\n    let timer;\n    while (timer = L.peek(list)) {\n      const diff = now - timer._idleStart;\n\n      // Check if this loop iteration is too early for the next timer.\n      // This happens if there are more timers scheduled for later in the list.\n      if (diff < msecs) {\n        list.expiry = MathMax(timer._idleStart + msecs, now + 1);\n        list.id = timerListId++;\n        timerListQueue.percolateDown(1);\n        debug('%d list wait because diff is %d', msecs, diff);\n        return;\n      }\n\n      if (ranAtLeastOneTimer)\n        runNextTicks();\n      else\n        ranAtLeastOneTimer = true;\n\n      // The actual logic for when a timeout happens.\n      L.remove(timer);\n\n      const asyncId = timer[async_id_symbol];\n\n      if (!timer._onTimeout) {\n        if (!timer._destroyed) {\n          timer._destroyed = true;\n\n          if (timer[kRefed])\n            refCount--;\n\n          if (destroyHooksExist())\n            emitDestroy(asyncId);\n        }\n        continue;\n      }\n\n      emitBefore(asyncId, timer[trigger_async_id_symbol], timer);\n\n      let start;\n      if (timer._repeat)\n        start = getLibuvNow();\n\n      try {\n        const args = timer._timerArgs;\n        if (args === undefined)\n          timer._onTimeout();\n        else\n          timer._onTimeout(...args);\n      } finally {\n        if (timer._repeat && timer._idleTimeout !== -1) {\n          timer._idleTimeout = timer._repeat;\n          insert(timer, timer._idleTimeout, start);\n        } else if (!timer._idleNext && !timer._idlePrev && !timer._destroyed) {\n          timer._destroyed = true;\n\n          if (timer[kRefed])\n            refCount--;\n\n          if (destroyHooksExist())\n            emitDestroy(asyncId);\n        }\n      }\n\n      emitAfter(asyncId);\n    }\n\n    // If `L.peek(list)` returned nothing, the list was either empty or we have\n    // called all of the timer timeouts.\n    // As such, we can remove the list from the object map and\n    // the PriorityQueue.\n    debug('%d list empty', msecs);\n\n    // The current list may have been removed and recreated since the reference\n    // to `list` was created. Make sure they're the same instance of the list\n    // before destroying.\n    if (list === timerListMap[msecs]) {\n      delete timerListMap[msecs];\n      timerListQueue.shift();\n    }\n  }\n\n  return {\n    processImmediate,\n    processTimers\n  };\n}\n\nmodule.exports = {\n  TIMEOUT_MAX,\n  kTimeout: Symbol('timeout'), // For hiding Timeouts on other internals.\n  async_id_symbol,\n  trigger_async_id_symbol,\n  Timeout,\n  kRefed,\n  kHasPrimitive,\n  initAsyncResource,\n  setUnrefTimeout,\n  getTimerDuration,\n  immediateQueue,\n  getTimerCallbacks,\n  immediateInfoFields: {\n    kCount,\n    kRefCount,\n    kHasOutstanding\n  },\n  active,\n  unrefActive,\n  insert,\n  timerListMap,\n  timerListQueue,\n  decRefCount,\n  incRefCount\n};\n"
  },
  {
    "url": "internal/url.js",
    "ranges": [
      {
        "start": 0,
        "end": 2224
      },
      {
        "start": 2520,
        "end": 2732
      },
      {
        "start": 2850,
        "end": 3254
      },
      {
        "start": 3477,
        "end": 3767
      },
      {
        "start": 6130,
        "end": 6134
      },
      {
        "start": 7204,
        "end": 7208
      },
      {
        "start": 7901,
        "end": 7903
      },
      {
        "start": 7978,
        "end": 7980
      },
      {
        "start": 8325,
        "end": 8327
      },
      {
        "start": 8673,
        "end": 8675
      },
      {
        "start": 8837,
        "end": 8839
      },
      {
        "start": 9145,
        "end": 9147
      },
      {
        "start": 9641,
        "end": 9643
      },
      {
        "start": 9811,
        "end": 9813
      },
      {
        "start": 9983,
        "end": 9999
      },
      {
        "start": 10327,
        "end": 10331
      },
      {
        "start": 10412,
        "end": 10416
      },
      {
        "start": 10509,
        "end": 10584
      },
      {
        "start": 10784,
        "end": 10788
      },
      {
        "start": 11721,
        "end": 11890
      },
      {
        "start": 13081,
        "end": 13355
      },
      {
        "start": 13414,
        "end": 13480
      },
      {
        "start": 13525,
        "end": 13531
      },
      {
        "start": 13711,
        "end": 13792
      },
      {
        "start": 14420,
        "end": 14490
      },
      {
        "start": 14538,
        "end": 14544
      },
      {
        "start": 14913,
        "end": 14983
      },
      {
        "start": 15033,
        "end": 15039
      },
      {
        "start": 15437,
        "end": 15507
      },
      {
        "start": 15557,
        "end": 15563
      },
      {
        "start": 15961,
        "end": 16027
      },
      {
        "start": 16183,
        "end": 16189
      },
      {
        "start": 16480,
        "end": 16550
      },
      {
        "start": 16602,
        "end": 16608
      },
      {
        "start": 16907,
        "end": 16973
      },
      {
        "start": 17073,
        "end": 17079
      },
      {
        "start": 17396,
        "end": 17466
      },
      {
        "start": 17661,
        "end": 17667
      },
      {
        "start": 17886,
        "end": 17954
      },
      {
        "start": 18093,
        "end": 18099
      },
      {
        "start": 18591,
        "end": 18678
      },
      {
        "start": 18724,
        "end": 18790
      },
      {
        "start": 18941,
        "end": 18947
      },
      {
        "start": 19365,
        "end": 19511
      },
      {
        "start": 19568,
        "end": 19578
      },
      {
        "start": 19883,
        "end": 19885
      },
      {
        "start": 20025,
        "end": 20134
      },
      {
        "start": 22435,
        "end": 23414
      },
      {
        "start": 23974,
        "end": 24737
      },
      {
        "start": 25367,
        "end": 25434
      },
      {
        "start": 25821,
        "end": 25826
      },
      {
        "start": 26325,
        "end": 26330
      },
      {
        "start": 26764,
        "end": 26769
      },
      {
        "start": 27237,
        "end": 27242
      },
      {
        "start": 27670,
        "end": 27675
      },
      {
        "start": 28701,
        "end": 28706
      },
      {
        "start": 29883,
        "end": 30046
      },
      {
        "start": 30255,
        "end": 30260
      },
      {
        "start": 30832,
        "end": 30887
      },
      {
        "start": 31087,
        "end": 31092
      },
      {
        "start": 31296,
        "end": 31429
      },
      {
        "start": 31629,
        "end": 31909
      },
      {
        "start": 32112,
        "end": 32336
      },
      {
        "start": 33089,
        "end": 33093
      },
      {
        "start": 34307,
        "end": 34313
      },
      {
        "start": 34488,
        "end": 34490
      },
      {
        "start": 34669,
        "end": 34812
      },
      {
        "start": 35355,
        "end": 35391
      },
      {
        "start": 36784,
        "end": 36786
      },
      {
        "start": 37290,
        "end": 37292
      },
      {
        "start": 37639,
        "end": 38399
      },
      {
        "start": 38955,
        "end": 38957
      },
      {
        "start": 40072,
        "end": 40074
      },
      {
        "start": 40193,
        "end": 40195
      },
      {
        "start": 40340,
        "end": 40342
      },
      {
        "start": 41042,
        "end": 41335
      }
    ],
    "text": "'use strict';\n\nconst {\n  Array,\n  Int8Array,\n  Number,\n  ObjectCreate,\n  ObjectDefineProperties,\n  ObjectDefineProperty,\n  ObjectGetOwnPropertySymbols,\n  ObjectGetPrototypeOf,\n  ObjectKeys,\n  ReflectGetOwnPropertyDescriptor,\n  ReflectOwnKeys,\n  String,\n  Symbol,\n  SymbolIterator,\n  SymbolToStringTag,\n} = primordials;\n\nconst { inspect } = require('internal/util/inspect');\nconst {\n  encodeStr,\n  hexTable,\n  isHexTable\n} = require('internal/querystring');\n\nconst { getConstructorOf, removeColors } = require('internal/util');\nconst {\n  ERR_ARG_NOT_ITERABLE,\n  ERR_INVALID_ARG_TYPE,\n  ERR_INVALID_ARG_VALUE,\n  ERR_INVALID_CALLBACK,\n  ERR_INVALID_FILE_URL_HOST,\n  ERR_INVALID_FILE_URL_PATH,\n  ERR_INVALID_THIS,\n  ERR_INVALID_TUPLE,\n  ERR_INVALID_URL,\n  ERR_INVALID_URL_SCHEME,\n  ERR_MISSING_ARGS\n} = require('internal/errors').codes;\nconst {\n  CHAR_AMPERSAND,\n  CHAR_BACKWARD_SLASH,\n  CHAR_EQUAL,\n  CHAR_FORWARD_SLASH,\n  CHAR_LOWERCASE_A,\n  CHAR_LOWERCASE_Z,\n  CHAR_PERCENT,\n  CHAR_PLUS\n} = require('internal/constants');\nconst path = require('path');\n\n// Lazy loaded for startup performance.\nlet querystring;\n\nconst { platform } = process;\nconst isWindows = platform === 'win32';\n\nconst {\n  domainToASCII: _domainToASCII,\n  domainToUnicode: _domainToUnicode,\n  encodeAuth,\n  toUSVString: _toUSVString,\n  parse,\n  setURLConstructor,\n  URL_FLAGS_CANNOT_BE_BASE,\n  URL_FLAGS_HAS_FRAGMENT,\n  URL_FLAGS_HAS_HOST,\n  URL_FLAGS_HAS_PASSWORD,\n  URL_FLAGS_HAS_PATH,\n  URL_FLAGS_HAS_QUERY,\n  URL_FLAGS_HAS_USERNAME,\n  URL_FLAGS_IS_DEFAULT_SCHEME_PORT,\n  URL_FLAGS_SPECIAL,\n  kFragment,\n  kHost,\n  kHostname,\n  kPathStart,\n  kPort,\n  kQuery,\n  kSchemeStart\n} = internalBinding('url');\n\nconst context = Symbol('context');\nconst cannotBeBase = Symbol('cannot-be-base');\nconst cannotHaveUsernamePasswordPort =\n    Symbol('cannot-have-username-password-port');\nconst special = Symbol('special');\nconst searchParams = Symbol('query');\nconst kFormat = Symbol('format');\n\n// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object\nconst IteratorPrototype = ObjectGetPrototypeOf(\n  ObjectGetPrototypeOf([][SymbolIterator]())\n);\n\nconst unpairedSurrogateRe =\n    /(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])/;\nfunction toUSVString(val) {\n  const str = `${val}`;\n  // As of V8 5.5, `str.search()` (and `unpairedSurrogateRe[@@search]()`) are\n  // slower than `unpairedSurrogateRe.exec()`.\n  const match = unpairedSurrogateRe.exec(str);\n  if (!match)\n    return str;\n  return _toUSVString(str, match.index);\n}\n\n// Refs: https://html.spec.whatwg.org/multipage/browsers.html#concept-origin-opaque\nconst kOpaqueOrigin = 'null';\n\n// Refs: https://html.spec.whatwg.org/multipage/browsers.html#ascii-serialisation-of-an-origin\nfunction serializeTupleOrigin(scheme, host, port) {\n  return `${scheme}//${host}${port === null ? '' : `:${port}`}`;\n}\n\n// This class provides the internal state of a URL object. An instance of this\n// class is stored in every URL object and is accessed internally by setters\n// and getters. It roughly corresponds to the concept of a URL record in the\n// URL Standard, with a few differences. It is also the object transported to\n// the C++ binding.\n// Refs: https://url.spec.whatwg.org/#concept-url\nclass URLContext {\n  constructor() {\n    this.flags = 0;\n    this.scheme = ':';\n    this.username = '';\n    this.password = '';\n    this.host = null;\n    this.port = null;\n    this.path = [];\n    this.query = null;\n    this.fragment = null;\n  }\n}\n\nclass URLSearchParams {\n  // URL Standard says the default value is '', but as undefined and '' have\n  // the same result, undefined is used to prevent unnecessary parsing.\n  // Default parameter is necessary to keep URLSearchParams.length === 0 in\n  // accordance with Web IDL spec.\n  constructor(init = undefined) {\n    if (init === null || init === undefined) {\n      this[searchParams] = [];\n    } else if (typeof init === 'object' || typeof init === 'function') {\n      const method = init[SymbolIterator];\n      if (method === this[SymbolIterator]) {\n        // While the spec does not have this branch, we can use it as a\n        // shortcut to avoid having to go through the costly generic iterator.\n        const childParams = init[searchParams];\n        this[searchParams] = childParams.slice();\n      } else if (method !== null && method !== undefined) {\n        if (typeof method !== 'function') {\n          throw new ERR_ARG_NOT_ITERABLE('Query pairs');\n        }\n\n        // Sequence<sequence<USVString>>\n        // Note: per spec we have to first exhaust the lists then process them\n        const pairs = [];\n        for (const pair of init) {\n          if ((typeof pair !== 'object' && typeof pair !== 'function') ||\n              pair === null ||\n              typeof pair[SymbolIterator] !== 'function') {\n            throw new ERR_INVALID_TUPLE('Each query pair', '[name, value]');\n          }\n          const convertedPair = [];\n          for (const element of pair)\n            convertedPair.push(toUSVString(element));\n          pairs.push(convertedPair);\n        }\n\n        this[searchParams] = [];\n        for (const pair of pairs) {\n          if (pair.length !== 2) {\n            throw new ERR_INVALID_TUPLE('Each query pair', '[name, value]');\n          }\n          this[searchParams].push(pair[0], pair[1]);\n        }\n      } else {\n        // Record<USVString, USVString>\n        // Need to use reflection APIs for full spec compliance.\n        this[searchParams] = [];\n        const keys = ReflectOwnKeys(init);\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          const desc = ReflectGetOwnPropertyDescriptor(init, key);\n          if (desc !== undefined && desc.enumerable) {\n            const typedKey = toUSVString(key);\n            const typedValue = toUSVString(init[key]);\n            this[searchParams].push(typedKey, typedValue);\n          }\n        }\n      }\n    } else {\n      // USVString\n      init = toUSVString(init);\n      if (init[0] === '?') init = init.slice(1);\n      initSearchParams(this, init);\n    }\n\n    // \"associated url object\"\n    this[context] = null;\n  }\n\n  [inspect.custom](recurseTimes, ctx) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new ERR_INVALID_THIS('URLSearchParams');\n    }\n\n    if (typeof recurseTimes === 'number' && recurseTimes < 0)\n      return ctx.stylize('[Object]', 'special');\n\n    const separator = ', ';\n    const innerOpts = { ...ctx };\n    if (recurseTimes !== null) {\n      innerOpts.depth = recurseTimes - 1;\n    }\n    const innerInspect = (v) => inspect(v, innerOpts);\n\n    const list = this[searchParams];\n    const output = [];\n    for (let i = 0; i < list.length; i += 2)\n      output.push(`${innerInspect(list[i])} => ${innerInspect(list[i + 1])}`);\n\n    const length = output.reduce(\n      (prev, cur) => prev + removeColors(cur).length + separator.length,\n      -separator.length\n    );\n    if (length > ctx.breakLength) {\n      return `${this.constructor.name} {\\n  ${output.join(',\\n  ')} }`;\n    } else if (output.length) {\n      return `${this.constructor.name} { ${output.join(separator)} }`;\n    }\n    return `${this.constructor.name} {}`;\n  }\n}\n\nfunction onParseComplete(flags, protocol, username, password,\n                         host, port, path, query, fragment) {\n  const ctx = this[context];\n  ctx.flags = flags;\n  ctx.scheme = protocol;\n  ctx.username = (flags & URL_FLAGS_HAS_USERNAME) !== 0 ? username : '';\n  ctx.password = (flags & URL_FLAGS_HAS_PASSWORD) !== 0 ? password : '';\n  ctx.port = port;\n  ctx.path = (flags & URL_FLAGS_HAS_PATH) !== 0 ? path : [];\n  ctx.query = query;\n  ctx.fragment = fragment;\n  ctx.host = host;\n  if (!this[searchParams]) { // Invoked from URL constructor\n    this[searchParams] = new URLSearchParams();\n    this[searchParams][context] = this;\n  }\n  initSearchParams(this[searchParams], query);\n}\n\nfunction onParseError(flags, input) {\n  throw new ERR_INVALID_URL(input);\n}\n\nfunction onParseProtocolComplete(flags, protocol, username, password,\n                                 host, port, path, query, fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_SPECIAL) !== 0) {\n    ctx.flags |= URL_FLAGS_SPECIAL;\n  } else {\n    ctx.flags &= ~URL_FLAGS_SPECIAL;\n  }\n  ctx.scheme = protocol;\n  ctx.port = port;\n}\n\nfunction onParseHostnameComplete(flags, protocol, username, password,\n                                 host, port, path, query, fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_HAS_HOST) !== 0) {\n    ctx.host = host;\n    ctx.flags |= URL_FLAGS_HAS_HOST;\n  } else {\n    ctx.host = null;\n    ctx.flags &= ~URL_FLAGS_HAS_HOST;\n  }\n}\n\nfunction onParsePortComplete(flags, protocol, username, password,\n                             host, port, path, query, fragment) {\n  this[context].port = port;\n}\n\nfunction onParseHostComplete(flags, protocol, username, password,\n                             host, port, path, query, fragment) {\n  onParseHostnameComplete.apply(this, arguments);\n  if (port !== null || ((flags & URL_FLAGS_IS_DEFAULT_SCHEME_PORT) !== 0))\n    onParsePortComplete.apply(this, arguments);\n}\n\nfunction onParsePathComplete(flags, protocol, username, password,\n                             host, port, path, query, fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_HAS_PATH) !== 0) {\n    ctx.path = path;\n    ctx.flags |= URL_FLAGS_HAS_PATH;\n  } else {\n    ctx.path = [];\n    ctx.flags &= ~URL_FLAGS_HAS_PATH;\n  }\n\n  // The C++ binding may set host to empty string.\n  if ((flags & URL_FLAGS_HAS_HOST) !== 0) {\n    ctx.host = host;\n    ctx.flags |= URL_FLAGS_HAS_HOST;\n  }\n}\n\nfunction onParseSearchComplete(flags, protocol, username, password,\n                               host, port, path, query, fragment) {\n  this[context].query = query;\n}\n\nfunction onParseHashComplete(flags, protocol, username, password,\n                             host, port, path, query, fragment) {\n  this[context].fragment = fragment;\n}\n\nclass URL {\n  constructor(input, base) {\n    // toUSVString is not needed.\n    input = `${input}`;\n    let base_context;\n    if (base !== undefined) {\n      base_context = new URL(base)[context];\n    }\n    this[context] = new URLContext();\n    parse(input, -1, base_context, undefined, onParseComplete.bind(this),\n          onParseError);\n  }\n\n  get [special]() {\n    return (this[context].flags & URL_FLAGS_SPECIAL) !== 0;\n  }\n\n  get [cannotBeBase]() {\n    return (this[context].flags & URL_FLAGS_CANNOT_BE_BASE) !== 0;\n  }\n\n  // https://url.spec.whatwg.org/#cannot-have-a-username-password-port\n  get [cannotHaveUsernamePasswordPort]() {\n    const { host, scheme } = this[context];\n    return ((host == null || host === '') ||\n            this[cannotBeBase] ||\n            scheme === 'file:');\n  }\n\n  [inspect.custom](depth, opts) {\n    if (this == null ||\n        ObjectGetPrototypeOf(this[context]) !== URLContext.prototype) {\n      throw new ERR_INVALID_THIS('URL');\n    }\n\n    if (typeof depth === 'number' && depth < 0)\n      return this;\n\n    const constructor = getConstructorOf(this) || URL;\n    const obj = ObjectCreate({ constructor });\n\n    obj.href = this.href;\n    obj.origin = this.origin;\n    obj.protocol = this.protocol;\n    obj.username = this.username;\n    obj.password = this.password;\n    obj.host = this.host;\n    obj.hostname = this.hostname;\n    obj.port = this.port;\n    obj.pathname = this.pathname;\n    obj.search = this.search;\n    obj.searchParams = this.searchParams;\n    obj.hash = this.hash;\n\n    if (opts.showHidden) {\n      obj.cannotBeBase = this[cannotBeBase];\n      obj.special = this[special];\n      obj[context] = this[context];\n    }\n\n    return `${constructor.name} ${inspect(obj, opts)}`;\n  }\n}\n\nObjectDefineProperties(URL.prototype, {\n  [kFormat]: {\n    enumerable: false,\n    configurable: false,\n    // eslint-disable-next-line func-name-matching\n    value: function format(options) {\n      if (options && typeof options !== 'object')\n        throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);\n      options = {\n        fragment: true,\n        unicode: false,\n        search: true,\n        auth: true,\n        ...options\n      };\n      const ctx = this[context];\n      let ret = ctx.scheme;\n      if (ctx.host !== null) {\n        ret += '//';\n        const has_username = ctx.username !== '';\n        const has_password = ctx.password !== '';\n        if (options.auth && (has_username || has_password)) {\n          if (has_username)\n            ret += ctx.username;\n          if (has_password)\n            ret += `:${ctx.password}`;\n          ret += '@';\n        }\n        ret += options.unicode ?\n          domainToUnicode(this.hostname) : this.hostname;\n        if (ctx.port !== null)\n          ret += `:${ctx.port}`;\n      } else if (ctx.scheme === 'file:') {\n        ret += '//';\n      }\n      if (this.pathname)\n        ret += this.pathname;\n      if (options.search && ctx.query !== null)\n        ret += `?${ctx.query}`;\n      if (options.fragment && ctx.fragment !== null)\n        ret += `#${ctx.fragment}`;\n      return ret;\n    }\n  },\n  [SymbolToStringTag]: {\n    configurable: true,\n    value: 'URL'\n  },\n  toString: {\n    // https://heycam.github.io/webidl/#es-stringifier\n    writable: true,\n    enumerable: true,\n    configurable: true,\n    // eslint-disable-next-line func-name-matching\n    value: function toString() {\n      return this[kFormat]({});\n    }\n  },\n  href: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      return this[kFormat]({});\n    },\n    set(input) {\n      // toUSVString is not needed.\n      input = `${input}`;\n      parse(input, -1, undefined, undefined, onParseComplete.bind(this),\n            onParseError);\n    }\n  },\n  origin: {  // readonly\n    enumerable: true,\n    configurable: true,\n    get() {\n      // Refs: https://url.spec.whatwg.org/#concept-url-origin\n      const ctx = this[context];\n      switch (ctx.scheme) {\n        case 'blob:':\n          if (ctx.path.length > 0) {\n            try {\n              return (new URL(ctx.path[0])).origin;\n            } catch {\n              // Fall through... do nothing\n            }\n          }\n          return kOpaqueOrigin;\n        case 'ftp:':\n        case 'gopher:':\n        case 'http:':\n        case 'https:':\n        case 'ws:':\n        case 'wss:':\n          return serializeTupleOrigin(ctx.scheme, ctx.host, ctx.port);\n      }\n      return kOpaqueOrigin;\n    }\n  },\n  protocol: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      return this[context].scheme;\n    },\n    set(scheme) {\n      // toUSVString is not needed.\n      scheme = `${scheme}`;\n      if (scheme.length === 0)\n        return;\n      const ctx = this[context];\n      if (ctx.scheme === 'file:' &&\n          (ctx.host === '' || ctx.host === null)) {\n        return;\n      }\n      parse(scheme, kSchemeStart, null, ctx,\n            onParseProtocolComplete.bind(this));\n    }\n  },\n  username: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      return this[context].username;\n    },\n    set(username) {\n      // toUSVString is not needed.\n      username = `${username}`;\n      if (this[cannotHaveUsernamePasswordPort])\n        return;\n      const ctx = this[context];\n      if (username === '') {\n        ctx.username = '';\n        ctx.flags &= ~URL_FLAGS_HAS_USERNAME;\n        return;\n      }\n      ctx.username = encodeAuth(username);\n      ctx.flags |= URL_FLAGS_HAS_USERNAME;\n    }\n  },\n  password: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      return this[context].password;\n    },\n    set(password) {\n      // toUSVString is not needed.\n      password = `${password}`;\n      if (this[cannotHaveUsernamePasswordPort])\n        return;\n      const ctx = this[context];\n      if (password === '') {\n        ctx.password = '';\n        ctx.flags &= ~URL_FLAGS_HAS_PASSWORD;\n        return;\n      }\n      ctx.password = encodeAuth(password);\n      ctx.flags |= URL_FLAGS_HAS_PASSWORD;\n    }\n  },\n  host: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      const ctx = this[context];\n      let ret = ctx.host || '';\n      if (ctx.port !== null)\n        ret += `:${ctx.port}`;\n      return ret;\n    },\n    set(host) {\n      const ctx = this[context];\n      // toUSVString is not needed.\n      host = `${host}`;\n      if (this[cannotBeBase]) {\n        // Cannot set the host if cannot-be-base is set\n        return;\n      }\n      parse(host, kHost, null, ctx, onParseHostComplete.bind(this));\n    }\n  },\n  hostname: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      return this[context].host || '';\n    },\n    set(host) {\n      const ctx = this[context];\n      // toUSVString is not needed.\n      host = `${host}`;\n      if (this[cannotBeBase]) {\n        // Cannot set the host if cannot-be-base is set\n        return;\n      }\n      parse(host, kHostname, null, ctx, onParseHostnameComplete.bind(this));\n    }\n  },\n  port: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      const port = this[context].port;\n      return port === null ? '' : String(port);\n    },\n    set(port) {\n      // toUSVString is not needed.\n      port = `${port}`;\n      if (this[cannotHaveUsernamePasswordPort])\n        return;\n      const ctx = this[context];\n      if (port === '') {\n        ctx.port = null;\n        return;\n      }\n      parse(port, kPort, null, ctx, onParsePortComplete.bind(this));\n    }\n  },\n  pathname: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      const ctx = this[context];\n      if (this[cannotBeBase])\n        return ctx.path[0];\n      if (ctx.path.length === 0)\n        return '';\n      return `/${ctx.path.join('/')}`;\n    },\n    set(path) {\n      // toUSVString is not needed.\n      path = `${path}`;\n      if (this[cannotBeBase])\n        return;\n      parse(path, kPathStart, null, this[context],\n            onParsePathComplete.bind(this));\n    }\n  },\n  search: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      const { query } = this[context];\n      if (query === null || query === '')\n        return '';\n      return `?${query}`;\n    },\n    set(search) {\n      const ctx = this[context];\n      search = toUSVString(search);\n      if (search === '') {\n        ctx.query = null;\n        ctx.flags &= ~URL_FLAGS_HAS_QUERY;\n      } else {\n        if (search[0] === '?') search = search.slice(1);\n        ctx.query = '';\n        ctx.flags |= URL_FLAGS_HAS_QUERY;\n        if (search) {\n          parse(search, kQuery, null, ctx, onParseSearchComplete.bind(this));\n        }\n      }\n      initSearchParams(this[searchParams], search);\n    }\n  },\n  searchParams: {  // readonly\n    enumerable: true,\n    configurable: true,\n    get() {\n      return this[searchParams];\n    }\n  },\n  hash: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      const { fragment } = this[context];\n      if (fragment === null || fragment === '')\n        return '';\n      return `#${fragment}`;\n    },\n    set(hash) {\n      const ctx = this[context];\n      // toUSVString is not needed.\n      hash = `${hash}`;\n      if (!hash) {\n        ctx.fragment = null;\n        ctx.flags &= ~URL_FLAGS_HAS_FRAGMENT;\n        return;\n      }\n      if (hash[0] === '#') hash = hash.slice(1);\n      ctx.fragment = '';\n      ctx.flags |= URL_FLAGS_HAS_FRAGMENT;\n      parse(hash, kFragment, null, ctx, onParseHashComplete.bind(this));\n    }\n  },\n  toJSON: {\n    writable: true,\n    enumerable: true,\n    configurable: true,\n    // eslint-disable-next-line func-name-matching\n    value: function toJSON() {\n      return this[kFormat]({});\n    }\n  }\n});\n\nfunction update(url, params) {\n  if (!url)\n    return;\n\n  const ctx = url[context];\n  const serializedParams = params.toString();\n  if (serializedParams) {\n    ctx.query = serializedParams;\n    ctx.flags |= URL_FLAGS_HAS_QUERY;\n  } else {\n    ctx.query = null;\n    ctx.flags &= ~URL_FLAGS_HAS_QUERY;\n  }\n}\n\nfunction initSearchParams(url, init) {\n  if (!init) {\n    url[searchParams] = [];\n    return;\n  }\n  url[searchParams] = parseParams(init);\n}\n\n// application/x-www-form-urlencoded parser\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-parser\nfunction parseParams(qs) {\n  const out = [];\n  let pairStart = 0;\n  let lastPos = 0;\n  let seenSep = false;\n  let buf = '';\n  let encoded = false;\n  let encodeCheck = 0;\n  let i;\n  for (i = 0; i < qs.length; ++i) {\n    const code = qs.charCodeAt(i);\n\n    // Try matching key/value pair separator\n    if (code === CHAR_AMPERSAND) {\n      if (pairStart === i) {\n        // We saw an empty substring between pair separators\n        lastPos = pairStart = i + 1;\n        continue;\n      }\n\n      if (lastPos < i)\n        buf += qs.slice(lastPos, i);\n      if (encoded)\n        buf = querystring.unescape(buf);\n      out.push(buf);\n\n      // If `buf` is the key, add an empty value.\n      if (!seenSep)\n        out.push('');\n\n      seenSep = false;\n      buf = '';\n      encoded = false;\n      encodeCheck = 0;\n      lastPos = pairStart = i + 1;\n      continue;\n    }\n\n    // Try matching key/value separator (e.g. '=') if we haven't already\n    if (!seenSep && code === CHAR_EQUAL) {\n      // Key/value separator match!\n      if (lastPos < i)\n        buf += qs.slice(lastPos, i);\n      if (encoded)\n        buf = querystring.unescape(buf);\n      out.push(buf);\n\n      seenSep = true;\n      buf = '';\n      encoded = false;\n      encodeCheck = 0;\n      lastPos = i + 1;\n      continue;\n    }\n\n    // Handle + and percent decoding.\n    if (code === CHAR_PLUS) {\n      if (lastPos < i)\n        buf += qs.slice(lastPos, i);\n      buf += ' ';\n      lastPos = i + 1;\n    } else if (!encoded) {\n      // Try to match an (valid) encoded byte (once) to minimize unnecessary\n      // calls to string decoding functions\n      if (code === CHAR_PERCENT) {\n        encodeCheck = 1;\n      } else if (encodeCheck > 0) {\n        if (isHexTable[code] === 1) {\n          if (++encodeCheck === 3) {\n            querystring = require('querystring');\n            encoded = true;\n          }\n        } else {\n          encodeCheck = 0;\n        }\n      }\n    }\n  }\n\n  // Deal with any leftover key or value data\n\n  // There is a trailing &. No more processing is needed.\n  if (pairStart === i)\n    return out;\n\n  if (lastPos < i)\n    buf += qs.slice(lastPos, i);\n  if (encoded)\n    buf = querystring.unescape(buf);\n  out.push(buf);\n\n  // If `buf` is the key, add an empty value.\n  if (!seenSep)\n    out.push('');\n\n  return out;\n}\n\n// Adapted from querystring's implementation.\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-byte-serializer\nconst noEscape = new Int8Array([\n/*\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F\n*/\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0x00 - 0x0F\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0x10 - 0x1F\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, // 0x20 - 0x2F\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 0x30 - 0x3F\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 0x40 - 0x4F\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, // 0x50 - 0x5F\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 0x60 - 0x6F\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0  // 0x70 - 0x7F\n]);\n\n// Special version of hexTable that uses `+` for U+0020 SPACE.\nconst paramHexTable = hexTable.slice();\nparamHexTable[0x20] = '+';\n\n// application/x-www-form-urlencoded serializer\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-serializer\nfunction serializeParams(array) {\n  const len = array.length;\n  if (len === 0)\n    return '';\n\n  const firstEncodedParam = encodeStr(array[0], noEscape, paramHexTable);\n  const firstEncodedValue = encodeStr(array[1], noEscape, paramHexTable);\n  let output = `${firstEncodedParam}=${firstEncodedValue}`;\n\n  for (let i = 2; i < len; i += 2) {\n    const encodedParam = encodeStr(array[i], noEscape, paramHexTable);\n    const encodedValue = encodeStr(array[i + 1], noEscape, paramHexTable);\n    output += `&${encodedParam}=${encodedValue}`;\n  }\n\n  return output;\n}\n\n// Mainly to mitigate func-name-matching ESLint rule\nfunction defineIDLClass(proto, classStr, obj) {\n  // https://heycam.github.io/webidl/#dfn-class-string\n  ObjectDefineProperty(proto, SymbolToStringTag, {\n    writable: false,\n    enumerable: false,\n    configurable: true,\n    value: classStr\n  });\n\n  // https://heycam.github.io/webidl/#es-operations\n  for (const key of ObjectKeys(obj)) {\n    ObjectDefineProperty(proto, key, {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: obj[key]\n    });\n  }\n  for (const key of ObjectGetOwnPropertySymbols(obj)) {\n    ObjectDefineProperty(proto, key, {\n      writable: true,\n      enumerable: false,\n      configurable: true,\n      value: obj[key]\n    });\n  }\n}\n\n// for merge sort\nfunction merge(out, start, mid, end, lBuffer, rBuffer) {\n  const sizeLeft = mid - start;\n  const sizeRight = end - mid;\n  let l, r, o;\n\n  for (l = 0; l < sizeLeft; l++)\n    lBuffer[l] = out[start + l];\n  for (r = 0; r < sizeRight; r++)\n    rBuffer[r] = out[mid + r];\n\n  l = 0;\n  r = 0;\n  o = start;\n  while (l < sizeLeft && r < sizeRight) {\n    if (lBuffer[l] <= rBuffer[r]) {\n      out[o++] = lBuffer[l++];\n      out[o++] = lBuffer[l++];\n    } else {\n      out[o++] = rBuffer[r++];\n      out[o++] = rBuffer[r++];\n    }\n  }\n  while (l < sizeLeft)\n    out[o++] = lBuffer[l++];\n  while (r < sizeRight)\n    out[o++] = rBuffer[r++];\n}\n\ndefineIDLClass(URLSearchParams.prototype, 'URLSearchParams', {\n  append(name, value) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new ERR_INVALID_THIS('URLSearchParams');\n    }\n    if (arguments.length < 2) {\n      throw new ERR_MISSING_ARGS('name', 'value');\n    }\n\n    name = toUSVString(name);\n    value = toUSVString(value);\n    this[searchParams].push(name, value);\n    update(this[context], this);\n  },\n\n  delete(name) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new ERR_INVALID_THIS('URLSearchParams');\n    }\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length;) {\n      const cur = list[i];\n      if (cur === name) {\n        list.splice(i, 2);\n      } else {\n        i += 2;\n      }\n    }\n    update(this[context], this);\n  },\n\n  get(name) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new ERR_INVALID_THIS('URLSearchParams');\n    }\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        return list[i + 1];\n      }\n    }\n    return null;\n  },\n\n  getAll(name) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new ERR_INVALID_THIS('URLSearchParams');\n    }\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    const values = [];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        values.push(list[i + 1]);\n      }\n    }\n    return values;\n  },\n\n  has(name) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new ERR_INVALID_THIS('URLSearchParams');\n    }\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        return true;\n      }\n    }\n    return false;\n  },\n\n  set(name, value) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new ERR_INVALID_THIS('URLSearchParams');\n    }\n    if (arguments.length < 2) {\n      throw new ERR_MISSING_ARGS('name', 'value');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    value = toUSVString(value);\n\n    // If there are any name-value pairs whose name is `name`, in `list`, set\n    // the value of the first such name-value pair to `value` and remove the\n    // others.\n    let found = false;\n    for (let i = 0; i < list.length;) {\n      const cur = list[i];\n      if (cur === name) {\n        if (!found) {\n          list[i + 1] = value;\n          found = true;\n          i += 2;\n        } else {\n          list.splice(i, 2);\n        }\n      } else {\n        i += 2;\n      }\n    }\n\n    // Otherwise, append a new name-value pair whose name is `name` and value\n    // is `value`, to `list`.\n    if (!found) {\n      list.push(name, value);\n    }\n\n    update(this[context], this);\n  },\n\n  sort() {\n    const a = this[searchParams];\n    const len = a.length;\n\n    if (len <= 2) {\n      // Nothing needs to be done.\n    } else if (len < 100) {\n      // 100 is found through testing.\n      // Simple stable in-place insertion sort\n      // Derived from v8/src/js/array.js\n      for (let i = 2; i < len; i += 2) {\n        const curKey = a[i];\n        const curVal = a[i + 1];\n        let j;\n        for (j = i - 2; j >= 0; j -= 2) {\n          if (a[j] > curKey) {\n            a[j + 2] = a[j];\n            a[j + 3] = a[j + 1];\n          } else {\n            break;\n          }\n        }\n        a[j + 2] = curKey;\n        a[j + 3] = curVal;\n      }\n    } else {\n      // Bottom-up iterative stable merge sort\n      const lBuffer = new Array(len);\n      const rBuffer = new Array(len);\n      for (let step = 2; step < len; step *= 2) {\n        for (let start = 0; start < len - 2; start += 2 * step) {\n          const mid = start + step;\n          let end = mid + step;\n          end = end < len ? end : len;\n          if (mid > end)\n            continue;\n          merge(a, start, mid, end, lBuffer, rBuffer);\n        }\n      }\n    }\n\n    update(this[context], this);\n  },\n\n  // https://heycam.github.io/webidl/#es-iterators\n  // Define entries here rather than [Symbol.iterator] as the function name\n  // must be set to `entries`.\n  entries() {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new ERR_INVALID_THIS('URLSearchParams');\n    }\n\n    return createSearchParamsIterator(this, 'key+value');\n  },\n\n  forEach(callback, thisArg = undefined) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new ERR_INVALID_THIS('URLSearchParams');\n    }\n    if (typeof callback !== 'function') {\n      throw new ERR_INVALID_CALLBACK(callback);\n    }\n\n    let list = this[searchParams];\n\n    let i = 0;\n    while (i < list.length) {\n      const key = list[i];\n      const value = list[i + 1];\n      callback.call(thisArg, value, key, this);\n      // In case the URL object's `search` is updated\n      list = this[searchParams];\n      i += 2;\n    }\n  },\n\n  // https://heycam.github.io/webidl/#es-iterable\n  keys() {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new ERR_INVALID_THIS('URLSearchParams');\n    }\n\n    return createSearchParamsIterator(this, 'key');\n  },\n\n  values() {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new ERR_INVALID_THIS('URLSearchParams');\n    }\n\n    return createSearchParamsIterator(this, 'value');\n  },\n\n  // https://heycam.github.io/webidl/#es-stringifier\n  // https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior\n  toString() {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new ERR_INVALID_THIS('URLSearchParams');\n    }\n\n    return serializeParams(this[searchParams]);\n  }\n});\n\n// https://heycam.github.io/webidl/#es-iterable-entries\nObjectDefineProperty(URLSearchParams.prototype, SymbolIterator, {\n  writable: true,\n  configurable: true,\n  value: URLSearchParams.prototype.entries\n});\n\n// https://heycam.github.io/webidl/#dfn-default-iterator-object\nfunction createSearchParamsIterator(target, kind) {\n  const iterator = ObjectCreate(URLSearchParamsIteratorPrototype);\n  iterator[context] = {\n    target,\n    kind,\n    index: 0\n  };\n  return iterator;\n}\n\n// https://heycam.github.io/webidl/#dfn-iterator-prototype-object\nconst URLSearchParamsIteratorPrototype = ObjectCreate(IteratorPrototype);\n\ndefineIDLClass(URLSearchParamsIteratorPrototype, 'URLSearchParams Iterator', {\n  next() {\n    if (!this ||\n        ObjectGetPrototypeOf(this) !== URLSearchParamsIteratorPrototype) {\n      throw new ERR_INVALID_THIS('URLSearchParamsIterator');\n    }\n\n    const {\n      target,\n      kind,\n      index\n    } = this[context];\n    const values = target[searchParams];\n    const len = values.length;\n    if (index >= len) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    const name = values[index];\n    const value = values[index + 1];\n    this[context].index = index + 2;\n\n    let result;\n    if (kind === 'key') {\n      result = name;\n    } else if (kind === 'value') {\n      result = value;\n    } else {\n      result = [name, value];\n    }\n\n    return {\n      value: result,\n      done: false\n    };\n  },\n  [inspect.custom](recurseTimes, ctx) {\n    if (this == null || this[context] == null || this[context].target == null)\n      throw new ERR_INVALID_THIS('URLSearchParamsIterator');\n\n    if (typeof recurseTimes === 'number' && recurseTimes < 0)\n      return ctx.stylize('[Object]', 'special');\n\n    const innerOpts = { ...ctx };\n    if (recurseTimes !== null) {\n      innerOpts.depth = recurseTimes - 1;\n    }\n    const {\n      target,\n      kind,\n      index\n    } = this[context];\n    const output = target[searchParams].slice(index).reduce((prev, cur, i) => {\n      const key = i % 2 === 0;\n      if (kind === 'key' && key) {\n        prev.push(cur);\n      } else if (kind === 'value' && !key) {\n        prev.push(cur);\n      } else if (kind === 'key+value' && !key) {\n        prev.push([target[searchParams][index + i - 1], cur]);\n      }\n      return prev;\n    }, []);\n    const breakLn = inspect(output, innerOpts).includes('\\n');\n    const outputStrs = output.map((p) => inspect(p, innerOpts));\n    let outputStr;\n    if (breakLn) {\n      outputStr = `\\n  ${outputStrs.join(',\\n  ')}`;\n    } else {\n      outputStr = ` ${outputStrs.join(', ')}`;\n    }\n    return `${this[SymbolToStringTag]} {${outputStr} }`;\n  }\n});\n\nfunction domainToASCII(domain) {\n  if (arguments.length < 1)\n    throw new ERR_MISSING_ARGS('domain');\n\n  // toUSVString is not needed.\n  return _domainToASCII(`${domain}`);\n}\n\nfunction domainToUnicode(domain) {\n  if (arguments.length < 1)\n    throw new ERR_MISSING_ARGS('domain');\n\n  // toUSVString is not needed.\n  return _domainToUnicode(`${domain}`);\n}\n\n// Utility function that converts a URL object into an ordinary\n// options object as expected by the http.request and https.request\n// APIs.\nfunction urlToOptions(url) {\n  const options = {\n    protocol: url.protocol,\n    hostname: typeof url.hostname === 'string' && url.hostname.startsWith('[') ?\n      url.hostname.slice(1, -1) :\n      url.hostname,\n    hash: url.hash,\n    search: url.search,\n    pathname: url.pathname,\n    path: `${url.pathname || ''}${url.search || ''}`,\n    href: url.href\n  };\n  if (url.port !== '') {\n    options.port = Number(url.port);\n  }\n  if (url.username || url.password) {\n    options.auth = `${url.username}:${url.password}`;\n  }\n  return options;\n}\n\nconst forwardSlashRegEx = /\\//g;\n\nfunction getPathFromURLWin32(url) {\n  const hostname = url.hostname;\n  let pathname = url.pathname;\n  for (let n = 0; n < pathname.length; n++) {\n    if (pathname[n] === '%') {\n      const third = pathname.codePointAt(n + 2) | 0x20;\n      if ((pathname[n + 1] === '2' && third === 102) || // 2f 2F /\n          (pathname[n + 1] === '5' && third === 99)) {  // 5c 5C \\\n        throw new ERR_INVALID_FILE_URL_PATH(\n          'must not include encoded \\\\ or / characters'\n        );\n      }\n    }\n  }\n  pathname = pathname.replace(forwardSlashRegEx, '\\\\');\n  pathname = decodeURIComponent(pathname);\n  if (hostname !== '') {\n    // If hostname is set, then we have a UNC path\n    // Pass the hostname through domainToUnicode just in case\n    // it is an IDN using punycode encoding. We do not need to worry\n    // about percent encoding because the URL parser will have\n    // already taken care of that for us. Note that this only\n    // causes IDNs with an appropriate `xn--` prefix to be decoded.\n    return `\\\\\\\\${domainToUnicode(hostname)}${pathname}`;\n  }\n  // Otherwise, it's a local path that requires a drive letter\n  const letter = pathname.codePointAt(1) | 0x20;\n  const sep = pathname[2];\n  if (letter < CHAR_LOWERCASE_A || letter > CHAR_LOWERCASE_Z ||   // a..z A..Z\n      (sep !== ':')) {\n    throw new ERR_INVALID_FILE_URL_PATH('must be absolute');\n  }\n  return pathname.slice(1);\n}\n\nfunction getPathFromURLPosix(url) {\n  if (url.hostname !== '') {\n    throw new ERR_INVALID_FILE_URL_HOST(platform);\n  }\n  const pathname = url.pathname;\n  for (let n = 0; n < pathname.length; n++) {\n    if (pathname[n] === '%') {\n      const third = pathname.codePointAt(n + 2) | 0x20;\n      if (pathname[n + 1] === '2' && third === 102) {\n        throw new ERR_INVALID_FILE_URL_PATH(\n          'must not include encoded / characters'\n        );\n      }\n    }\n  }\n  return decodeURIComponent(pathname);\n}\n\nfunction fileURLToPath(path) {\n  if (typeof path === 'string')\n    path = new URL(path);\n  else if (!isURLInstance(path))\n    throw new ERR_INVALID_ARG_TYPE('path', ['string', 'URL'], path);\n  if (path.protocol !== 'file:')\n    throw new ERR_INVALID_URL_SCHEME('file');\n  return isWindows ? getPathFromURLWin32(path) : getPathFromURLPosix(path);\n}\n\n// The following characters are percent-encoded when converting from file path\n// to URL:\n// - %: The percent character is the only character not encoded by the\n//        `pathname` setter.\n// - \\: Backslash is encoded on non-windows platforms since it's a valid\n//      character but the `pathname` setters replaces it by a forward slash.\n// - LF: The newline character is stripped out by the `pathname` setter.\n//       (See whatwg/url#419)\n// - CR: The carriage return character is also stripped out by the `pathname`\n//       setter.\n// - TAB: The tab character is also stripped out by the `pathname` setter.\nconst percentRegEx = /%/g;\nconst backslashRegEx = /\\\\/g;\nconst newlineRegEx = /\\n/g;\nconst carriageReturnRegEx = /\\r/g;\nconst tabRegEx = /\\t/g;\n\nfunction encodePathChars(filepath) {\n  if (filepath.includes('%'))\n    filepath = filepath.replace(percentRegEx, '%25');\n  // In posix, backslash is a valid character in paths:\n  if (!isWindows && filepath.includes('\\\\'))\n    filepath = filepath.replace(backslashRegEx, '%5C');\n  if (filepath.includes('\\n'))\n    filepath = filepath.replace(newlineRegEx, '%0A');\n  if (filepath.includes('\\r'))\n    filepath = filepath.replace(carriageReturnRegEx, '%0D');\n  if (filepath.includes('\\t'))\n    filepath = filepath.replace(tabRegEx, '%09');\n  return filepath;\n}\n\nfunction pathToFileURL(filepath) {\n  const outURL = new URL('file://');\n  if (isWindows && filepath.startsWith('\\\\\\\\')) {\n    // UNC path format: \\\\server\\share\\resource\n    const paths = filepath.split('\\\\');\n    if (paths.length <= 3) {\n      throw new ERR_INVALID_ARG_VALUE(\n        'filepath',\n        filepath,\n        'Missing UNC resource path'\n      );\n    }\n    const hostname = paths[2];\n    if (hostname.length === 0) {\n      throw new ERR_INVALID_ARG_VALUE(\n        'filepath',\n        filepath,\n        'Empty UNC servername'\n      );\n    }\n    outURL.hostname = domainToASCII(hostname);\n    outURL.pathname = encodePathChars(paths.slice(3).join('/'));\n  } else {\n    let resolved = path.resolve(filepath);\n    // path.resolve strips trailing slashes so we must add them back\n    const filePathLast = filepath.charCodeAt(filepath.length - 1);\n    if ((filePathLast === CHAR_FORWARD_SLASH ||\n         (isWindows && filePathLast === CHAR_BACKWARD_SLASH)) &&\n        resolved[resolved.length - 1] !== path.sep)\n      resolved += '/';\n    outURL.pathname = encodePathChars(resolved);\n  }\n  return outURL;\n}\n\nfunction isURLInstance(fileURLOrPath) {\n  return fileURLOrPath != null && fileURLOrPath.href && fileURLOrPath.origin;\n}\n\nfunction toPathIfFileURL(fileURLOrPath) {\n  if (!isURLInstance(fileURLOrPath))\n    return fileURLOrPath;\n  return fileURLToPath(fileURLOrPath);\n}\n\nfunction constructUrl(flags, protocol, username, password,\n                      host, port, path, query, fragment) {\n  const ctx = new URLContext();\n  ctx.flags = flags;\n  ctx.scheme = protocol;\n  ctx.username = (flags & URL_FLAGS_HAS_USERNAME) !== 0 ? username : '';\n  ctx.password = (flags & URL_FLAGS_HAS_PASSWORD) !== 0 ? password : '';\n  ctx.port = port;\n  ctx.path = (flags & URL_FLAGS_HAS_PATH) !== 0 ? path : [];\n  ctx.query = query;\n  ctx.fragment = fragment;\n  ctx.host = host;\n\n  const url = ObjectCreate(URL.prototype);\n  url[context] = ctx;\n  const params = new URLSearchParams();\n  url[searchParams] = params;\n  params[context] = url;\n  initSearchParams(params, query);\n  return url;\n}\nsetURLConstructor(constructUrl);\n\nmodule.exports = {\n  toUSVString,\n  fileURLToPath,\n  pathToFileURL,\n  toPathIfFileURL,\n  isURLInstance,\n  URL,\n  URLSearchParams,\n  domainToASCII,\n  domainToUnicode,\n  urlToOptions,\n  formatSymbol: kFormat,\n  searchParamsSymbol: searchParams,\n  encodeStr\n};\n"
  },
  {
    "url": "internal/util.js",
    "ranges": [
      {
        "start": 0,
        "end": 975
      },
      {
        "start": 1044,
        "end": 1046
      },
      {
        "start": 1296,
        "end": 1816
      },
      {
        "start": 2290,
        "end": 2680
      },
      {
        "start": 3019,
        "end": 3021
      },
      {
        "start": 3095,
        "end": 3274
      },
      {
        "start": 3405,
        "end": 3407
      },
      {
        "start": 4987,
        "end": 4989
      },
      {
        "start": 5277,
        "end": 5279
      },
      {
        "start": 5587,
        "end": 5589
      },
      {
        "start": 5732,
        "end": 5997
      },
      {
        "start": 6362,
        "end": 6391
      },
      {
        "start": 6669,
        "end": 6671
      },
      {
        "start": 6978,
        "end": 6980
      },
      {
        "start": 7326,
        "end": 7328
      },
      {
        "start": 7457,
        "end": 8305
      },
      {
        "start": 8786,
        "end": 9168
      },
      {
        "start": 9490,
        "end": 9631
      },
      {
        "start": 9758,
        "end": 9840
      },
      {
        "start": 11012,
        "end": 11014
      },
      {
        "start": 11172,
        "end": 11195
      },
      {
        "start": 11410,
        "end": 12301
      }
    ],
    "text": "'use strict';\n\nconst {\n  ArrayFrom,\n  ArrayIsArray,\n  Error,\n  Map,\n  ObjectCreate,\n  ObjectDefineProperties,\n  ObjectDefineProperty,\n  ObjectGetOwnPropertyDescriptor,\n  ObjectGetOwnPropertyDescriptors,\n  ObjectGetPrototypeOf,\n  ObjectSetPrototypeOf,\n  Promise,\n  ReflectConstruct,\n  Set,\n  Symbol,\n  SymbolFor,\n} = primordials;\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_NO_CRYPTO,\n    ERR_UNKNOWN_SIGNAL\n  },\n  uvErrmapGet,\n  overrideStackTrace,\n} = require('internal/errors');\nconst { signals } = internalBinding('constants').os;\nconst {\n  getHiddenValue,\n  setHiddenValue,\n  arrow_message_private_symbol: kArrowMessagePrivateSymbolIndex,\n  decorated_private_symbol: kDecoratedPrivateSymbolIndex,\n  sleep: _sleep\n} = internalBinding('util');\nconst { isNativeError } = internalBinding('types');\n\nconst noCrypto = !process.versions.openssl;\n\nconst experimentalWarnings = new Set();\n\nconst colorRegExp = /\\u001b\\[\\d\\d?m/g; // eslint-disable-line no-control-regex\n\nfunction removeColors(str) {\n  return str.replace(colorRegExp, '');\n}\n\nfunction isError(e) {\n  // An error could be an instance of Error while not being a native error\n  // or could be from a different realm and not be instance of Error but still\n  // be a native error.\n  return isNativeError(e) || e instanceof Error;\n}\n\n// Keep a list of deprecation codes that have been warned on so we only warn on\n// each one once.\nconst codesWarned = new Set();\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nfunction deprecate(fn, msg, code) {\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  if (code !== undefined && typeof code !== 'string')\n    throw new ERR_INVALID_ARG_TYPE('code', 'string', code);\n\n  let warned = false;\n  function deprecated(...args) {\n    if (!warned) {\n      warned = true;\n      if (code !== undefined) {\n        if (!codesWarned.has(code)) {\n          process.emitWarning(msg, 'DeprecationWarning', code, deprecated);\n          codesWarned.add(code);\n        }\n      } else {\n        process.emitWarning(msg, 'DeprecationWarning', deprecated);\n      }\n    }\n    if (new.target) {\n      return ReflectConstruct(fn, args, new.target);\n    }\n    return fn.apply(this, args);\n  }\n\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\n  ObjectSetPrototypeOf(deprecated, fn);\n  if (fn.prototype) {\n    // Setting this (rather than using Object.setPrototype, as above) ensures\n    // that calling the unwrapped constructor gives an instanceof the wrapped\n    // constructor.\n    deprecated.prototype = fn.prototype;\n  }\n\n  return deprecated;\n}\n\nfunction decorateErrorStack(err) {\n  if (!(isError(err) && err.stack) ||\n      getHiddenValue(err, kDecoratedPrivateSymbolIndex) === true)\n    return;\n\n  const arrow = getHiddenValue(err, kArrowMessagePrivateSymbolIndex);\n\n  if (arrow) {\n    err.stack = arrow + err.stack;\n    setHiddenValue(err, kDecoratedPrivateSymbolIndex, true);\n  }\n}\n\nfunction assertCrypto() {\n  if (noCrypto)\n    throw new ERR_NO_CRYPTO();\n}\n\n// Return undefined if there is no match.\n// Move the \"slow cases\" to a separate function to make sure this function gets\n// inlined properly. That prioritizes the common case.\nfunction normalizeEncoding(enc) {\n  if (enc == null || enc === 'utf8' || enc === 'utf-8') return 'utf8';\n  return slowCases(enc);\n}\n\nfunction slowCases(enc) {\n  switch (enc.length) {\n    case 4:\n      if (enc === 'UTF8') return 'utf8';\n      if (enc === 'ucs2' || enc === 'UCS2') return 'utf16le';\n      enc = `${enc}`.toLowerCase();\n      if (enc === 'utf8') return 'utf8';\n      if (enc === 'ucs2') return 'utf16le';\n      break;\n    case 3:\n      if (enc === 'hex' || enc === 'HEX' || `${enc}`.toLowerCase() === 'hex')\n        return 'hex';\n      break;\n    case 5:\n      if (enc === 'ascii') return 'ascii';\n      if (enc === 'ucs-2') return 'utf16le';\n      if (enc === 'UTF-8') return 'utf8';\n      if (enc === 'ASCII') return 'ascii';\n      if (enc === 'UCS-2') return 'utf16le';\n      enc = `${enc}`.toLowerCase();\n      if (enc === 'utf-8') return 'utf8';\n      if (enc === 'ascii') return 'ascii';\n      if (enc === 'ucs-2') return 'utf16le';\n      break;\n    case 6:\n      if (enc === 'base64') return 'base64';\n      if (enc === 'latin1' || enc === 'binary') return 'latin1';\n      if (enc === 'BASE64') return 'base64';\n      if (enc === 'LATIN1' || enc === 'BINARY') return 'latin1';\n      enc = `${enc}`.toLowerCase();\n      if (enc === 'base64') return 'base64';\n      if (enc === 'latin1' || enc === 'binary') return 'latin1';\n      break;\n    case 7:\n      if (enc === 'utf16le' || enc === 'UTF16LE' ||\n        `${enc}`.toLowerCase() === 'utf16le')\n        return 'utf16le';\n      break;\n    case 8:\n      if (enc === 'utf-16le' || enc === 'UTF-16LE' ||\n        `${enc}`.toLowerCase() === 'utf-16le')\n        return 'utf16le';\n      break;\n    default:\n      if (enc === '') return 'utf8';\n  }\n}\n\nfunction emitExperimentalWarning(feature) {\n  if (experimentalWarnings.has(feature)) return;\n  const msg = `${feature} is an experimental feature. This feature could ` +\n       'change at any time';\n  experimentalWarnings.add(feature);\n  process.emitWarning(msg, 'ExperimentalWarning');\n}\n\nfunction filterDuplicateStrings(items, low) {\n  const map = new Map();\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i];\n    const key = item.toLowerCase();\n    if (low) {\n      map.set(key, key);\n    } else {\n      map.set(key, item);\n    }\n  }\n  return ArrayFrom(map.values()).sort();\n}\n\nfunction cachedResult(fn) {\n  let result;\n  return () => {\n    if (result === undefined)\n      result = fn();\n    return result.slice();\n  };\n}\n\n// Useful for Wrapping an ES6 Class with a constructor Function that\n// does not require the new keyword. For instance:\n//   class A { constructor(x) {this.x = x;}}\n//   const B = createClassWrapper(A);\n//   B() instanceof A // true\n//   B() instanceof B // true\nfunction createClassWrapper(type) {\n  function fn(...args) {\n    return ReflectConstruct(type, args, new.target || type);\n  }\n  // Mask the wrapper function name and length values\n  ObjectDefineProperties(fn, {\n    name: { value: type.name },\n    length: { value: type.length }\n  });\n  ObjectSetPrototypeOf(fn, type);\n  fn.prototype = type.prototype;\n  return fn;\n}\n\nlet signalsToNamesMapping;\nfunction getSignalsToNamesMapping() {\n  if (signalsToNamesMapping !== undefined)\n    return signalsToNamesMapping;\n\n  signalsToNamesMapping = ObjectCreate(null);\n  for (const key in signals) {\n    signalsToNamesMapping[signals[key]] = key;\n  }\n\n  return signalsToNamesMapping;\n}\n\nfunction convertToValidSignal(signal) {\n  if (typeof signal === 'number' && getSignalsToNamesMapping()[signal])\n    return signal;\n\n  if (typeof signal === 'string') {\n    const signalName = signals[signal.toUpperCase()];\n    if (signalName) return signalName;\n  }\n\n  throw new ERR_UNKNOWN_SIGNAL(signal);\n}\n\nfunction getConstructorOf(obj) {\n  while (obj) {\n    const descriptor = ObjectGetOwnPropertyDescriptor(obj, 'constructor');\n    if (descriptor !== undefined &&\n        typeof descriptor.value === 'function' &&\n        descriptor.value.name !== '') {\n      return descriptor.value;\n    }\n\n    obj = ObjectGetPrototypeOf(obj);\n  }\n\n  return null;\n}\n\nfunction getSystemErrorName(err) {\n  const entry = uvErrmapGet(err);\n  return entry ? entry[0] : `Unknown system error ${err}`;\n}\n\nconst kCustomPromisifiedSymbol = SymbolFor('nodejs.util.promisify.custom');\nconst kCustomPromisifyArgsSymbol = Symbol('customPromisifyArgs');\n\nfunction promisify(original) {\n  if (typeof original !== 'function')\n    throw new ERR_INVALID_ARG_TYPE('original', 'Function', original);\n\n  if (original[kCustomPromisifiedSymbol]) {\n    const fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE('util.promisify.custom', 'Function', fn);\n    }\n    return ObjectDefineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n  }\n\n  // Names to create an object from in case the callback receives multiple\n  // arguments, e.g. ['bytesRead', 'buffer'] for fs.read.\n  const argumentNames = original[kCustomPromisifyArgsSymbol];\n\n  function fn(...args) {\n    return new Promise((resolve, reject) => {\n      original.call(this, ...args, (err, ...values) => {\n        if (err) {\n          return reject(err);\n        }\n        if (argumentNames !== undefined && values.length > 1) {\n          const obj = {};\n          for (let i = 0; i < argumentNames.length; i++)\n            obj[argumentNames[i]] = values[i];\n          resolve(obj);\n        } else {\n          resolve(values[0]);\n        }\n      });\n    });\n  }\n\n  ObjectSetPrototypeOf(fn, ObjectGetPrototypeOf(original));\n\n  ObjectDefineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return ObjectDefineProperties(\n    fn,\n    ObjectGetOwnPropertyDescriptors(original)\n  );\n}\n\npromisify.custom = kCustomPromisifiedSymbol;\n\n// The build-in Array#join is slower in v8 6.0\nfunction join(output, separator) {\n  let str = '';\n  if (output.length !== 0) {\n    const lastIndex = output.length - 1;\n    for (let i = 0; i < lastIndex; i++) {\n      // It is faster not to use a template string here\n      str += output[i];\n      str += separator;\n    }\n    str += output[lastIndex];\n  }\n  return str;\n}\n\n// As of V8 6.6, depending on the size of the array, this is anywhere\n// between 1.5-10x faster than the two-arg version of Array#splice()\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nconst kNodeModulesRE = /^(.*)[\\\\/]node_modules[\\\\/]/;\n\nlet getStructuredStack;\n\nfunction isInsideNodeModules() {\n  if (getStructuredStack === undefined) {\n    // Lazy-load to avoid a circular dependency.\n    const { runInNewContext } = require('vm');\n    // Use `runInNewContext()` to get something tamper-proof and\n    // side-effect-free. Since this is currently only used for a deprecated API,\n    // the perf implications should be okay.\n    getStructuredStack = runInNewContext(`(function() {\n      Error.stackTraceLimit = Infinity;\n      return function structuredStack() {\n        const e = new Error();\n        overrideStackTrace.set(e, (err, trace) => trace);\n        return e.stack;\n      };\n    })()`, { overrideStackTrace }, { filename: 'structured-stack' });\n  }\n\n  const stack = getStructuredStack();\n\n  // Iterate over all stack frames and look for the first one not coming\n  // from inside Node.js itself:\n  if (ArrayIsArray(stack)) {\n    for (const frame of stack) {\n      const filename = frame.getFileName();\n      // If a filename does not start with / or contain \\,\n      // it's likely from Node.js core.\n      if (!/^\\/|\\\\/.test(filename))\n        continue;\n      return kNodeModulesRE.test(filename);\n    }\n  }\n  return false;\n}\n\nfunction once(callback) {\n  let called = false;\n  return function(...args) {\n    if (called) return;\n    called = true;\n    callback.apply(this, args);\n  };\n}\n\nlet validateUint32;\n\nfunction sleep(msec) {\n  // Lazy-load to avoid a circular dependency.\n  if (validateUint32 === undefined)\n    ({ validateUint32 } = require('internal/validators'));\n\n  validateUint32(msec, 'msec');\n  _sleep(msec);\n}\n\nmodule.exports = {\n  assertCrypto,\n  cachedResult,\n  convertToValidSignal,\n  createClassWrapper,\n  decorateErrorStack,\n  deprecate,\n  emitExperimentalWarning,\n  filterDuplicateStrings,\n  getConstructorOf,\n  getSystemErrorName,\n  isError,\n  isInsideNodeModules,\n  join,\n  normalizeEncoding,\n  once,\n  promisify,\n  sleep,\n  spliceOne,\n  removeColors,\n\n  // Symbol used to customize promisify conversion\n  customPromisifyArgs: kCustomPromisifyArgsSymbol,\n\n  // Symbol used to provide a custom inspect function for an object as an\n  // alternative to using 'inspect'\n  customInspectSymbol: SymbolFor('nodejs.util.inspect.custom'),\n\n  // Used by the buffer module to capture an internal reference to the\n  // default isEncoding implementation, just in case userland overrides it.\n  kIsEncodingSymbol: Symbol('kIsEncodingSymbol'),\n  kVmBreakFirstLineSymbol: Symbol('kVmBreakFirstLineSymbol')\n};\n"
  },
  {
    "url": "internal/util/debuglog.js",
    "ranges": [
      {
        "start": 0,
        "end": 947
      },
      {
        "start": 1272,
        "end": 1477
      },
      {
        "start": 1777,
        "end": 2488
      },
      {
        "start": 2557,
        "end": 2653
      },
      {
        "start": 2687,
        "end": 2815
      }
    ],
    "text": "'use strict';\n\nconst {\n  FunctionPrototypeBind,\n  ObjectCreate,\n  ObjectDefineProperty,\n  RegExp,\n  RegExpPrototypeTest,\n  StringPrototypeToUpperCase\n} = primordials;\n\nconst { inspect, format, formatWithOptions } = require('internal/util/inspect');\n\n// `debugs` is deliberately initialized to undefined so any call to\n// debuglog() before initializeDebugEnv() is called will throw.\nlet debugImpls;\n\nlet debugEnvRegex = /^$/;\nlet testEnabled;\n\n// `debugEnv` is initial value of process.env.NODE_DEBUG\nfunction initializeDebugEnv(debugEnv) {\n  debugImpls = ObjectCreate(null);\n  if (debugEnv) {\n    debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+?.]/g, '\\\\$&')\n      .replace(/\\*/g, '.*')\n      .replace(/,/g, '$|^')\n      .toUpperCase();\n    debugEnvRegex = new RegExp(`^${debugEnv}$`, 'i');\n  }\n  testEnabled = FunctionPrototypeBind(RegExpPrototypeTest, null, debugEnvRegex);\n}\n\n// Emits warning when user sets\n// NODE_DEBUG=http or NODE_DEBUG=http2.\nfunction emitWarningIfNeeded(set) {\n  if ('HTTP' === set || 'HTTP2' === set) {\n    process.emitWarning('Setting the NODE_DEBUG environment variable ' +\n      'to \\'' + set.toLowerCase() + '\\' can expose sensitive ' +\n      'data (such as passwords, tokens and authentication headers) ' +\n      'in the resulting log.');\n  }\n}\n\nfunction noop() {}\n\nfunction debuglogImpl(enabled, set) {\n  if (debugImpls[set] === undefined) {\n    if (enabled) {\n      const pid = process.pid;\n      emitWarningIfNeeded(set);\n      debugImpls[set] = function debug(...args) {\n        const colors = process.stderr.hasColors && process.stderr.hasColors();\n        const msg = formatWithOptions({ colors }, ...args);\n        const coloredPID = inspect(pid, { colors });\n        process.stderr.write(format('%s %s: %s\\n', set, coloredPID, msg));\n      };\n    } else {\n      debugImpls[set] = noop;\n    }\n  }\n  return debugImpls[set];\n}\n\n// debuglogImpl depends on process.pid and process.env.NODE_DEBUG,\n// so it needs to be called lazily in top scopes of internal modules\n// that may be loaded before these run time states are allowed to\n// be accessed.\nfunction debuglog(set, cb) {\n  function init() {\n    set = StringPrototypeToUpperCase(set);\n    enabled = testEnabled(set);\n  }\n  let debug = (...args) => {\n    init();\n    // Only invokes debuglogImpl() when the debug function is\n    // called for the first time.\n    debug = debuglogImpl(enabled, set);\n    if (typeof cb === 'function')\n      cb(debug);\n    debug(...args);\n  };\n  let enabled;\n  let test = () => {\n    init();\n    test = () => enabled;\n    return enabled;\n  };\n  const logger = (...args) => debug(...args);\n  ObjectDefineProperty(logger, 'enabled', {\n    get() {\n      return test();\n    },\n    configurable: true,\n    enumerable: true\n  });\n  return logger;\n}\n\nmodule.exports = {\n  debuglog,\n  initializeDebugEnv\n};\n"
  },
  {
    "url": "internal/util/inspect.js",
    "ranges": [
      {
        "start": 0,
        "end": 3020
      },
      {
        "start": 3070,
        "end": 6215
      },
      {
        "start": 7666,
        "end": 7961
      },
      {
        "start": 9878,
        "end": 9970
      },
      {
        "start": 10015,
        "end": 10019
      },
      {
        "start": 10227,
        "end": 12059
      },
      {
        "start": 12099,
        "end": 12105
      },
      {
        "start": 12151,
        "end": 13216
      },
      {
        "start": 13374,
        "end": 13393
      },
      {
        "start": 13425,
        "end": 13538
      },
      {
        "start": 15164,
        "end": 15166
      },
      {
        "start": 15432,
        "end": 15434
      },
      {
        "start": 15480,
        "end": 15559
      },
      {
        "start": 15606,
        "end": 15608
      },
      {
        "start": 15726,
        "end": 15728
      },
      {
        "start": 16988,
        "end": 17175
      },
      {
        "start": 19018,
        "end": 19020
      },
      {
        "start": 19407,
        "end": 19444
      },
      {
        "start": 20386,
        "end": 20388
      },
      {
        "start": 20651,
        "end": 20653
      },
      {
        "start": 21102,
        "end": 21104
      },
      {
        "start": 21627,
        "end": 21809
      },
      {
        "start": 24348,
        "end": 24350
      },
      {
        "start": 34825,
        "end": 34827
      },
      {
        "start": 35009,
        "end": 35011
      },
      {
        "start": 36185,
        "end": 36187
      },
      {
        "start": 36787,
        "end": 36789
      },
      {
        "start": 37882,
        "end": 37884
      },
      {
        "start": 41005,
        "end": 41007
      },
      {
        "start": 45258,
        "end": 45260
      },
      {
        "start": 45612,
        "end": 45614
      },
      {
        "start": 45791,
        "end": 45793
      },
      {
        "start": 45865,
        "end": 45867
      },
      {
        "start": 47050,
        "end": 47052
      },
      {
        "start": 48200,
        "end": 48247
      },
      {
        "start": 49454,
        "end": 49456
      },
      {
        "start": 50056,
        "end": 50058
      },
      {
        "start": 50652,
        "end": 50654
      },
      {
        "start": 51670,
        "end": 51672
      },
      {
        "start": 51904,
        "end": 51906
      },
      {
        "start": 52204,
        "end": 52206
      },
      {
        "start": 53019,
        "end": 53021
      },
      {
        "start": 54343,
        "end": 54345
      },
      {
        "start": 54437,
        "end": 54439
      },
      {
        "start": 54596,
        "end": 54598
      },
      {
        "start": 54755,
        "end": 54757
      },
      {
        "start": 55148,
        "end": 55150
      },
      {
        "start": 55615,
        "end": 55617
      },
      {
        "start": 57951,
        "end": 57953
      },
      {
        "start": 58895,
        "end": 58897
      },
      {
        "start": 61647,
        "end": 61649
      },
      {
        "start": 62668,
        "end": 62693
      },
      {
        "start": 62732,
        "end": 62762
      },
      {
        "start": 63231,
        "end": 63233
      },
      {
        "start": 63317,
        "end": 63319
      },
      {
        "start": 63597,
        "end": 63599
      },
      {
        "start": 67383,
        "end": 67812
      },
      {
        "start": 68363,
        "end": 68478
      },
      {
        "start": 68890,
        "end": 69058
      },
      {
        "start": 70667,
        "end": 70701
      },
      {
        "start": 71269,
        "end": 71359
      },
      {
        "start": 71433,
        "end": 71569
      }
    ],
    "text": "'use strict';\n\nconst {\n  Array,\n  ArrayIsArray,\n  BigInt64Array,\n  BigIntPrototypeValueOf,\n  BigUint64Array,\n  BooleanPrototypeValueOf,\n  DatePrototypeGetTime,\n  DatePrototypeToISOString,\n  DatePrototypeToString,\n  ErrorPrototypeToString,\n  Float32Array,\n  Float64Array,\n  FunctionPrototypeCall,\n  FunctionPrototypeToString,\n  Int8Array,\n  Int16Array,\n  Int32Array,\n  JSONStringify,\n  Map,\n  MapPrototype,\n  MapPrototypeEntries,\n  MathFloor,\n  MathMax,\n  MathMin,\n  MathRound,\n  MathSqrt,\n  Number,\n  NumberIsNaN,\n  NumberParseFloat,\n  NumberParseInt,\n  NumberPrototypeValueOf,\n  Object,\n  ObjectAssign,\n  ObjectCreate,\n  ObjectDefineProperty,\n  ObjectGetOwnPropertyDescriptor,\n  ObjectGetOwnPropertyNames,\n  ObjectGetOwnPropertySymbols,\n  ObjectGetPrototypeOf,\n  ObjectIs,\n  ObjectKeys,\n  ObjectPrototypeHasOwnProperty,\n  ObjectPrototypePropertyIsEnumerable,\n  ObjectSeal,\n  ObjectSetPrototypeOf,\n  ReflectApply,\n  RegExp,\n  RegExpPrototypeToString,\n  Set,\n  SetPrototype,\n  SetPrototypeValues,\n  String,\n  StringPrototypeValueOf,\n  SymbolPrototypeToString,\n  SymbolPrototypeValueOf,\n  SymbolIterator,\n  SymbolToStringTag,\n  Uint16Array,\n  Uint32Array,\n  Uint8Array,\n  Uint8ArrayPrototype,\n  Uint8ClampedArray,\n  uncurryThis,\n} = primordials;\n\nconst {\n  getOwnNonIndexProperties,\n  getPromiseDetails,\n  getProxyDetails,\n  kPending,\n  kRejected,\n  previewEntries,\n  getConstructorName: internalGetConstructorName,\n  getExternalValue,\n  propertyFilter: {\n    ALL_PROPERTIES,\n    ONLY_ENUMERABLE\n  }\n} = internalBinding('util');\n\nconst {\n  customInspectSymbol,\n  isError,\n  join,\n  removeColors\n} = require('internal/util');\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\n  },\n  isStackOverflowError\n} = require('internal/errors');\n\nconst {\n  isAsyncFunction,\n  isGeneratorFunction,\n  isAnyArrayBuffer,\n  isArrayBuffer,\n  isArgumentsObject,\n  isBoxedPrimitive,\n  isDataView,\n  isExternal,\n  isMap,\n  isMapIterator,\n  isModuleNamespaceObject,\n  isNativeError,\n  isPromise,\n  isSet,\n  isSetIterator,\n  isWeakMap,\n  isWeakSet,\n  isRegExp,\n  isDate,\n  isTypedArray,\n  isStringObject,\n  isNumberObject,\n  isBooleanObject,\n  isBigIntObject,\n  isUint8Array,\n  isUint8ClampedArray,\n  isUint16Array,\n  isUint32Array,\n  isInt8Array,\n  isInt16Array,\n  isInt32Array,\n  isFloat32Array,\n  isFloat64Array,\n  isBigInt64Array,\n  isBigUint64Array\n} = require('internal/util/types');\n\nconst assert = require('internal/assert');\n\nconst { NativeModule } = require('internal/bootstrap/loaders');\n\nconst setSizeGetter = uncurryThis(\n  ObjectGetOwnPropertyDescriptor(SetPrototype, 'size').get);\nconst mapSizeGetter = uncurryThis(\n  ObjectGetOwnPropertyDescriptor(MapPrototype, 'size').get);\nconst typedArraySizeGetter = uncurryThis(\n  ObjectGetOwnPropertyDescriptor(\n    ObjectGetPrototypeOf(Uint8ArrayPrototype), 'length').get);\n\nlet hexSlice;\n\nconst builtInObjects = new Set(\n  ObjectGetOwnPropertyNames(global).filter((e) => /^[A-Z][a-zA-Z0-9]+$/.test(e))\n);\n\n// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\nconst isUndetectableObject = (v) => typeof v === 'undefined' && v !== undefined;\n\n// These options must stay in sync with `getUserOptions`. So if any option will\n// be added or removed, `getUserOptions` must also be updated accordingly.\nconst inspectDefaultOptions = ObjectSeal({\n  showHidden: false,\n  depth: 2,\n  colors: false,\n  customInspect: true,\n  showProxy: false,\n  maxArrayLength: 100,\n  maxStringLength: Infinity,\n  breakLength: 80,\n  compact: 3,\n  sorted: false,\n  getters: false\n});\n\nconst kObjectType = 0;\nconst kArrayType = 1;\nconst kArrayExtrasType = 2;\n\n/* eslint-disable no-control-regex */\nconst strEscapeSequencesRegExp = /[\\x00-\\x1f\\x27\\x5c\\x7f-\\x9f]/;\nconst strEscapeSequencesReplacer = /[\\x00-\\x1f\\x27\\x5c\\x7f-\\x9f]/g;\nconst strEscapeSequencesRegExpSingle = /[\\x00-\\x1f\\x5c\\x7f-\\x9f]/;\nconst strEscapeSequencesReplacerSingle = /[\\x00-\\x1f\\x5c\\x7f-\\x9f]/g;\n/* eslint-enable no-control-regex */\n\nconst keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;\nconst numberRegExp = /^(0|[1-9][0-9]*)$/;\n\nconst coreModuleRegExp = /^    at (?:[^/\\\\(]+ \\(|)((?<![/\\\\]).+)\\.js:\\d+:\\d+\\)?$/;\nconst nodeModulesRegExp = /[/\\\\]node_modules[/\\\\](.+?)(?=[/\\\\])/g;\n\nconst classRegExp = /^(\\s+[^(]*?)\\s*{/;\n// eslint-disable-next-line node-core/no-unescaped-regexp-dot\nconst stripCommentsRegExp = /(\\/\\/.*?\\n)|(\\/\\*(.|\\n)*?\\*\\/)/g;\n\nconst kMinLineLength = 16;\n\n// Constants to map the iterator state.\nconst kWeak = 0;\nconst kIterator = 1;\nconst kMapEntries = 2;\n\n// Escaped control characters (plus the single quote and the backslash). Use\n// empty strings to fill up unused entries.\nconst meta = [\n  '\\\\x00', '\\\\x01', '\\\\x02', '\\\\x03', '\\\\x04', '\\\\x05', '\\\\x06', '\\\\x07', // x07\n  '\\\\b', '\\\\t', '\\\\n', '\\\\x0B', '\\\\f', '\\\\r', '\\\\x0E', '\\\\x0F',           // x0F\n  '\\\\x10', '\\\\x11', '\\\\x12', '\\\\x13', '\\\\x14', '\\\\x15', '\\\\x16', '\\\\x17', // x17\n  '\\\\x18', '\\\\x19', '\\\\x1A', '\\\\x1B', '\\\\x1C', '\\\\x1D', '\\\\x1E', '\\\\x1F', // x1F\n  '', '', '', '', '', '', '', \"\\\\'\", '', '', '', '', '', '', '', '',      // x2F\n  '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',         // x3F\n  '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',         // x4F\n  '', '', '', '', '', '', '', '', '', '', '', '', '\\\\\\\\', '', '', '',     // x5F\n  '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',         // x6F\n  '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '\\\\x7F',    // x7F\n  '\\\\x80', '\\\\x81', '\\\\x82', '\\\\x83', '\\\\x84', '\\\\x85', '\\\\x86', '\\\\x87', // x87\n  '\\\\x88', '\\\\x89', '\\\\x8A', '\\\\x8B', '\\\\x8C', '\\\\x8D', '\\\\x8E', '\\\\x8F', // x8F\n  '\\\\x90', '\\\\x91', '\\\\x92', '\\\\x93', '\\\\x94', '\\\\x95', '\\\\x96', '\\\\x97', // x97\n  '\\\\x98', '\\\\x99', '\\\\x9A', '\\\\x9B', '\\\\x9C', '\\\\x9D', '\\\\x9E', '\\\\x9F', // x9F\n];\n\n// Regex used for ansi escape code splitting\n// Adopted from https://github.com/chalk/ansi-regex/blob/master/index.js\n// License: MIT, authors: @sindresorhus, Qix-, arjunmehta and LitoMore\n// Matches all ansi escape code sequences in a string\nconst ansiPattern = '[\\\\u001B\\\\u009B][[\\\\]()#;?]*' +\n  '(?:(?:(?:[a-zA-Z\\\\d]*(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)' +\n  '|(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))';\nconst ansi = new RegExp(ansiPattern, 'g');\n\nlet getStringWidth;\n\nfunction getUserOptions(ctx, isCrossContext) {\n  const ret = {\n    stylize: ctx.stylize,\n    showHidden: ctx.showHidden,\n    depth: ctx.depth,\n    colors: ctx.colors,\n    customInspect: ctx.customInspect,\n    showProxy: ctx.showProxy,\n    maxArrayLength: ctx.maxArrayLength,\n    maxStringLength: ctx.maxStringLength,\n    breakLength: ctx.breakLength,\n    compact: ctx.compact,\n    sorted: ctx.sorted,\n    getters: ctx.getters,\n    ...ctx.userOptions\n  };\n\n  // Typically, the target value will be an instance of `Object`. If that is\n  // *not* the case, the object may come from another vm.Context, and we want\n  // to avoid passing it objects from this Context in that case, so we remove\n  // the prototype from the returned object itself + the `stylize()` function,\n  // and remove all other non-primitives, including non-primitive user options.\n  if (isCrossContext) {\n    ObjectSetPrototypeOf(ret, null);\n    for (const key of ObjectKeys(ret)) {\n      if ((typeof ret[key] === 'object' || typeof ret[key] === 'function') &&\n          ret[key] !== null) {\n        delete ret[key];\n      }\n    }\n    ret.stylize = ObjectSetPrototypeOf((value, flavour) => {\n      let stylized;\n      try {\n        stylized = `${ctx.stylize(value, flavour)}`;\n      } catch {}\n\n      if (typeof stylized !== 'string') return value;\n      // `stylized` is a string as it should be, which is safe to pass along.\n      return stylized;\n    }, null);\n  }\n\n  return ret;\n}\n\n/**\n * Echos the value of any input. Tries to print the value out\n * in the best way possible given the different types.\n *\n * @param {any} value The value to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* Legacy: value, showHidden, depth, colors */\nfunction inspect(value, opts) {\n  // Default options\n  const ctx = {\n    budget: {},\n    indentationLvl: 0,\n    seen: [],\n    currentDepth: 0,\n    stylize: stylizeNoColor,\n    showHidden: inspectDefaultOptions.showHidden,\n    depth: inspectDefaultOptions.depth,\n    colors: inspectDefaultOptions.colors,\n    customInspect: inspectDefaultOptions.customInspect,\n    showProxy: inspectDefaultOptions.showProxy,\n    maxArrayLength: inspectDefaultOptions.maxArrayLength,\n    maxStringLength: inspectDefaultOptions.maxStringLength,\n    breakLength: inspectDefaultOptions.breakLength,\n    compact: inspectDefaultOptions.compact,\n    sorted: inspectDefaultOptions.sorted,\n    getters: inspectDefaultOptions.getters\n  };\n  if (arguments.length > 1) {\n    // Legacy...\n    if (arguments.length > 2) {\n      if (arguments[2] !== undefined) {\n        ctx.depth = arguments[2];\n      }\n      if (arguments.length > 3 && arguments[3] !== undefined) {\n        ctx.colors = arguments[3];\n      }\n    }\n    // Set user-specified options\n    if (typeof opts === 'boolean') {\n      ctx.showHidden = opts;\n    } else if (opts) {\n      const optKeys = ObjectKeys(opts);\n      for (const key of optKeys) {\n        // TODO(BridgeAR): Find a solution what to do about stylize. Either make\n        // this function public or add a new API with a similar or better\n        // functionality.\n        if (\n          ObjectPrototypeHasOwnProperty(inspectDefaultOptions, key) ||\n          key === 'stylize') {\n          ctx[key] = opts[key];\n        } else if (ctx.userOptions === undefined) {\n          // This is required to pass through the actual user input.\n          ctx.userOptions = opts;\n        }\n      }\n    }\n  }\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  if (ctx.maxArrayLength === null) ctx.maxArrayLength = Infinity;\n  if (ctx.maxStringLength === null) ctx.maxStringLength = Infinity;\n  return formatValue(ctx, value, 0);\n}\ninspect.custom = customInspectSymbol;\n\nObjectDefineProperty(inspect, 'defaultOptions', {\n  get() {\n    return inspectDefaultOptions;\n  },\n  set(options) {\n    if (options === null || typeof options !== 'object') {\n      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);\n    }\n    return ObjectAssign(inspectDefaultOptions, options);\n  }\n});\n\n// Set Graphics Rendition https://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n// Each color consists of an array with the color code as first entry and the\n// reset code as second entry.\nconst defaultFG = 39;\nconst defaultBG = 49;\ninspect.colors = ObjectAssign(ObjectCreate(null), {\n  reset: [0, 0],\n  bold: [1, 22],\n  dim: [2, 22], // Alias: faint\n  italic: [3, 23],\n  underline: [4, 24],\n  blink: [5, 25],\n  // Swap forground and background colors\n  inverse: [7, 27], // Alias: swapcolors, swapColors\n  hidden: [8, 28], // Alias: conceal\n  strikethrough: [9, 29], // Alias: strikeThrough, crossedout, crossedOut\n  doubleunderline: [21, 24], // Alias: doubleUnderline\n  black: [30, defaultFG],\n  red: [31, defaultFG],\n  green: [32, defaultFG],\n  yellow: [33, defaultFG],\n  blue: [34, defaultFG],\n  magenta: [35, defaultFG],\n  cyan: [36, defaultFG],\n  white: [37, defaultFG],\n  bgBlack: [40, defaultBG],\n  bgRed: [41, defaultBG],\n  bgGreen: [42, defaultBG],\n  bgYellow: [43, defaultBG],\n  bgBlue: [44, defaultBG],\n  bgMagenta: [45, defaultBG],\n  bgCyan: [46, defaultBG],\n  bgWhite: [47, defaultBG],\n  framed: [51, 54],\n  overlined: [53, 55],\n  gray: [90, defaultFG], // Alias: grey, blackBright\n  redBright: [91, defaultFG],\n  greenBright: [92, defaultFG],\n  yellowBright: [93, defaultFG],\n  blueBright: [94, defaultFG],\n  magentaBright: [95, defaultFG],\n  cyanBright: [96, defaultFG],\n  whiteBright: [97, defaultFG],\n  bgGray: [100, defaultBG], // Alias: bgGrey, bgBlackBright\n  bgRedBright: [101, defaultBG],\n  bgGreenBright: [102, defaultBG],\n  bgYellowBright: [103, defaultBG],\n  bgBlueBright: [104, defaultBG],\n  bgMagentaBright: [105, defaultBG],\n  bgCyanBright: [106, defaultBG],\n  bgWhiteBright: [107, defaultBG],\n});\n\nfunction defineColorAlias(target, alias) {\n  ObjectDefineProperty(inspect.colors, alias, {\n    get() {\n      return this[target];\n    },\n    set(value) {\n      this[target] = value;\n    },\n    configurable: true,\n    enumerable: false\n  });\n}\n\ndefineColorAlias('gray', 'grey');\ndefineColorAlias('gray', 'blackBright');\ndefineColorAlias('bgGray', 'bgGrey');\ndefineColorAlias('bgGray', 'bgBlackBright');\ndefineColorAlias('dim', 'faint');\ndefineColorAlias('strikethrough', 'crossedout');\ndefineColorAlias('strikethrough', 'strikeThrough');\ndefineColorAlias('strikethrough', 'crossedOut');\ndefineColorAlias('hidden', 'conceal');\ndefineColorAlias('inverse', 'swapColors');\ndefineColorAlias('inverse', 'swapcolors');\ndefineColorAlias('doubleunderline', 'doubleUnderline');\n\n// TODO(BridgeAR): Add function style support for more complex styles.\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = ObjectAssign(ObjectCreate(null), {\n  special: 'cyan',\n  number: 'yellow',\n  bigint: 'yellow',\n  boolean: 'yellow',\n  undefined: 'grey',\n  null: 'bold',\n  string: 'green',\n  symbol: 'green',\n  date: 'magenta',\n  // \"name\": intentionally not styling\n  // TODO(BridgeAR): Highlight regular expressions properly.\n  regexp: 'red',\n  module: 'underline'\n});\n\nfunction addQuotes(str, quotes) {\n  if (quotes === -1) {\n    return `\"${str}\"`;\n  }\n  if (quotes === -2) {\n    return `\\`${str}\\``;\n  }\n  return `'${str}'`;\n}\n\nconst escapeFn = (str) => meta[str.charCodeAt(0)];\n\n// Escape control characters, single quotes and the backslash.\n// This is similar to JSON stringify escaping.\nfunction strEscape(str) {\n  let escapeTest = strEscapeSequencesRegExp;\n  let escapeReplace = strEscapeSequencesReplacer;\n  let singleQuote = 39;\n\n  // Check for double quotes. If not present, do not escape single quotes and\n  // instead wrap the text in double quotes. If double quotes exist, check for\n  // backticks. If they do not exist, use those as fallback instead of the\n  // double quotes.\n  if (str.includes(\"'\")) {\n    // This invalidates the charCode and therefore can not be matched for\n    // anymore.\n    if (!str.includes('\"')) {\n      singleQuote = -1;\n    } else if (!str.includes('`') && !str.includes('${')) {\n      singleQuote = -2;\n    }\n    if (singleQuote !== 39) {\n      escapeTest = strEscapeSequencesRegExpSingle;\n      escapeReplace = strEscapeSequencesReplacerSingle;\n    }\n  }\n\n  // Some magic numbers that worked out fine while benchmarking with v8 6.0\n  if (str.length < 5000 && !escapeTest.test(str))\n    return addQuotes(str, singleQuote);\n  if (str.length > 100) {\n    str = str.replace(escapeReplace, escapeFn);\n    return addQuotes(str, singleQuote);\n  }\n\n  let result = '';\n  let last = 0;\n  const lastIndex = str.length;\n  for (let i = 0; i < lastIndex; i++) {\n    const point = str.charCodeAt(i);\n    if (point === singleQuote ||\n        point === 92 ||\n        point < 32 ||\n        (point > 126 && point < 160)) {\n      if (last === i) {\n        result += meta[point];\n      } else {\n        result += `${str.slice(last, i)}${meta[point]}`;\n      }\n      last = i + 1;\n    }\n  }\n\n  if (last !== lastIndex) {\n    result += str.slice(last);\n  }\n  return addQuotes(result, singleQuote);\n}\n\nfunction stylizeWithColor(str, styleType) {\n  const style = inspect.styles[styleType];\n  if (style !== undefined) {\n    const color = inspect.colors[style];\n    if (color !== undefined)\n      return `\\u001b[${color[0]}m${str}\\u001b[${color[1]}m`;\n  }\n  return str;\n}\n\nfunction stylizeNoColor(str) {\n  return str;\n}\n\n// Return a new empty array to push in the results of the default formatter.\nfunction getEmptyFormatArray() {\n  return [];\n}\n\nfunction isInstanceof(object, proto) {\n  try {\n    return object instanceof proto;\n  } catch {\n    return false;\n  }\n}\n\nfunction getConstructorName(obj, ctx, recurseTimes, protoProps) {\n  let firstProto;\n  const tmp = obj;\n  while (obj || isUndetectableObject(obj)) {\n    const descriptor = ObjectGetOwnPropertyDescriptor(obj, 'constructor');\n    if (descriptor !== undefined &&\n        typeof descriptor.value === 'function' &&\n        descriptor.value.name !== '' &&\n        isInstanceof(tmp, descriptor.value)) {\n      if (protoProps !== undefined &&\n         (firstProto !== obj ||\n         !builtInObjects.has(descriptor.value.name))) {\n        addPrototypeProperties(\n          ctx, tmp, firstProto || tmp, recurseTimes, protoProps);\n      }\n      return descriptor.value.name;\n    }\n\n    obj = ObjectGetPrototypeOf(obj);\n    if (firstProto === undefined) {\n      firstProto = obj;\n    }\n  }\n\n  if (firstProto === null) {\n    return null;\n  }\n\n  const res = internalGetConstructorName(tmp);\n\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\n    return `${res} <Complex prototype>`;\n  }\n\n  const protoConstr = getConstructorName(\n    firstProto, ctx, recurseTimes + 1, protoProps);\n\n  if (protoConstr === null) {\n    return `${res} <${inspect(firstProto, {\n      ...ctx,\n      customInspect: false,\n      depth: -1\n    })}>`;\n  }\n\n  return `${res} <${protoConstr}>`;\n}\n\n// This function has the side effect of adding prototype properties to the\n// `output` argument (which is an array). This is intended to highlight user\n// defined prototype properties.\nfunction addPrototypeProperties(ctx, main, obj, recurseTimes, output) {\n  let depth = 0;\n  let keys;\n  let keySet;\n  do {\n    if (depth !== 0 || main === obj) {\n      obj = ObjectGetPrototypeOf(obj);\n      // Stop as soon as a null prototype is encountered.\n      if (obj === null) {\n        return;\n      }\n      // Stop as soon as a built-in object type is detected.\n      const descriptor = ObjectGetOwnPropertyDescriptor(obj, 'constructor');\n      if (descriptor !== undefined &&\n          typeof descriptor.value === 'function' &&\n          builtInObjects.has(descriptor.value.name)) {\n        return;\n      }\n    }\n\n    if (depth === 0) {\n      keySet = new Set();\n    } else {\n      keys.forEach((key) => keySet.add(key));\n    }\n    // Get all own property names and symbols.\n    keys = ObjectGetOwnPropertyNames(obj);\n    const symbols = ObjectGetOwnPropertySymbols(obj);\n    if (symbols.length !== 0) {\n      keys.push(...symbols);\n    }\n    for (const key of keys) {\n      // Ignore the `constructor` property and keys that exist on layers above.\n      if (key === 'constructor' ||\n          ObjectPrototypeHasOwnProperty(main, key) ||\n          (depth !== 0 && keySet.has(key))) {\n        continue;\n      }\n      const desc = ObjectGetOwnPropertyDescriptor(obj, key);\n      if (typeof desc.value === 'function') {\n        continue;\n      }\n      const value = formatProperty(\n        ctx, obj, recurseTimes, key, kObjectType, desc, main);\n      if (ctx.colors) {\n        // Faint!\n        output.push(`\\u001b[2m${value}\\u001b[22m`);\n      } else {\n        output.push(value);\n      }\n    }\n  // Limit the inspection to up to three prototype layers. Using `recurseTimes`\n  // is not a good choice here, because it's as if the properties are declared\n  // on the current object from the users perspective.\n  } while (++depth !== 3);\n}\n\nfunction getPrefix(constructor, tag, fallback, size = '') {\n  if (constructor === null) {\n    if (tag !== '' && fallback !== tag) {\n      return `[${fallback}${size}: null prototype] [${tag}] `;\n    }\n    return `[${fallback}${size}: null prototype] `;\n  }\n\n  if (tag !== '' && constructor !== tag) {\n    return `${constructor}${size} [${tag}] `;\n  }\n  return `${constructor}${size} `;\n}\n\n// Look up the keys of the object.\nfunction getKeys(value, showHidden) {\n  let keys;\n  const symbols = ObjectGetOwnPropertySymbols(value);\n  if (showHidden) {\n    keys = ObjectGetOwnPropertyNames(value);\n    if (symbols.length !== 0)\n      keys.push(...symbols);\n  } else {\n    // This might throw if `value` is a Module Namespace Object from an\n    // unevaluated module, but we don't want to perform the actual type\n    // check because it's expensive.\n    // TODO(devsnek): track https://github.com/tc39/ecma262/issues/1209\n    // and modify this logic as needed.\n    try {\n      keys = ObjectKeys(value);\n    } catch (err) {\n      assert(isNativeError(err) && err.name === 'ReferenceError' &&\n             isModuleNamespaceObject(value));\n      keys = ObjectGetOwnPropertyNames(value);\n    }\n    if (symbols.length !== 0) {\n      const filter = (key) => ObjectPrototypePropertyIsEnumerable(value, key);\n      keys.push(...symbols.filter(filter));\n    }\n  }\n  return keys;\n}\n\nfunction getCtxStyle(value, constructor, tag) {\n  let fallback = '';\n  if (constructor === null) {\n    fallback = internalGetConstructorName(value);\n    if (fallback === tag) {\n      fallback = 'Object';\n    }\n  }\n  return getPrefix(constructor, tag, fallback);\n}\n\nfunction formatProxy(ctx, proxy, recurseTimes) {\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\n    return ctx.stylize('Proxy [Array]', 'special');\n  }\n  recurseTimes += 1;\n  ctx.indentationLvl += 2;\n  const res = [\n    formatValue(ctx, proxy[0], recurseTimes),\n    formatValue(ctx, proxy[1], recurseTimes)\n  ];\n  ctx.indentationLvl -= 2;\n  return reduceToSingleString(\n    ctx, res, '', ['Proxy [', ']'], kArrayExtrasType, recurseTimes);\n}\n\nfunction findTypedConstructor(value) {\n  for (const [check, clazz] of [\n    [isUint8Array, Uint8Array],\n    [isUint8ClampedArray, Uint8ClampedArray],\n    [isUint16Array, Uint16Array],\n    [isUint32Array, Uint32Array],\n    [isInt8Array, Int8Array],\n    [isInt16Array, Int16Array],\n    [isInt32Array, Int32Array],\n    [isFloat32Array, Float32Array],\n    [isFloat64Array, Float64Array],\n    [isBigInt64Array, BigInt64Array],\n    [isBigUint64Array, BigUint64Array]\n  ]) {\n    if (check(value)) {\n      return clazz;\n    }\n  }\n}\n\n// Note: using `formatValue` directly requires the indentation level to be\n// corrected by setting `ctx.indentationLvL += diff` and then to decrease the\n// value afterwards again.\nfunction formatValue(ctx, value, recurseTimes, typedArray) {\n  // Primitive types cannot have properties.\n  if (typeof value !== 'object' &&\n      typeof value !== 'function' &&\n      !isUndetectableObject(value)) {\n    return formatPrimitive(ctx.stylize, value, ctx);\n  }\n  if (value === null) {\n    return ctx.stylize('null', 'null');\n  }\n\n  // Memorize the context for custom inspection on proxies.\n  const context = value;\n  // Always check for proxies to prevent side effects and to prevent triggering\n  // any proxy handlers.\n  const proxy = getProxyDetails(value, !!ctx.showProxy);\n  if (proxy !== undefined) {\n    if (ctx.showProxy) {\n      return formatProxy(ctx, proxy, recurseTimes);\n    }\n    value = proxy;\n  }\n\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it.\n  if (ctx.customInspect) {\n    const maybeCustom = value[customInspectSymbol];\n    if (typeof maybeCustom === 'function' &&\n        // Filter out the util module, its inspect function is special.\n        maybeCustom !== inspect &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      // This makes sure the recurseTimes are reported as before while using\n      // a counter internally.\n      const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;\n      const isCrossContext =\n        proxy !== undefined || !(context instanceof Object);\n      const ret = FunctionPrototypeCall(\n        maybeCustom, context, depth, getUserOptions(ctx, isCrossContext));\n      // If the custom inspection method returned `this`, don't go into\n      // infinite recursion.\n      if (ret !== context) {\n        if (typeof ret !== 'string') {\n          return formatValue(ctx, ret, recurseTimes);\n        }\n        return ret.replace(/\\n/g, `\\n${' '.repeat(ctx.indentationLvl)}`);\n      }\n    }\n  }\n\n  // Using an array here is actually better for the average case than using\n  // a Set. `seen` will only check for the depth and will never grow too large.\n  if (ctx.seen.includes(value)) {\n    let index = 1;\n    if (ctx.circular === undefined) {\n      ctx.circular = new Map([[value, index]]);\n    } else {\n      index = ctx.circular.get(value);\n      if (index === undefined) {\n        index = ctx.circular.size + 1;\n        ctx.circular.set(value, index);\n      }\n    }\n    return ctx.stylize(`[Circular *${index}]`, 'special');\n  }\n\n  return formatRaw(ctx, value, recurseTimes, typedArray);\n}\n\nfunction formatRaw(ctx, value, recurseTimes, typedArray) {\n  let keys;\n  let protoProps;\n  if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {\n    protoProps = [];\n  }\n\n  const constructor = getConstructorName(value, ctx, recurseTimes, protoProps);\n  // Reset the variable to check for this later on.\n  if (protoProps !== undefined && protoProps.length === 0) {\n    protoProps = undefined;\n  }\n\n  let tag = value[SymbolToStringTag];\n  // Only list the tag in case it's non-enumerable / not an own property.\n  // Otherwise we'd print this twice.\n  if (typeof tag !== 'string' ||\n      (tag !== '' &&\n      (ctx.showHidden ?\n        ObjectPrototypeHasOwnProperty :\n        ObjectPrototypePropertyIsEnumerable)(\n        value, SymbolToStringTag\n      ))) {\n    tag = '';\n  }\n  let base = '';\n  let formatter = getEmptyFormatArray;\n  let braces;\n  let noIterator = true;\n  let i = 0;\n  const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;\n\n  let extrasType = kObjectType;\n\n  // Iterators and the rest are split to reduce checks.\n  // We have to check all values in case the constructor is set to null.\n  // Otherwise it would not possible to identify all types properly.\n  if (value[SymbolIterator] || constructor === null) {\n    noIterator = false;\n    if (ArrayIsArray(value)) {\n      // Only set the constructor for non ordinary (\"Array [...]\") arrays.\n      const prefix = (constructor !== 'Array' || tag !== '') ?\n        getPrefix(constructor, tag, 'Array', `(${value.length})`) :\n        '';\n      keys = getOwnNonIndexProperties(value, filter);\n      braces = [`${prefix}[`, ']'];\n      if (value.length === 0 && keys.length === 0 && protoProps === undefined)\n        return `${braces[0]}]`;\n      extrasType = kArrayExtrasType;\n      formatter = formatArray;\n    } else if (isSet(value)) {\n      const size = setSizeGetter(value);\n      const prefix = getPrefix(constructor, tag, 'Set', `(${size})`);\n      keys = getKeys(value, ctx.showHidden);\n      formatter = constructor !== null ?\n        formatSet.bind(null, value) :\n        formatSet.bind(null, SetPrototypeValues(value));\n      if (size === 0 && keys.length === 0 && protoProps === undefined)\n        return `${prefix}{}`;\n      braces = [`${prefix}{`, '}'];\n    } else if (isMap(value)) {\n      const size = mapSizeGetter(value);\n      const prefix = getPrefix(constructor, tag, 'Map', `(${size})`);\n      keys = getKeys(value, ctx.showHidden);\n      formatter = constructor !== null ?\n        formatMap.bind(null, value) :\n        formatMap.bind(null, MapPrototypeEntries(value));\n      if (size === 0 && keys.length === 0 && protoProps === undefined)\n        return `${prefix}{}`;\n      braces = [`${prefix}{`, '}'];\n    } else if (isTypedArray(value)) {\n      keys = getOwnNonIndexProperties(value, filter);\n      let bound = value;\n      let fallback = '';\n      if (constructor === null) {\n        const constr = findTypedConstructor(value);\n        fallback = constr.name;\n        // Reconstruct the array information.\n        bound = new constr(value);\n      }\n      const size = typedArraySizeGetter(value);\n      const prefix = getPrefix(constructor, tag, fallback, `(${size})`);\n      braces = [`${prefix}[`, ']'];\n      if (value.length === 0 && keys.length === 0 && !ctx.showHidden)\n        return `${braces[0]}]`;\n      // Special handle the value. The original value is required below. The\n      // bound function is required to reconstruct missing information.\n      formatter = formatTypedArray.bind(null, bound, size);\n      extrasType = kArrayExtrasType;\n    } else if (isMapIterator(value)) {\n      keys = getKeys(value, ctx.showHidden);\n      braces = getIteratorBraces('Map', tag);\n      // Add braces to the formatter parameters.\n      formatter = formatIterator.bind(null, braces);\n    } else if (isSetIterator(value)) {\n      keys = getKeys(value, ctx.showHidden);\n      braces = getIteratorBraces('Set', tag);\n      // Add braces to the formatter parameters.\n      formatter = formatIterator.bind(null, braces);\n    } else {\n      noIterator = true;\n    }\n  }\n  if (noIterator) {\n    keys = getKeys(value, ctx.showHidden);\n    braces = ['{', '}'];\n    if (constructor === 'Object') {\n      if (isArgumentsObject(value)) {\n        braces[0] = '[Arguments] {';\n      } else if (tag !== '') {\n        braces[0] = `${getPrefix(constructor, tag, 'Object')}{`;\n      }\n      if (keys.length === 0 && protoProps === undefined) {\n        return `${braces[0]}}`;\n      }\n    } else if (typeof value === 'function') {\n      base = getFunctionBase(value, constructor, tag);\n      if (keys.length === 0 && protoProps === undefined)\n        return ctx.stylize(base, 'special');\n    } else if (isRegExp(value)) {\n      // Make RegExps say that they are RegExps\n      base = RegExpPrototypeToString(\n        constructor !== null ? value : new RegExp(value)\n      );\n      const prefix = getPrefix(constructor, tag, 'RegExp');\n      if (prefix !== 'RegExp ')\n        base = `${prefix}${base}`;\n      if ((keys.length === 0 && protoProps === undefined) ||\n          (recurseTimes > ctx.depth && ctx.depth !== null)) {\n        return ctx.stylize(base, 'regexp');\n      }\n    } else if (isDate(value)) {\n      // Make dates with properties first say the date\n      base = NumberIsNaN(DatePrototypeGetTime(value)) ?\n        DatePrototypeToString(value) :\n        DatePrototypeToISOString(value);\n      const prefix = getPrefix(constructor, tag, 'Date');\n      if (prefix !== 'Date ')\n        base = `${prefix}${base}`;\n      if (keys.length === 0 && protoProps === undefined) {\n        return ctx.stylize(base, 'date');\n      }\n    } else if (isError(value)) {\n      base = formatError(value, constructor, tag, ctx, keys);\n      if (keys.length === 0 && protoProps === undefined)\n        return base;\n    } else if (isAnyArrayBuffer(value)) {\n      // Fast path for ArrayBuffer and SharedArrayBuffer.\n      // Can't do the same for DataView because it has a non-primitive\n      // .buffer property that we need to recurse for.\n      const arrayType = isArrayBuffer(value) ? 'ArrayBuffer' :\n        'SharedArrayBuffer';\n      const prefix = getPrefix(constructor, tag, arrayType);\n      if (typedArray === undefined) {\n        formatter = formatArrayBuffer;\n      } else if (keys.length === 0 && protoProps === undefined) {\n        return prefix +\n              `{ byteLength: ${formatNumber(ctx.stylize, value.byteLength)} }`;\n      }\n      braces[0] = `${prefix}{`;\n      keys.unshift('byteLength');\n    } else if (isDataView(value)) {\n      braces[0] = `${getPrefix(constructor, tag, 'DataView')}{`;\n      // .buffer goes last, it's not a primitive like the others.\n      keys.unshift('byteLength', 'byteOffset', 'buffer');\n    } else if (isPromise(value)) {\n      braces[0] = `${getPrefix(constructor, tag, 'Promise')}{`;\n      formatter = formatPromise;\n    } else if (isWeakSet(value)) {\n      braces[0] = `${getPrefix(constructor, tag, 'WeakSet')}{`;\n      formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;\n    } else if (isWeakMap(value)) {\n      braces[0] = `${getPrefix(constructor, tag, 'WeakMap')}{`;\n      formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;\n    } else if (isModuleNamespaceObject(value)) {\n      braces[0] = `${getPrefix(constructor, tag, 'Module')}{`;\n      // Special handle keys for namespace objects.\n      formatter = formatNamespaceObject.bind(null, keys);\n    } else if (isBoxedPrimitive(value)) {\n      base = getBoxedBase(value, ctx, keys, constructor, tag);\n      if (keys.length === 0 && protoProps === undefined) {\n        return base;\n      }\n    } else {\n      if (keys.length === 0 && protoProps === undefined) {\n        if (isExternal(value)) {\n          const address = getExternalValue(value).toString(16);\n          return ctx.stylize(`[External: ${address}]`, 'special');\n        }\n        return `${getCtxStyle(value, constructor, tag)}{}`;\n      }\n      braces[0] = `${getCtxStyle(value, constructor, tag)}{`;\n    }\n  }\n\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\n    let constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);\n    if (constructor !== null)\n      constructorName = `[${constructorName}]`;\n    return ctx.stylize(constructorName, 'special');\n  }\n  recurseTimes += 1;\n\n  ctx.seen.push(value);\n  ctx.currentDepth = recurseTimes;\n  let output;\n  const indentationLvl = ctx.indentationLvl;\n  try {\n    output = formatter(ctx, value, recurseTimes);\n    for (i = 0; i < keys.length; i++) {\n      output.push(\n        formatProperty(ctx, value, recurseTimes, keys[i], extrasType));\n    }\n    if (protoProps !== undefined) {\n      output.push(...protoProps);\n    }\n  } catch (err) {\n    const constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);\n    return handleMaxCallStackSize(ctx, err, constructorName, indentationLvl);\n  }\n  if (ctx.circular !== undefined) {\n    const index = ctx.circular.get(value);\n    if (index !== undefined) {\n      const reference = ctx.stylize(`<ref *${index}>`, 'special');\n      // Add reference always to the very beginning of the output.\n      if (ctx.compact !== true) {\n        base = base === '' ? reference : `${reference} ${base}`;\n      } else {\n        braces[0] = `${reference} ${braces[0]}`;\n      }\n    }\n  }\n  ctx.seen.pop();\n\n  if (ctx.sorted) {\n    const comparator = ctx.sorted === true ? undefined : ctx.sorted;\n    if (extrasType === kObjectType) {\n      output = output.sort(comparator);\n    } else if (keys.length > 1) {\n      const sorted = output.slice(output.length - keys.length).sort(comparator);\n      output.splice(output.length - keys.length, keys.length, ...sorted);\n    }\n  }\n\n  const res = reduceToSingleString(\n    ctx, output, base, braces, extrasType, recurseTimes, value);\n  const budget = ctx.budget[ctx.indentationLvl] || 0;\n  const newLength = budget + res.length;\n  ctx.budget[ctx.indentationLvl] = newLength;\n  // If any indentationLvl exceeds this limit, limit further inspecting to the\n  // minimum. Otherwise the recursive algorithm might continue inspecting the\n  // object even though the maximum string size (~2 ** 28 on 32 bit systems and\n  // ~2 ** 30 on 64 bit systems) exceeded. The actual output is not limited at\n  // exactly 2 ** 27 but a bit higher. This depends on the object shape.\n  // This limit also makes sure that huge objects don't block the event loop\n  // significantly.\n  if (newLength > 2 ** 27) {\n    ctx.depth = -1;\n  }\n  return res;\n}\n\nfunction getIteratorBraces(type, tag) {\n  if (tag !== `${type} Iterator`) {\n    if (tag !== '')\n      tag += '] [';\n    tag += `${type} Iterator`;\n  }\n  return [`[${tag}] {`, '}'];\n}\n\nfunction getBoxedBase(value, ctx, keys, constructor, tag) {\n  let fn;\n  let type;\n  if (isNumberObject(value)) {\n    fn = NumberPrototypeValueOf;\n    type = 'Number';\n  } else if (isStringObject(value)) {\n    fn = StringPrototypeValueOf;\n    type = 'String';\n    // For boxed Strings, we have to remove the 0-n indexed entries,\n    // since they just noisy up the output and are redundant\n    // Make boxed primitive Strings look like such\n    keys.splice(0, value.length);\n  } else if (isBooleanObject(value)) {\n    fn = BooleanPrototypeValueOf;\n    type = 'Boolean';\n  } else if (isBigIntObject(value)) {\n    fn = BigIntPrototypeValueOf;\n    type = 'BigInt';\n  } else {\n    fn = SymbolPrototypeValueOf;\n    type = 'Symbol';\n  }\n  let base = `[${type}`;\n  if (type !== constructor) {\n    if (constructor === null) {\n      base += ' (null prototype)';\n    } else {\n      base += ` (${constructor})`;\n    }\n  }\n  base += `: ${formatPrimitive(stylizeNoColor, fn(value), ctx)}]`;\n  if (tag !== '' && tag !== constructor) {\n    base += ` [${tag}]`;\n  }\n  if (keys.length !== 0 || ctx.stylize === stylizeNoColor)\n    return base;\n  return ctx.stylize(base, type.toLowerCase());\n}\n\nfunction getClassBase(value, constructor, tag) {\n  const hasName = ObjectPrototypeHasOwnProperty(value, 'name');\n  const name = (hasName && value.name) || '(anonymous)';\n  let base = `class ${name}`;\n  if (constructor !== 'Function' && constructor !== null) {\n    base += ` [${constructor}]`;\n  }\n  if (tag !== '' && constructor !== tag) {\n    base += ` [${tag}]`;\n  }\n  if (constructor !== null) {\n    const superName = ObjectGetPrototypeOf(value).name;\n    if (superName) {\n      base += ` extends ${superName}`;\n    }\n  } else {\n    base += ' extends [null prototype]';\n  }\n  return `[${base}]`;\n}\n\nfunction getFunctionBase(value, constructor, tag) {\n  const stringified = FunctionPrototypeToString(value);\n  if (stringified.slice(0, 5) === 'class' && stringified.endsWith('}')) {\n    const slice = stringified.slice(5, -1);\n    const bracketIndex = slice.indexOf('{');\n    if (bracketIndex !== -1 &&\n        (!slice.slice(0, bracketIndex).includes('(') ||\n          // Slow path to guarantee that it's indeed a class.\n          classRegExp.test(slice.replace(stripCommentsRegExp)))) {\n      return getClassBase(value, constructor, tag);\n    }\n  }\n  let type = 'Function';\n  if (isGeneratorFunction(value)) {\n    type = `Generator${type}`;\n  }\n  if (isAsyncFunction(value)) {\n    type = `Async${type}`;\n  }\n  let base = `[${type}`;\n  if (constructor === null) {\n    base += ' (null prototype)';\n  }\n  if (value.name === '') {\n    base += ' (anonymous)';\n  } else {\n    base += `: ${value.name}`;\n  }\n  base += ']';\n  if (constructor !== type && constructor !== null) {\n    base += ` ${constructor}`;\n  }\n  if (tag !== '' && constructor !== tag) {\n    base += ` [${tag}]`;\n  }\n  return base;\n}\n\nfunction formatError(err, constructor, tag, ctx, keys) {\n  const name = err.name != null ? String(err.name) : 'Error';\n  let len = name.length;\n  let stack = err.stack ? String(err.stack) : ErrorPrototypeToString(err);\n\n  // Do not \"duplicate\" error properties that are already included in the output\n  // otherwise.\n  if (!ctx.showHidden && keys.length !== 0) {\n    for (const name of ['name', 'message', 'stack']) {\n      const index = keys.indexOf(name);\n      // Only hide the property in case it's part of the original stack\n      if (index !== -1 && stack.includes(err[name])) {\n        keys.splice(index, 1);\n      }\n    }\n  }\n\n  // A stack trace may contain arbitrary data. Only manipulate the output\n  // for \"regular errors\" (errors that \"look normal\") for now.\n  if (constructor === null ||\n      (name.endsWith('Error') &&\n      stack.startsWith(name) &&\n      (stack.length === len || stack[len] === ':' || stack[len] === '\\n'))) {\n    let fallback = 'Error';\n    if (constructor === null) {\n      const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\\]()-]+)(?::|\\n {4}at)/) ||\n        stack.match(/^([a-z_A-Z0-9-]*Error)$/);\n      fallback = (start && start[1]) || '';\n      len = fallback.length;\n      fallback = fallback || 'Error';\n    }\n    const prefix = getPrefix(constructor, tag, fallback).slice(0, -1);\n    if (name !== prefix) {\n      if (prefix.includes(name)) {\n        if (len === 0) {\n          stack = `${prefix}: ${stack}`;\n        } else {\n          stack = `${prefix}${stack.slice(len)}`;\n        }\n      } else {\n        stack = `${prefix} [${name}]${stack.slice(len)}`;\n      }\n    }\n  }\n  // Ignore the error message if it's contained in the stack.\n  let pos = (err.message && stack.indexOf(err.message)) || -1;\n  if (pos !== -1)\n    pos += err.message.length;\n  // Wrap the error in brackets in case it has no stack trace.\n  const stackStart = stack.indexOf('\\n    at', pos);\n  if (stackStart === -1) {\n    stack = `[${stack}]`;\n  } else if (ctx.colors) {\n    // Highlight userland code and node modules.\n    let newStack = stack.slice(0, stackStart);\n    const lines = stack.slice(stackStart + 1).split('\\n');\n    for (const line of lines) {\n      const core = line.match(coreModuleRegExp);\n      if (core !== null && NativeModule.exists(core[1])) {\n        newStack += `\\n${ctx.stylize(line, 'undefined')}`;\n      } else {\n        // This adds underscores to all node_modules to quickly identify them.\n        let nodeModule;\n        newStack += '\\n';\n        let pos = 0;\n        while (nodeModule = nodeModulesRegExp.exec(line)) {\n          // '/node_modules/'.length === 14\n          newStack += line.slice(pos, nodeModule.index + 14);\n          newStack += ctx.stylize(nodeModule[1], 'module');\n          pos = nodeModule.index + nodeModule[0].length;\n        }\n        newStack += pos === 0 ? line : line.slice(pos);\n      }\n    }\n    stack = newStack;\n  }\n  // The message and the stack have to be indented as well!\n  if (ctx.indentationLvl !== 0) {\n    const indentation = ' '.repeat(ctx.indentationLvl);\n    stack = stack.replace(/\\n/g, `\\n${indentation}`);\n  }\n  return stack;\n}\n\nfunction groupArrayElements(ctx, output, value) {\n  let totalLength = 0;\n  let maxLength = 0;\n  let i = 0;\n  let outputLength = output.length;\n  if (ctx.maxArrayLength < output.length) {\n    // This makes sure the \"... n more items\" part is not taken into account.\n    outputLength--;\n  }\n  const separatorSpace = 2; // Add 1 for the space and 1 for the separator.\n  const dataLen = new Array(outputLength);\n  // Calculate the total length of all output entries and the individual max\n  // entries length of all output entries. We have to remove colors first,\n  // otherwise the length would not be calculated properly.\n  for (; i < outputLength; i++) {\n    const len = getStringWidth(output[i], ctx.colors);\n    dataLen[i] = len;\n    totalLength += len + separatorSpace;\n    if (maxLength < len)\n      maxLength = len;\n  }\n  // Add two to `maxLength` as we add a single whitespace character plus a comma\n  // in-between two entries.\n  const actualMax = maxLength + separatorSpace;\n  // Check if at least three entries fit next to each other and prevent grouping\n  // of arrays that contains entries of very different length (i.e., if a single\n  // entry is longer than 1/5 of all other entries combined). Otherwise the\n  // space in-between small entries would be enormous.\n  if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength &&\n      (totalLength / actualMax > 5 || maxLength <= 6)) {\n\n    const approxCharHeights = 2.5;\n    const averageBias = MathSqrt(actualMax - totalLength / output.length);\n    const biasedMax = MathMax(actualMax - 3 - averageBias, 1);\n    // Dynamically check how many columns seem possible.\n    const columns = MathMin(\n      // Ideally a square should be drawn. We expect a character to be about 2.5\n      // times as high as wide. This is the area formula to calculate a square\n      // which contains n rectangles of size `actualMax * approxCharHeights`.\n      // Divide that by `actualMax` to receive the correct number of columns.\n      // The added bias increases the columns for short entries.\n      MathRound(\n        MathSqrt(\n          approxCharHeights * biasedMax * outputLength\n        ) / biasedMax\n      ),\n      // Do not exceed the breakLength.\n      MathFloor((ctx.breakLength - ctx.indentationLvl) / actualMax),\n      // Limit array grouping for small `compact` modes as the user requested\n      // minimal grouping.\n      ctx.compact * 4,\n      // Limit the columns to a maximum of fifteen.\n      15\n    );\n    // Return with the original output if no grouping should happen.\n    if (columns <= 1) {\n      return output;\n    }\n    const tmp = [];\n    const maxLineLength = [];\n    for (let i = 0; i < columns; i++) {\n      let lineMaxLength = 0;\n      for (let j = i; j < output.length; j += columns) {\n        if (dataLen[j] > lineMaxLength)\n          lineMaxLength = dataLen[j];\n      }\n      lineMaxLength += separatorSpace;\n      maxLineLength[i] = lineMaxLength;\n    }\n    let order = 'padStart';\n    if (value !== undefined) {\n      for (let i = 0; i < output.length; i++) {\n        if (typeof value[i] !== 'number' && typeof value[i] !== 'bigint') {\n          order = 'padEnd';\n          break;\n        }\n      }\n    }\n    // Each iteration creates a single line of grouped entries.\n    for (let i = 0; i < outputLength; i += columns) {\n      // The last lines may contain less entries than columns.\n      const max = MathMin(i + columns, outputLength);\n      let str = '';\n      let j = i;\n      for (; j < max - 1; j++) {\n        // Calculate extra color padding in case it's active. This has to be\n        // done line by line as some lines might contain more colors than\n        // others.\n        const padding = maxLineLength[j - i] + output[j].length - dataLen[j];\n        str += `${output[j]}, `[order](padding, ' ');\n      }\n      if (order === 'padStart') {\n        const padding = maxLineLength[j - i] +\n                        output[j].length -\n                        dataLen[j] -\n                        separatorSpace;\n        str += output[j].padStart(padding, ' ');\n      } else {\n        str += output[j];\n      }\n      tmp.push(str);\n    }\n    if (ctx.maxArrayLength < output.length) {\n      tmp.push(output[outputLength]);\n    }\n    output = tmp;\n  }\n  return output;\n}\n\nfunction handleMaxCallStackSize(ctx, err, constructorName, indentationLvl) {\n  if (isStackOverflowError(err)) {\n    ctx.seen.pop();\n    ctx.indentationLvl = indentationLvl;\n    return ctx.stylize(\n      `[${constructorName}: Inspection interrupted ` +\n        'prematurely. Maximum call stack size exceeded.]',\n      'special'\n    );\n  }\n  throw err;\n}\n\nfunction formatNumber(fn, value) {\n  // Format -0 as '-0'. Checking `value === -0` won't distinguish 0 from -0.\n  return fn(ObjectIs(value, -0) ? '-0' : `${value}`, 'number');\n}\n\nfunction formatBigInt(fn, value) {\n  return fn(`${value}n`, 'bigint');\n}\n\nfunction formatPrimitive(fn, value, ctx) {\n  if (typeof value === 'string') {\n    let trailer = '';\n    if (value.length > ctx.maxStringLength) {\n      const remaining = value.length - ctx.maxStringLength;\n      value = value.slice(0, ctx.maxStringLength);\n      trailer = `... ${remaining} more character${remaining > 1 ? 's' : ''}`;\n    }\n    if (ctx.compact !== true &&\n        // TODO(BridgeAR): Add unicode support. Use the readline getStringWidth\n        // function.\n        value.length > kMinLineLength &&\n        value.length > ctx.breakLength - ctx.indentationLvl - 4) {\n      return value\n        .split(/(?<=\\n)/)\n        .map((line) => fn(strEscape(line), 'string'))\n        .join(` +\\n${' '.repeat(ctx.indentationLvl + 2)}`) + trailer;\n    }\n    return fn(strEscape(value), 'string') + trailer;\n  }\n  if (typeof value === 'number')\n    return formatNumber(fn, value);\n  if (typeof value === 'bigint')\n    return formatBigInt(fn, value);\n  if (typeof value === 'boolean')\n    return fn(`${value}`, 'boolean');\n  if (typeof value === 'undefined')\n    return fn('undefined', 'undefined');\n  // es6 symbol primitive\n  return fn(SymbolPrototypeToString(value), 'symbol');\n}\n\nfunction formatNamespaceObject(keys, ctx, value, recurseTimes) {\n  const output = new Array(keys.length);\n  for (let i = 0; i < keys.length; i++) {\n    try {\n      output[i] = formatProperty(ctx, value, recurseTimes, keys[i],\n                                 kObjectType);\n    } catch (err) {\n      if (!(isNativeError(err) && err.name === 'ReferenceError')) {\n        throw err;\n      }\n      // Use the existing functionality. This makes sure the indentation and\n      // line breaks are always correct. Otherwise it is very difficult to keep\n      // this aligned, even though this is a hacky way of dealing with this.\n      const tmp = { [keys[i]]: '' };\n      output[i] = formatProperty(ctx, tmp, recurseTimes, keys[i], kObjectType);\n      const pos = output[i].lastIndexOf(' ');\n      // We have to find the last whitespace and have to replace that value as\n      // it will be visualized as a regular string.\n      output[i] = output[i].slice(0, pos + 1) +\n                  ctx.stylize('<uninitialized>', 'special');\n    }\n  }\n  // Reset the keys to an empty array. This prevents duplicated inspection.\n  keys.length = 0;\n  return output;\n}\n\n// The array is sparse and/or has extra keys\nfunction formatSpecialArray(ctx, value, recurseTimes, maxLength, output, i) {\n  const keys = ObjectKeys(value);\n  let index = i;\n  for (; i < keys.length && output.length < maxLength; i++) {\n    const key = keys[i];\n    const tmp = +key;\n    // Arrays can only have up to 2^32 - 1 entries\n    if (tmp > 2 ** 32 - 2) {\n      break;\n    }\n    if (`${index}` !== key) {\n      if (!numberRegExp.test(key)) {\n        break;\n      }\n      const emptyItems = tmp - index;\n      const ending = emptyItems > 1 ? 's' : '';\n      const message = `<${emptyItems} empty item${ending}>`;\n      output.push(ctx.stylize(message, 'undefined'));\n      index = tmp;\n      if (output.length === maxLength) {\n        break;\n      }\n    }\n    output.push(formatProperty(ctx, value, recurseTimes, key, kArrayType));\n    index++;\n  }\n  const remaining = value.length - index;\n  if (output.length !== maxLength) {\n    if (remaining > 0) {\n      const ending = remaining > 1 ? 's' : '';\n      const message = `<${remaining} empty item${ending}>`;\n      output.push(ctx.stylize(message, 'undefined'));\n    }\n  } else if (remaining > 0) {\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  }\n  return output;\n}\n\nfunction formatArrayBuffer(ctx, value) {\n  let buffer;\n  try {\n    buffer = new Uint8Array(value);\n  } catch {\n    return [ctx.stylize('(detached)', 'special')];\n  }\n  if (hexSlice === undefined)\n    hexSlice = uncurryThis(require('buffer').Buffer.prototype.hexSlice);\n  let str = hexSlice(buffer, 0, MathMin(ctx.maxArrayLength, buffer.length))\n    .replace(/(.{2})/g, '$1 ').trim();\n  const remaining = buffer.length - ctx.maxArrayLength;\n  if (remaining > 0)\n    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;\n  return [`${ctx.stylize('[Uint8Contents]', 'special')}: <${str}>`];\n}\n\nfunction formatArray(ctx, value, recurseTimes) {\n  const valLen = value.length;\n  const len = MathMin(MathMax(0, ctx.maxArrayLength), valLen);\n\n  const remaining = valLen - len;\n  const output = [];\n  for (let i = 0; i < len; i++) {\n    // Special handle sparse arrays.\n    if (!ObjectPrototypeHasOwnProperty(value, i)) {\n      return formatSpecialArray(ctx, value, recurseTimes, len, output, i);\n    }\n    output.push(formatProperty(ctx, value, recurseTimes, i, kArrayType));\n  }\n  if (remaining > 0)\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  return output;\n}\n\nfunction formatTypedArray(value, length, ctx, ignored, recurseTimes) {\n  const maxLength = MathMin(MathMax(0, ctx.maxArrayLength), length);\n  const remaining = value.length - maxLength;\n  const output = new Array(maxLength);\n  const elementFormatter = value.length > 0 && typeof value[0] === 'number' ?\n    formatNumber :\n    formatBigInt;\n  for (let i = 0; i < maxLength; ++i)\n    output[i] = elementFormatter(ctx.stylize, value[i]);\n  if (remaining > 0) {\n    output[maxLength] = `... ${remaining} more item${remaining > 1 ? 's' : ''}`;\n  }\n  if (ctx.showHidden) {\n    // .buffer goes last, it's not a primitive like the others.\n    // All besides `BYTES_PER_ELEMENT` are actually getters.\n    ctx.indentationLvl += 2;\n    for (const key of [\n      'BYTES_PER_ELEMENT',\n      'length',\n      'byteLength',\n      'byteOffset',\n      'buffer'\n    ]) {\n      const str = formatValue(ctx, value[key], recurseTimes, true);\n      output.push(`[${key}]: ${str}`);\n    }\n    ctx.indentationLvl -= 2;\n  }\n  return output;\n}\n\nfunction formatSet(value, ctx, ignored, recurseTimes) {\n  const output = [];\n  ctx.indentationLvl += 2;\n  for (const v of value) {\n    output.push(formatValue(ctx, v, recurseTimes));\n  }\n  ctx.indentationLvl -= 2;\n  return output;\n}\n\nfunction formatMap(value, ctx, ignored, recurseTimes) {\n  const output = [];\n  ctx.indentationLvl += 2;\n  for (const [k, v] of value) {\n    output.push(`${formatValue(ctx, k, recurseTimes)} => ` +\n                formatValue(ctx, v, recurseTimes));\n  }\n  ctx.indentationLvl -= 2;\n  return output;\n}\n\nfunction formatSetIterInner(ctx, recurseTimes, entries, state) {\n  const maxArrayLength = MathMax(ctx.maxArrayLength, 0);\n  const maxLength = MathMin(maxArrayLength, entries.length);\n  let output = new Array(maxLength);\n  ctx.indentationLvl += 2;\n  for (let i = 0; i < maxLength; i++) {\n    output[i] = formatValue(ctx, entries[i], recurseTimes);\n  }\n  ctx.indentationLvl -= 2;\n  if (state === kWeak && !ctx.sorted) {\n    // Sort all entries to have a halfway reliable output (if more entries than\n    // retrieved ones exist, we can not reliably return the same output) if the\n    // output is not sorted anyway.\n    output = output.sort();\n  }\n  const remaining = entries.length - maxLength;\n  if (remaining > 0) {\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  }\n  return output;\n}\n\nfunction formatMapIterInner(ctx, recurseTimes, entries, state) {\n  const maxArrayLength = MathMax(ctx.maxArrayLength, 0);\n  // Entries exist as [key1, val1, key2, val2, ...]\n  const len = entries.length / 2;\n  const remaining = len - maxArrayLength;\n  const maxLength = MathMin(maxArrayLength, len);\n  let output = new Array(maxLength);\n  let i = 0;\n  ctx.indentationLvl += 2;\n  if (state === kWeak) {\n    for (; i < maxLength; i++) {\n      const pos = i * 2;\n      output[i] = `${formatValue(ctx, entries[pos], recurseTimes)}` +\n        ` => ${formatValue(ctx, entries[pos + 1], recurseTimes)}`;\n    }\n    // Sort all entries to have a halfway reliable output (if more entries than\n    // retrieved ones exist, we can not reliably return the same output) if the\n    // output is not sorted anyway.\n    if (!ctx.sorted)\n      output = output.sort();\n  } else {\n    for (; i < maxLength; i++) {\n      const pos = i * 2;\n      const res = [\n        formatValue(ctx, entries[pos], recurseTimes),\n        formatValue(ctx, entries[pos + 1], recurseTimes)\n      ];\n      output[i] = reduceToSingleString(\n        ctx, res, '', ['[', ']'], kArrayExtrasType, recurseTimes);\n    }\n  }\n  ctx.indentationLvl -= 2;\n  if (remaining > 0) {\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  }\n  return output;\n}\n\nfunction formatWeakCollection(ctx) {\n  return [ctx.stylize('<items unknown>', 'special')];\n}\n\nfunction formatWeakSet(ctx, value, recurseTimes) {\n  const entries = previewEntries(value);\n  return formatSetIterInner(ctx, recurseTimes, entries, kWeak);\n}\n\nfunction formatWeakMap(ctx, value, recurseTimes) {\n  const entries = previewEntries(value);\n  return formatMapIterInner(ctx, recurseTimes, entries, kWeak);\n}\n\nfunction formatIterator(braces, ctx, value, recurseTimes) {\n  const [entries, isKeyValue] = previewEntries(value, true);\n  if (isKeyValue) {\n    // Mark entry iterators as such.\n    braces[0] = braces[0].replace(/ Iterator] {$/, ' Entries] {');\n    return formatMapIterInner(ctx, recurseTimes, entries, kMapEntries);\n  }\n\n  return formatSetIterInner(ctx, recurseTimes, entries, kIterator);\n}\n\nfunction formatPromise(ctx, value, recurseTimes) {\n  let output;\n  const [state, result] = getPromiseDetails(value);\n  if (state === kPending) {\n    output = [ctx.stylize('<pending>', 'special')];\n  } else {\n    ctx.indentationLvl += 2;\n    const str = formatValue(ctx, result, recurseTimes);\n    ctx.indentationLvl -= 2;\n    output = [\n      state === kRejected ?\n        `${ctx.stylize('<rejected>', 'special')} ${str}` :\n        str\n    ];\n  }\n  return output;\n}\n\nfunction formatProperty(ctx, value, recurseTimes, key, type, desc,\n                        original = value) {\n  let name, str;\n  let extra = ' ';\n  desc = desc || ObjectGetOwnPropertyDescriptor(value, key) ||\n    { value: value[key], enumerable: true };\n  if (desc.value !== undefined) {\n    const diff = (ctx.compact !== true || type !== kObjectType) ? 2 : 3;\n    ctx.indentationLvl += diff;\n    str = formatValue(ctx, desc.value, recurseTimes);\n    if (diff === 3 && ctx.breakLength < getStringWidth(str, ctx.colors)) {\n      extra = `\\n${' '.repeat(ctx.indentationLvl)}`;\n    }\n    ctx.indentationLvl -= diff;\n  } else if (desc.get !== undefined) {\n    const label = desc.set !== undefined ? 'Getter/Setter' : 'Getter';\n    const s = ctx.stylize;\n    const sp = 'special';\n    if (ctx.getters && (ctx.getters === true ||\n          (ctx.getters === 'get' && desc.set === undefined) ||\n          (ctx.getters === 'set' && desc.set !== undefined))) {\n      try {\n        const tmp = ReflectApply(desc.get, original, []);\n        ctx.indentationLvl += 2;\n        if (tmp === null) {\n          str = `${s(`[${label}:`, sp)} ${s('null', 'null')}${s(']', sp)}`;\n        } else if (typeof tmp === 'object') {\n          str = `${s(`[${label}]`, sp)} ${formatValue(ctx, tmp, recurseTimes)}`;\n        } else {\n          const primitive = formatPrimitive(s, tmp, ctx);\n          str = `${s(`[${label}:`, sp)} ${primitive}${s(']', sp)}`;\n        }\n        ctx.indentationLvl -= 2;\n      } catch (err) {\n        const message = `<Inspection threw (${err.message})>`;\n        str = `${s(`[${label}:`, sp)} ${message}${s(']', sp)}`;\n      }\n    } else {\n      str = ctx.stylize(`[${label}]`, sp);\n    }\n  } else if (desc.set !== undefined) {\n    str = ctx.stylize('[Setter]', 'special');\n  } else {\n    str = ctx.stylize('undefined', 'undefined');\n  }\n  if (type === kArrayType) {\n    return str;\n  }\n  if (typeof key === 'symbol') {\n    const tmp = key.toString().replace(strEscapeSequencesReplacer, escapeFn);\n    name = `[${ctx.stylize(tmp, 'symbol')}]`;\n  } else if (desc.enumerable === false) {\n    name = `[${key.replace(strEscapeSequencesReplacer, escapeFn)}]`;\n  } else if (keyStrRegExp.test(key)) {\n    name = ctx.stylize(key, 'name');\n  } else {\n    name = ctx.stylize(strEscape(key), 'string');\n  }\n  return `${name}:${extra}${str}`;\n}\n\nfunction isBelowBreakLength(ctx, output, start, base) {\n  // Each entry is separated by at least a comma. Thus, we start with a total\n  // length of at least `output.length`. In addition, some cases have a\n  // whitespace in-between each other that is added to the total as well.\n  // TODO(BridgeAR): Add unicode support. Use the readline getStringWidth\n  // function. Check the performance overhead and make it an opt-in in case it's\n  // significant.\n  let totalLength = output.length + start;\n  if (totalLength + output.length > ctx.breakLength)\n    return false;\n  for (let i = 0; i < output.length; i++) {\n    if (ctx.colors) {\n      totalLength += removeColors(output[i]).length;\n    } else {\n      totalLength += output[i].length;\n    }\n    if (totalLength > ctx.breakLength) {\n      return false;\n    }\n  }\n  // Do not line up properties on the same line if `base` contains line breaks.\n  return base === '' || !base.includes('\\n');\n}\n\nfunction reduceToSingleString(\n  ctx, output, base, braces, extrasType, recurseTimes, value) {\n  if (ctx.compact !== true) {\n    if (typeof ctx.compact === 'number' && ctx.compact >= 1) {\n      // Memorize the original output length. In case the the output is grouped,\n      // prevent lining up the entries on a single line.\n      const entries = output.length;\n      // Group array elements together if the array contains at least six\n      // separate entries.\n      if (extrasType === kArrayExtrasType && entries > 6) {\n        output = groupArrayElements(ctx, output, value);\n      }\n      // `ctx.currentDepth` is set to the most inner depth of the currently\n      // inspected object part while `recurseTimes` is the actual current depth\n      // that is inspected.\n      //\n      // Example:\n      //\n      // const a = { first: [ 1, 2, 3 ], second: { inner: [ 1, 2, 3 ] } }\n      //\n      // The deepest depth of `a` is 2 (a.second.inner) and `a.first` has a max\n      // depth of 1.\n      //\n      // Consolidate all entries of the local most inner depth up to\n      // `ctx.compact`, as long as the properties are smaller than\n      // `ctx.breakLength`.\n      if (ctx.currentDepth - recurseTimes < ctx.compact &&\n          entries === output.length) {\n        // Line up all entries on a single line in case the entries do not\n        // exceed `breakLength`. Add 10 as constant to start next to all other\n        // factors that may reduce `breakLength`.\n        const start = output.length + ctx.indentationLvl +\n                      braces[0].length + base.length + 10;\n        if (isBelowBreakLength(ctx, output, start, base)) {\n          return `${base ? `${base} ` : ''}${braces[0]} ${join(output, ', ')}` +\n            ` ${braces[1]}`;\n        }\n      }\n    }\n    // Line up each entry on an individual line.\n    const indentation = `\\n${' '.repeat(ctx.indentationLvl)}`;\n    return `${base ? `${base} ` : ''}${braces[0]}${indentation}  ` +\n      `${join(output, `,${indentation}  `)}${indentation}${braces[1]}`;\n  }\n  // Line up all entries on a single line in case the entries do not exceed\n  // `breakLength`.\n  if (isBelowBreakLength(ctx, output, 0, base)) {\n    return `${braces[0]}${base ? ` ${base}` : ''} ${join(output, ', ')} ` +\n      braces[1];\n  }\n  const indentation = ' '.repeat(ctx.indentationLvl);\n  // If the opening \"brace\" is too large, like in the case of \"Set {\",\n  // we need to force the first item to be on the next line or the\n  // items will not line up correctly.\n  const ln = base === '' && braces[0].length === 1 ?\n    ' ' : `${base ? ` ${base}` : ''}\\n${indentation}  `;\n  // Line up each entry on an individual line.\n  return `${braces[0]}${ln}${join(output, `,\\n${indentation}  `)} ${braces[1]}`;\n}\n\nfunction hasBuiltInToString(value) {\n  // Prevent triggering proxy traps.\n  const getFullProxy = false;\n  const proxyTarget = getProxyDetails(value, getFullProxy);\n  if (proxyTarget !== undefined) {\n    value = proxyTarget;\n  }\n\n  // Count objects that have no `toString` function as built-in.\n  if (typeof value.toString !== 'function') {\n    return true;\n  }\n\n  // The object has a own `toString` property. Thus it's not not a built-in one.\n  if (ObjectPrototypeHasOwnProperty(value, 'toString')) {\n    return false;\n  }\n\n  // Find the object that has the `toString` property as own property in the\n  // prototype chain.\n  let pointer = value;\n  do {\n    pointer = ObjectGetPrototypeOf(pointer);\n  } while (!ObjectPrototypeHasOwnProperty(pointer, 'toString'));\n\n  // Check closer if the object is a built-in.\n  const descriptor = ObjectGetOwnPropertyDescriptor(pointer, 'constructor');\n  return descriptor !== undefined &&\n    typeof descriptor.value === 'function' &&\n    builtInObjects.has(descriptor.value.name);\n}\n\nconst firstErrorLine = (error) => error.message.split('\\n')[0];\nlet CIRCULAR_ERROR_MESSAGE;\nfunction tryStringify(arg) {\n  try {\n    return JSONStringify(arg);\n  } catch (err) {\n    // Populate the circular error message lazily\n    if (!CIRCULAR_ERROR_MESSAGE) {\n      try {\n        const a = {}; a.a = a; JSONStringify(a);\n      } catch (err) {\n        CIRCULAR_ERROR_MESSAGE = firstErrorLine(err);\n      }\n    }\n    if (err.name === 'TypeError' &&\n        firstErrorLine(err) === CIRCULAR_ERROR_MESSAGE) {\n      return '[Circular]';\n    }\n    throw err;\n  }\n}\n\nfunction format(...args) {\n  return formatWithOptionsInternal(undefined, ...args);\n}\n\nfunction formatWithOptions(inspectOptions, ...args) {\n  if (typeof inspectOptions !== 'object' || inspectOptions === null) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'inspectOptions', 'object', inspectOptions);\n  }\n  return formatWithOptionsInternal(inspectOptions, ...args);\n}\n\nfunction formatWithOptionsInternal(inspectOptions, ...args) {\n  const first = args[0];\n  let a = 0;\n  let str = '';\n  let join = '';\n\n  if (typeof first === 'string') {\n    if (args.length === 1) {\n      return first;\n    }\n    let tempStr;\n    let lastPos = 0;\n\n    for (let i = 0; i < first.length - 1; i++) {\n      if (first.charCodeAt(i) === 37) { // '%'\n        const nextChar = first.charCodeAt(++i);\n        if (a + 1 !== args.length) {\n          switch (nextChar) {\n            case 115: // 's'\n              const tempArg = args[++a];\n              if (typeof tempArg === 'number') {\n                tempStr = formatNumber(stylizeNoColor, tempArg);\n              } else if (typeof tempArg === 'bigint') {\n                tempStr = `${tempArg}n`;\n              } else if (typeof tempArg !== 'object' ||\n                         tempArg === null ||\n                         !hasBuiltInToString(tempArg)) {\n                tempStr = String(tempArg);\n              } else {\n                tempStr = inspect(tempArg, {\n                  ...inspectOptions,\n                  compact: 3,\n                  colors: false,\n                  depth: 0\n                });\n              }\n              break;\n            case 106: // 'j'\n              tempStr = tryStringify(args[++a]);\n              break;\n            case 100: // 'd'\n              const tempNum = args[++a];\n              if (typeof tempNum === 'bigint') {\n                tempStr = `${tempNum}n`;\n              } else if (typeof tempNum === 'symbol') {\n                tempStr = 'NaN';\n              } else {\n                tempStr = formatNumber(stylizeNoColor, Number(tempNum));\n              }\n              break;\n            case 79: // 'O'\n              tempStr = inspect(args[++a], inspectOptions);\n              break;\n            case 111: // 'o'\n              tempStr = inspect(args[++a], {\n                ...inspectOptions,\n                showHidden: true,\n                showProxy: true,\n                depth: 4\n              });\n              break;\n            case 105: // 'i'\n              const tempInteger = args[++a];\n              if (typeof tempInteger === 'bigint') {\n                tempStr = `${tempInteger}n`;\n              } else if (typeof tempInteger === 'symbol') {\n                tempStr = 'NaN';\n              } else {\n                tempStr = formatNumber(stylizeNoColor,\n                                       NumberParseInt(tempInteger));\n              }\n              break;\n            case 102: // 'f'\n              const tempFloat = args[++a];\n              if (typeof tempFloat === 'symbol') {\n                tempStr = 'NaN';\n              } else {\n                tempStr = formatNumber(stylizeNoColor,\n                                       NumberParseFloat(tempFloat));\n              }\n              break;\n            case 99: // 'c'\n              a += 1;\n              tempStr = '';\n              break;\n            case 37: // '%'\n              str += first.slice(lastPos, i);\n              lastPos = i + 1;\n              continue;\n            default: // Any other character is not a correct placeholder\n              continue;\n          }\n          if (lastPos !== i - 1) {\n            str += first.slice(lastPos, i - 1);\n          }\n          str += tempStr;\n          lastPos = i + 1;\n        } else if (nextChar === 37) {\n          str += first.slice(lastPos, i);\n          lastPos = i + 1;\n        }\n      }\n    }\n    if (lastPos !== 0) {\n      a++;\n      join = ' ';\n      if (lastPos < first.length) {\n        str += first.slice(lastPos);\n      }\n    }\n  }\n\n  while (a < args.length) {\n    const value = args[a];\n    str += join;\n    str += typeof value !== 'string' ? inspect(value, inspectOptions) : value;\n    join = ' ';\n    a++;\n  }\n  return str;\n}\n\nif (internalBinding('config').hasIntl) {\n  const icu = internalBinding('icu');\n  // icu.getStringWidth(string, ambiguousAsFullWidth, expandEmojiSequence)\n  // Defaults: ambiguousAsFullWidth = false; expandEmojiSequence = true;\n  // TODO(BridgeAR): Expose the options to the user. That is probably the\n  // best thing possible at the moment, since it's difficult to know what\n  // the receiving end supports.\n  getStringWidth = function getStringWidth(str, removeControlChars = true) {\n    let width = 0;\n\n    if (removeControlChars)\n      str = stripVTControlCharacters(str);\n    for (let i = 0; i < str.length; i++) {\n      // Try to avoid calling into C++ by first handling the ASCII portion of\n      // the string. If it is fully ASCII, we skip the C++ part.\n      const code = str.charCodeAt(i);\n      if (code >= 127) {\n        width += icu.getStringWidth(str.slice(i).normalize('NFC'));\n        break;\n      }\n      width += code >= 32 ? 1 : 0;\n    }\n    return width;\n  };\n} else {\n  /**\n   * Returns the number of columns required to display the given string.\n   */\n  getStringWidth = function getStringWidth(str, removeControlChars = true) {\n    let width = 0;\n\n    if (removeControlChars)\n      str = stripVTControlCharacters(str);\n    str = str.normalize('NFC');\n    for (const char of str) {\n      const code = char.codePointAt(0);\n      if (isFullWidthCodePoint(code)) {\n        width += 2;\n      } else if (!isZeroWidthCodePoint(code)) {\n        width++;\n      }\n    }\n\n    return width;\n  };\n\n  /**\n   * Returns true if the character represented by a given\n   * Unicode code point is full-width. Otherwise returns false.\n   */\n  const isFullWidthCodePoint = (code) => {\n    // Code points are partially derived from:\n    // https://www.unicode.org/Public/UNIDATA/EastAsianWidth.txt\n    return code >= 0x1100 && (\n      code <= 0x115f ||  // Hangul Jamo\n      code === 0x2329 || // LEFT-POINTING ANGLE BRACKET\n      code === 0x232a || // RIGHT-POINTING ANGLE BRACKET\n      // CJK Radicals Supplement .. Enclosed CJK Letters and Months\n      (code >= 0x2e80 && code <= 0x3247 && code !== 0x303f) ||\n      // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A\n      (code >= 0x3250 && code <= 0x4dbf) ||\n      // CJK Unified Ideographs .. Yi Radicals\n      (code >= 0x4e00 && code <= 0xa4c6) ||\n      // Hangul Jamo Extended-A\n      (code >= 0xa960 && code <= 0xa97c) ||\n      // Hangul Syllables\n      (code >= 0xac00 && code <= 0xd7a3) ||\n      // CJK Compatibility Ideographs\n      (code >= 0xf900 && code <= 0xfaff) ||\n      // Vertical Forms\n      (code >= 0xfe10 && code <= 0xfe19) ||\n      // CJK Compatibility Forms .. Small Form Variants\n      (code >= 0xfe30 && code <= 0xfe6b) ||\n      // Halfwidth and Fullwidth Forms\n      (code >= 0xff01 && code <= 0xff60) ||\n      (code >= 0xffe0 && code <= 0xffe6) ||\n      // Kana Supplement\n      (code >= 0x1b000 && code <= 0x1b001) ||\n      // Enclosed Ideographic Supplement\n      (code >= 0x1f200 && code <= 0x1f251) ||\n      // Miscellaneous Symbols and Pictographs 0x1f300 - 0x1f5ff\n      // Emoticons 0x1f600 - 0x1f64f\n      (code >= 0x1f300 && code <= 0x1f64f) ||\n      // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane\n      (code >= 0x20000 && code <= 0x3fffd)\n    );\n  };\n\n  const isZeroWidthCodePoint = (code) => {\n    return code <= 0x1F || // C0 control codes\n      (code >= 0x7F && code <= 0x9F) || // C1 control codes\n      (code >= 0x300 && code <= 0x36F) || // Combining Diacritical Marks\n      (code >= 0x200B && code <= 0x200F) || // Modifying Invisible Characters\n      // Combining Diacritical Marks for Symbols\n      (code >= 0x20D0 && code <= 0x20FF) ||\n      (code >= 0xFE00 && code <= 0xFE0F) || // Variation Selectors\n      (code >= 0xFE20 && code <= 0xFE2F) || // Combining Half Marks\n      (code >= 0xE0100 && code <= 0xE01EF); // Variation Selectors\n  };\n}\n\n/**\n * Remove all VT control characters. Use to estimate displayed string width.\n */\nfunction stripVTControlCharacters(str) {\n  return str.replace(ansi, '');\n}\n\nmodule.exports = {\n  inspect,\n  format,\n  formatWithOptions,\n  getStringWidth,\n  inspectDefaultOptions,\n  stripVTControlCharacters\n};\n"
  },
  {
    "url": "internal/util/types.js",
    "ranges": [
      {
        "start": 0,
        "end": 425
      },
      {
        "start": 516,
        "end": 518
      },
      {
        "start": 612,
        "end": 614
      },
      {
        "start": 722,
        "end": 724
      },
      {
        "start": 820,
        "end": 822
      },
      {
        "start": 918,
        "end": 920
      },
      {
        "start": 1012,
        "end": 1014
      },
      {
        "start": 1108,
        "end": 1110
      },
      {
        "start": 1204,
        "end": 1206
      },
      {
        "start": 1304,
        "end": 1306
      },
      {
        "start": 1404,
        "end": 1406
      },
      {
        "start": 1506,
        "end": 1508
      },
      {
        "start": 1610,
        "end": 1915
      }
    ],
    "text": "'use strict';\n\nconst {\n  ArrayBufferIsView,\n  ObjectGetOwnPropertyDescriptor,\n  ObjectGetPrototypeOf,\n  SymbolToStringTag,\n  Uint8ArrayPrototype,\n  uncurryThis,\n} = primordials;\n\nconst TypedArrayPrototype = ObjectGetPrototypeOf(Uint8ArrayPrototype);\n\nconst TypedArrayProto_toStringTag =\n    uncurryThis(\n      ObjectGetOwnPropertyDescriptor(TypedArrayPrototype,\n                                     SymbolToStringTag).get);\n\nfunction isTypedArray(value) {\n  return TypedArrayProto_toStringTag(value) !== undefined;\n}\n\nfunction isUint8Array(value) {\n  return TypedArrayProto_toStringTag(value) === 'Uint8Array';\n}\n\nfunction isUint8ClampedArray(value) {\n  return TypedArrayProto_toStringTag(value) === 'Uint8ClampedArray';\n}\n\nfunction isUint16Array(value) {\n  return TypedArrayProto_toStringTag(value) === 'Uint16Array';\n}\n\nfunction isUint32Array(value) {\n  return TypedArrayProto_toStringTag(value) === 'Uint32Array';\n}\n\nfunction isInt8Array(value) {\n  return TypedArrayProto_toStringTag(value) === 'Int8Array';\n}\n\nfunction isInt16Array(value) {\n  return TypedArrayProto_toStringTag(value) === 'Int16Array';\n}\n\nfunction isInt32Array(value) {\n  return TypedArrayProto_toStringTag(value) === 'Int32Array';\n}\n\nfunction isFloat32Array(value) {\n  return TypedArrayProto_toStringTag(value) === 'Float32Array';\n}\n\nfunction isFloat64Array(value) {\n  return TypedArrayProto_toStringTag(value) === 'Float64Array';\n}\n\nfunction isBigInt64Array(value) {\n  return TypedArrayProto_toStringTag(value) === 'BigInt64Array';\n}\n\nfunction isBigUint64Array(value) {\n  return TypedArrayProto_toStringTag(value) === 'BigUint64Array';\n}\n\nmodule.exports = {\n  ...internalBinding('types'),\n  isArrayBufferView: ArrayBufferIsView,\n  isTypedArray,\n  isUint8Array,\n  isUint8ClampedArray,\n  isUint16Array,\n  isUint32Array,\n  isInt8Array,\n  isInt16Array,\n  isInt32Array,\n  isFloat32Array,\n  isFloat64Array,\n  isBigInt64Array,\n  isBigUint64Array\n};\n"
  },
  {
    "url": "internal/validators.js",
    "ranges": [
      {
        "start": 0,
        "end": 581
      },
      {
        "start": 640,
        "end": 642
      },
      {
        "start": 704,
        "end": 1326
      },
      {
        "start": 1807,
        "end": 1852
      },
      {
        "start": 2233,
        "end": 2279
      },
      {
        "start": 2860,
        "end": 2904
      },
      {
        "start": 3414,
        "end": 3552
      },
      {
        "start": 3684,
        "end": 3724
      },
      {
        "start": 4174,
        "end": 4178
      },
      {
        "start": 4313,
        "end": 4357
      },
      {
        "start": 4582,
        "end": 4624
      },
      {
        "start": 4911,
        "end": 4915
      },
      {
        "start": 5336,
        "end": 5377
      },
      {
        "start": 5607,
        "end": 5611
      },
      {
        "start": 5945,
        "end": 6089
      },
      {
        "start": 6463,
        "end": 6506
      },
      {
        "start": 6607,
        "end": 6930
      }
    ],
    "text": "'use strict';\n\nconst {\n  ArrayIsArray,\n  NumberIsInteger,\n  NumberMAX_SAFE_INTEGER,\n  NumberMIN_SAFE_INTEGER,\n  NumberParseInt,\n  String,\n} = primordials;\n\nconst {\n  hideStackFrames,\n  codes: {\n    ERR_SOCKET_BAD_PORT,\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_ARG_VALUE,\n    ERR_INVALID_OPT_VALUE,\n    ERR_OUT_OF_RANGE,\n    ERR_UNKNOWN_SIGNAL,\n    ERR_INVALID_CALLBACK,\n  }\n} = require('internal/errors');\nconst { normalizeEncoding } = require('internal/util');\nconst {\n  isArrayBufferView\n} = require('internal/util/types');\nconst { signals } = internalBinding('constants').os;\n\nfunction isInt32(value) {\n  return value === (value | 0);\n}\n\nfunction isUint32(value) {\n  return value === (value >>> 0);\n}\n\nconst octalReg = /^[0-7]+$/;\nconst modeDesc = 'must be a 32-bit unsigned integer or an octal string';\n\n/**\n * Parse and validate values that will be converted into mode_t (the S_*\n * constants). Only valid numbers and octal strings are allowed. They could be\n * converted to 32-bit unsigned integers or non-negative signed integers in the\n * C++ land, but any value higher than 0o777 will result in platform-specific\n * behaviors.\n *\n * @param {*} value Values to be validated\n * @param {string} name Name of the argument\n * @param {number} def If specified, will be returned for invalid values\n * @returns {number}\n */\nfunction parseFileMode(value, name, def) {\n  if (value == null && def !== undefined) {\n    return def;\n  }\n\n  if (isUint32(value)) {\n    return value;\n  }\n\n  if (typeof value === 'number') {\n    validateInt32(value, name, 0, 2 ** 32 - 1);\n  }\n\n  if (typeof value === 'string') {\n    if (!octalReg.test(value)) {\n      throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc);\n    }\n    return NumberParseInt(value, 8);\n  }\n\n  throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc);\n}\n\nconst validateInteger = hideStackFrames(\n  (value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {\n    if (typeof value !== 'number')\n      throw new ERR_INVALID_ARG_TYPE(name, 'number', value);\n    if (!NumberIsInteger(value))\n      throw new ERR_OUT_OF_RANGE(name, 'an integer', value);\n    if (value < min || value > max)\n      throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n  }\n);\n\nconst validateInt32 = hideStackFrames(\n  (value, name, min = -2147483648, max = 2147483647) => {\n    // The defaults for min and max correspond to the limits of 32-bit integers.\n    if (!isInt32(value)) {\n      if (typeof value !== 'number') {\n        throw new ERR_INVALID_ARG_TYPE(name, 'number', value);\n      }\n      if (!NumberIsInteger(value)) {\n        throw new ERR_OUT_OF_RANGE(name, 'an integer', value);\n      }\n      throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n    }\n    if (value < min || value > max) {\n      throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n    }\n  }\n);\n\nconst validateUint32 = hideStackFrames((value, name, positive) => {\n  if (!isUint32(value)) {\n    if (typeof value !== 'number') {\n      throw new ERR_INVALID_ARG_TYPE(name, 'number', value);\n    }\n    if (!NumberIsInteger(value)) {\n      throw new ERR_OUT_OF_RANGE(name, 'an integer', value);\n    }\n    const min = positive ? 1 : 0;\n    // 2 ** 32 === 4294967296\n    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && < 4294967296`, value);\n  }\n  if (positive && value === 0) {\n    throw new ERR_OUT_OF_RANGE(name, '>= 1 && < 4294967296', value);\n  }\n});\n\nfunction validateString(value, name) {\n  if (typeof value !== 'string')\n    throw new ERR_INVALID_ARG_TYPE(name, 'string', value);\n}\n\nfunction validateNumber(value, name) {\n  if (typeof value !== 'number')\n    throw new ERR_INVALID_ARG_TYPE(name, 'number', value);\n}\n\nconst validateOneOf = hideStackFrames((value, name, oneOf, option = false) => {\n  if (!oneOf.includes(value)) {\n    const allowed = oneOf\n      .map((v) => (typeof v === 'string' ? `'${v}'` : String(v)))\n      .join(', ');\n    if (!option) {\n      const reason = 'must be one of: ' + allowed;\n      throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n    } else {\n      const reason = 'Must be one of: ' + allowed;\n      throw new ERR_INVALID_OPT_VALUE(name, value, reason);\n    }\n  }\n});\n\nfunction validateBoolean(value, name) {\n  if (typeof value !== 'boolean')\n    throw new ERR_INVALID_ARG_TYPE(name, 'boolean', value);\n}\n\nconst validateObject = hideStackFrames(\n  (value, name, { nullable = false } = {}) => {\n    if ((!nullable && value === null) ||\n        ArrayIsArray(value) ||\n        typeof value !== 'object') {\n      throw new ERR_INVALID_ARG_TYPE(name, 'Object', value);\n    }\n  });\n\nconst validateArray = hideStackFrames((value, name, { minLength = 0 } = {}) => {\n  if (!ArrayIsArray(value)) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'Array', value);\n  }\n  if (value.length < minLength) {\n    const reason = `must be longer than ${minLength}`;\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n  }\n});\n\nfunction validateSignalName(signal, name = 'signal') {\n  if (typeof signal !== 'string')\n    throw new ERR_INVALID_ARG_TYPE(name, 'string', signal);\n\n  if (signals[signal] === undefined) {\n    if (signals[signal.toUpperCase()] !== undefined) {\n      throw new ERR_UNKNOWN_SIGNAL(signal +\n                                   ' (signals must use all capital letters)');\n    }\n\n    throw new ERR_UNKNOWN_SIGNAL(signal);\n  }\n}\n\nconst validateBuffer = hideStackFrames((buffer, name = 'buffer') => {\n  if (!isArrayBufferView(buffer)) {\n    throw new ERR_INVALID_ARG_TYPE(name,\n                                   ['Buffer', 'TypedArray', 'DataView'],\n                                   buffer);\n  }\n});\n\nfunction validateEncoding(data, encoding) {\n  const normalizedEncoding = normalizeEncoding(encoding);\n  const length = data.length;\n\n  if (normalizedEncoding === 'hex' && length % 2 !== 0) {\n    throw new ERR_INVALID_ARG_VALUE('encoding', encoding,\n                                    `is invalid for data of length ${length}`);\n  }\n}\n\n// Check that the port number is not NaN when coerced to a number,\n// is an integer and that it falls within the legal range of port numbers.\nfunction validatePort(port, name = 'Port', { allowZero = true } = {}) {\n  if ((typeof port !== 'number' && typeof port !== 'string') ||\n      (typeof port === 'string' && port.trim().length === 0) ||\n      +port !== (+port >>> 0) ||\n      port > 0xFFFF ||\n      (port === 0 && !allowZero)) {\n    throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);\n  }\n  return port | 0;\n}\n\nconst validateCallback = hideStackFrames((callback) => {\n  if (typeof callback !== 'function')\n    throw new ERR_INVALID_CALLBACK(callback);\n});\n\nmodule.exports = {\n  isInt32,\n  isUint32,\n  parseFileMode,\n  validateArray,\n  validateBoolean,\n  validateBuffer,\n  validateEncoding,\n  validateInt32,\n  validateInteger,\n  validateNumber,\n  validateObject,\n  validateOneOf,\n  validatePort,\n  validateSignalName,\n  validateString,\n  validateUint32,\n  validateCallback,\n};\n"
  },
  {
    "url": "internal/vm/module.js",
    "ranges": [
      {
        "start": 0,
        "end": 1618
      },
      {
        "start": 3804,
        "end": 3808
      },
      {
        "start": 3945,
        "end": 3949
      },
      {
        "start": 4082,
        "end": 4086
      },
      {
        "start": 4363,
        "end": 4367
      },
      {
        "start": 4520,
        "end": 4524
      },
      {
        "start": 4774,
        "end": 4778
      },
      {
        "start": 5257,
        "end": 5261
      },
      {
        "start": 6213,
        "end": 6217
      },
      {
        "start": 6945,
        "end": 7092
      },
      {
        "start": 7128,
        "end": 7133
      },
      {
        "start": 9452,
        "end": 9456
      },
      {
        "start": 9755,
        "end": 9759
      },
      {
        "start": 10028,
        "end": 10032
      },
      {
        "start": 10228,
        "end": 10232
      },
      {
        "start": 10494,
        "end": 10539
      },
      {
        "start": 11836,
        "end": 11840
      },
      {
        "start": 12142,
        "end": 12146
      },
      {
        "start": 12608,
        "end": 12730
      },
      {
        "start": 12765,
        "end": 12770
      }
    ],
    "text": "'use strict';\n\nconst assert = require('internal/assert');\nconst {\n  ArrayIsArray,\n  ArrayPrototypeForEach,\n  ArrayPrototypeIndexOf,\n  ArrayPrototypeSome,\n  ObjectCreate,\n  ObjectDefineProperty,\n  ObjectGetPrototypeOf,\n  ObjectSetPrototypeOf,\n  PromiseAll,\n  SafeWeakMap,\n  Symbol,\n  TypeError,\n} = primordials;\n\nconst { isContext } = internalBinding('contextify');\nconst {\n  isModuleNamespaceObject,\n  isArrayBufferView,\n} = require('internal/util/types');\nconst {\n  getConstructorOf,\n  customInspectSymbol,\n  emitExperimentalWarning,\n} = require('internal/util');\nconst {\n  ERR_INVALID_ARG_TYPE,\n  ERR_INVALID_ARG_VALUE,\n  ERR_VM_MODULE_ALREADY_LINKED,\n  ERR_VM_MODULE_DIFFERENT_CONTEXT,\n  ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA,\n  ERR_VM_MODULE_LINKING_ERRORED,\n  ERR_VM_MODULE_NOT_MODULE,\n  ERR_VM_MODULE_STATUS,\n} = require('internal/errors').codes;\nconst {\n  validateInt32,\n  validateUint32,\n  validateString,\n} = require('internal/validators');\n\nconst binding = internalBinding('module_wrap');\nconst {\n  ModuleWrap,\n  kUninstantiated,\n  kInstantiating,\n  kInstantiated,\n  kEvaluating,\n  kEvaluated,\n  kErrored,\n} = binding;\n\nconst STATUS_MAP = {\n  [kUninstantiated]: 'unlinked',\n  [kInstantiating]: 'linking',\n  [kInstantiated]: 'linked',\n  [kEvaluating]: 'evaluating',\n  [kEvaluated]: 'evaluated',\n  [kErrored]: 'errored',\n};\n\nlet globalModuleId = 0;\nconst defaultModuleName = 'vm:module';\nconst wrapToModuleMap = new SafeWeakMap();\n\nconst kWrap = Symbol('kWrap');\nconst kContext = Symbol('kContext');\nconst kPerContextModuleId = Symbol('kPerContextModuleId');\nconst kLink = Symbol('kLink');\n\nclass Module {\n  constructor(options) {\n    emitExperimentalWarning('VM Modules');\n\n    if (new.target === Module) {\n      // eslint-disable-next-line no-restricted-syntax\n      throw new TypeError('Module is not a constructor');\n    }\n\n    const {\n      context,\n      sourceText,\n      syntheticExportNames,\n      syntheticEvaluationSteps,\n    } = options;\n\n    if (context !== undefined) {\n      if (typeof context !== 'object' || context === null) {\n        throw new ERR_INVALID_ARG_TYPE('options.context', 'Object', context);\n      }\n      if (!isContext(context)) {\n        throw new ERR_INVALID_ARG_TYPE('options.context', 'vm.Context',\n                                       context);\n      }\n    }\n\n    let { identifier } = options;\n    if (identifier !== undefined) {\n      validateString(identifier, 'options.identifier');\n    } else if (context === undefined) {\n      identifier = `${defaultModuleName}(${globalModuleId++})`;\n    } else if (context[kPerContextModuleId] !== undefined) {\n      const curId = context[kPerContextModuleId];\n      identifier = `${defaultModuleName}(${curId})`;\n      context[kPerContextModuleId] += 1;\n    } else {\n      identifier = `${defaultModuleName}(0)`;\n      ObjectDefineProperty(context, kPerContextModuleId, {\n        value: 1,\n        writable: true,\n        enumerable: false,\n        configurable: true,\n      });\n    }\n\n    if (sourceText !== undefined) {\n      this[kWrap] = new ModuleWrap(identifier, context, sourceText,\n                                   options.lineOffset, options.columnOffset,\n                                   options.cachedData);\n\n      binding.callbackMap.set(this[kWrap], {\n        initializeImportMeta: options.initializeImportMeta,\n        importModuleDynamically: options.importModuleDynamically ?\n          importModuleDynamicallyWrap(options.importModuleDynamically) :\n          undefined,\n      });\n    } else {\n      assert(syntheticEvaluationSteps);\n      this[kWrap] = new ModuleWrap(identifier, context,\n                                   syntheticExportNames,\n                                   syntheticEvaluationSteps);\n    }\n\n    wrapToModuleMap.set(this[kWrap], this);\n\n    this[kContext] = context;\n  }\n\n  get identifier() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    return this[kWrap].url;\n  }\n\n  get context() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    return this[kContext];\n  }\n\n  get namespace() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this[kWrap].getStatus() < kInstantiated) {\n      throw new ERR_VM_MODULE_STATUS('must not be unlinked or linking');\n    }\n    return this[kWrap].getNamespace();\n  }\n\n  get status() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    return STATUS_MAP[this[kWrap].getStatus()];\n  }\n\n  get error() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this[kWrap].getStatus() !== kErrored) {\n      throw new ERR_VM_MODULE_STATUS('must be errored');\n    }\n    return this[kWrap].getError();\n  }\n\n  async link(linker) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (typeof linker !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE('linker', 'function', linker);\n    }\n    if (this.status === 'linked') {\n      throw new ERR_VM_MODULE_ALREADY_LINKED();\n    }\n    if (this.status !== 'unlinked') {\n      throw new ERR_VM_MODULE_STATUS('must be unlinked');\n    }\n    await this[kLink](linker);\n    this[kWrap].instantiate();\n  }\n\n  async evaluate(options = {}) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n\n    if (typeof options !== 'object' || options === null) {\n      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);\n    }\n\n    let timeout = options.timeout;\n    if (timeout === undefined) {\n      timeout = -1;\n    } else {\n      validateUint32(timeout, 'options.timeout', true);\n    }\n    const { breakOnSigint = false } = options;\n    if (typeof breakOnSigint !== 'boolean') {\n      throw new ERR_INVALID_ARG_TYPE('options.breakOnSigint', 'boolean',\n                                     breakOnSigint);\n    }\n    const status = this[kWrap].getStatus();\n    if (status !== kInstantiated &&\n        status !== kEvaluated &&\n        status !== kErrored) {\n      throw new ERR_VM_MODULE_STATUS(\n        'must be one of linked, evaluated, or errored'\n      );\n    }\n    await this[kWrap].evaluate(timeout, breakOnSigint);\n  }\n\n  [customInspectSymbol](depth, options) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (typeof depth === 'number' && depth < 0)\n      return this;\n\n    const constructor = getConstructorOf(this) || Module;\n    const o = ObjectCreate({ constructor });\n    o.status = this.status;\n    o.identifier = this.identifier;\n    o.context = this.context;\n\n    ObjectSetPrototypeOf(o, ObjectGetPrototypeOf(this));\n    ObjectDefineProperty(o, Symbol.toStringTag, {\n      value: constructor.name,\n      configurable: true\n    });\n\n    // Lazy to avoid circular dependency\n    const { inspect } = require('internal/util/inspect');\n    return inspect(o, { ...options, customInspect: false });\n  }\n}\n\nconst kDependencySpecifiers = Symbol('kDependencySpecifiers');\nconst kNoError = Symbol('kNoError');\n\nclass SourceTextModule extends Module {\n  #error = kNoError;\n  #statusOverride;\n\n  constructor(sourceText, options = {}) {\n    validateString(sourceText, 'sourceText');\n\n    if (typeof options !== 'object' || options === null) {\n      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);\n    }\n\n    const {\n      lineOffset = 0,\n      columnOffset = 0,\n      initializeImportMeta,\n      importModuleDynamically,\n      context,\n      identifier,\n      cachedData,\n    } = options;\n\n    validateInt32(lineOffset, 'options.lineOffset');\n    validateInt32(columnOffset, 'options.columnOffset');\n\n    if (initializeImportMeta !== undefined &&\n        typeof initializeImportMeta !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.initializeImportMeta', 'function', initializeImportMeta);\n    }\n\n    if (importModuleDynamically !== undefined &&\n        typeof importModuleDynamically !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.importModuleDynamically', 'function',\n        importModuleDynamically);\n    }\n\n    if (cachedData !== undefined && !isArrayBufferView(cachedData)) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.cachedData',\n        ['Buffer', 'TypedArray', 'DataView'],\n        cachedData\n      );\n    }\n\n    super({\n      sourceText,\n      context,\n      identifier,\n      lineOffset,\n      columnOffset,\n      cachedData,\n      initializeImportMeta,\n      importModuleDynamically,\n    });\n\n    this[kLink] = async (linker) => {\n      this.#statusOverride = 'linking';\n\n      const promises = this[kWrap].link(async (identifier) => {\n        const module = await linker(identifier, this);\n        if (module[kWrap] === undefined) {\n          throw new ERR_VM_MODULE_NOT_MODULE();\n        }\n        if (module.context !== this.context) {\n          throw new ERR_VM_MODULE_DIFFERENT_CONTEXT();\n        }\n        if (module.status === 'errored') {\n          throw new ERR_VM_MODULE_LINKING_ERRORED();\n        }\n        if (module.status === 'unlinked') {\n          await module[kLink](linker);\n        }\n        return module[kWrap];\n      });\n\n      try {\n        if (promises !== undefined) {\n          await PromiseAll(promises);\n        }\n      } catch (e) {\n        this.#error = e;\n        throw e;\n      } finally {\n        this.#statusOverride = undefined;\n      }\n    };\n\n    this[kDependencySpecifiers] = undefined;\n  }\n\n  get dependencySpecifiers() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this[kDependencySpecifiers] === undefined) {\n      this[kDependencySpecifiers] = this[kWrap].getStaticDependencySpecifiers();\n    }\n    return this[kDependencySpecifiers];\n  }\n\n  get status() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this.#error !== kNoError) {\n      return 'errored';\n    }\n    if (this.#statusOverride) {\n      return this.#statusOverride;\n    }\n    return super.status;\n  }\n\n  get error() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this.#error !== kNoError) {\n      return this.#error;\n    }\n    return super.error;\n  }\n\n  createCachedData() {\n    const { status } = this;\n    if (status === 'evaluating' ||\n        status === 'evaluated' ||\n        status === 'errored') {\n      throw new ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA();\n    }\n    return this[kWrap].createCachedData();\n  }\n}\n\nclass SyntheticModule extends Module {\n  constructor(exportNames, evaluateCallback, options = {}) {\n    if (!ArrayIsArray(exportNames) ||\n      ArrayPrototypeSome(exportNames, (e) => typeof e !== 'string')) {\n      throw new ERR_INVALID_ARG_TYPE('exportNames',\n                                     'Array of unique strings',\n                                     exportNames);\n    } else {\n      ArrayPrototypeForEach(exportNames, (name, i) => {\n        if (ArrayPrototypeIndexOf(exportNames, name, i + 1) !== -1) {\n          throw new ERR_INVALID_ARG_VALUE(`exportNames.${name}`,\n                                          name,\n                                          'is duplicated');\n        }\n      });\n    }\n    if (typeof evaluateCallback !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE('evaluateCallback', 'function',\n                                     evaluateCallback);\n    }\n\n    if (typeof options !== 'object' || options === null) {\n      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);\n    }\n\n    const { context, identifier } = options;\n\n    super({\n      syntheticExportNames: exportNames,\n      syntheticEvaluationSteps: evaluateCallback,\n      context,\n      identifier,\n    });\n\n    this[kLink] = () => this[kWrap].link(() => {\n      assert.fail('link callback should not be called');\n    });\n  }\n\n  setExport(name, value) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    validateString(name, 'name');\n    if (this[kWrap].getStatus() < kInstantiated) {\n      throw new ERR_VM_MODULE_STATUS('must be linked');\n    }\n    this[kWrap].setExport(name, value);\n  }\n}\n\nfunction importModuleDynamicallyWrap(importModuleDynamically) {\n  const importModuleDynamicallyWrapper = async (...args) => {\n    const m = await importModuleDynamically(...args);\n    if (isModuleNamespaceObject(m)) {\n      return m;\n    }\n    if (!m || m[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (m.status === 'errored') {\n      throw m.error;\n    }\n    return m.namespace;\n  };\n  return importModuleDynamicallyWrapper;\n}\n\nmodule.exports = {\n  Module,\n  SourceTextModule,\n  SyntheticModule,\n  importModuleDynamicallyWrap,\n  getModuleFromWrap: (wrap) => wrapToModuleMap.get(wrap),\n};\n"
  },
  {
    "url": "internal/worker/js_transferable.js",
    "ranges": [
      {
        "start": 0,
        "end": 585
      },
      {
        "start": 1087,
        "end": 1310
      }
    ],
    "text": "'use strict';\nconst { Error } = primordials;\nconst {\n  messaging_deserialize_symbol,\n  messaging_transfer_symbol,\n  messaging_clone_symbol,\n  messaging_transfer_list_symbol\n} = internalBinding('symbols');\nconst {\n  JSTransferable,\n  setDeserializerCreateObjectFunction\n} = internalBinding('messaging');\n\nfunction setup() {\n  // Register the handler that will be used when deserializing JS-based objects\n  // from .postMessage() calls. The format of `deserializeInfo` is generally\n  // 'module:Constructor', e.g. 'internal/fs/promises:FileHandle'.\n  setDeserializerCreateObjectFunction((deserializeInfo) => {\n    const [ module, ctor ] = deserializeInfo.split(':');\n    const Ctor = require(module)[ctor];\n    if (typeof Ctor !== 'function' ||\n        !(Ctor.prototype instanceof JSTransferable)) {\n      // Not one of the official errors because one should not be able to get\n      // here without messing with Node.js internals.\n      // eslint-disable-next-line no-restricted-syntax\n      throw new Error(`Unknown deserialize spec ${deserializeInfo}`);\n    }\n    return new Ctor();\n  });\n}\n\nmodule.exports = {\n  setup,\n  JSTransferable,\n  kClone: messaging_clone_symbol,\n  kDeserialize: messaging_deserialize_symbol,\n  kTransfer: messaging_transfer_symbol,\n  kTransferList: messaging_transfer_list_symbol\n};\n"
  },
  {
    "url": "module.js",
    "ranges": [
      {
        "start": 0,
        "end": 308
      }
    ],
    "text": "'use strict';\n\nconst { findSourceMap } = require('internal/source_map/source_map_cache');\nconst { Module } = require('internal/modules/cjs/loader');\nconst { SourceMap } = require('internal/source_map/source_map');\n\nModule.findSourceMap = findSourceMap;\nModule.SourceMap = SourceMap;\nmodule.exports = Module;\n"
  },
  {
    "url": "path.js",
    "ranges": [
      {
        "start": 0,
        "end": 1492
      },
      {
        "start": 1596,
        "end": 1677
      },
      {
        "start": 1847,
        "end": 3716
      },
      {
        "start": 4141,
        "end": 4195
      },
      {
        "start": 8598,
        "end": 8603
      },
      {
        "start": 11354,
        "end": 11359
      },
      {
        "start": 11727,
        "end": 11732
      },
      {
        "start": 13788,
        "end": 14002
      },
      {
        "start": 17476,
        "end": 17481
      },
      {
        "start": 18509,
        "end": 18514
      },
      {
        "start": 20842,
        "end": 20847
      },
      {
        "start": 23482,
        "end": 23487
      },
      {
        "start": 25496,
        "end": 25538
      },
      {
        "start": 30004,
        "end": 31024
      },
      {
        "start": 31599,
        "end": 31738
      },
      {
        "start": 32152,
        "end": 32157
      },
      {
        "start": 34367,
        "end": 35086
      },
      {
        "start": 37406,
        "end": 37411
      },
      {
        "start": 39069,
        "end": 39110
      },
      {
        "start": 41464,
        "end": 41803
      }
    ],
    "text": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst { ERR_INVALID_ARG_TYPE } = require('internal/errors').codes;\nconst {\n  CHAR_UPPERCASE_A,\n  CHAR_LOWERCASE_A,\n  CHAR_UPPERCASE_Z,\n  CHAR_LOWERCASE_Z,\n  CHAR_DOT,\n  CHAR_FORWARD_SLASH,\n  CHAR_BACKWARD_SLASH,\n  CHAR_COLON,\n  CHAR_QUESTION_MARK,\n} = require('internal/constants');\nconst { validateString } = require('internal/validators');\n\nfunction isPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\n\nfunction isPosixPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH;\n}\n\nfunction isWindowsDeviceRoot(code) {\n  return (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z) ||\n         (code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z);\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path, allowAboveRoot, separator, isPathSeparator) {\n  let res = '';\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = 0;\n  for (let i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (isPathSeparator(code))\n      break;\n    else\n      code = CHAR_FORWARD_SLASH;\n\n    if (isPathSeparator(code)) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 ||\n            res.charCodeAt(res.length - 1) !== CHAR_DOT ||\n            res.charCodeAt(res.length - 2) !== CHAR_DOT) {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf(separator);\n            if (lastSlashIndex === -1) {\n              res = '';\n              lastSegmentLength = 0;\n            } else {\n              res = res.slice(0, lastSlashIndex);\n              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n            }\n            lastSlash = i;\n            dots = 0;\n            continue;\n          } else if (res.length !== 0) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          res += res.length > 0 ? `${separator}..` : '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += `${separator}${path.slice(lastSlash + 1, i)}`;\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  if (pathObject === null || typeof pathObject !== 'object') {\n    throw new ERR_INVALID_ARG_TYPE('pathObject', 'Object', pathObject);\n  }\n  const dir = pathObject.dir || pathObject.root;\n  const base = pathObject.base ||\n    `${pathObject.name || ''}${pathObject.ext || ''}`;\n  if (!dir) {\n    return base;\n  }\n  return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\n\nconst win32 = {\n  // path.resolve([from ...], to)\n  resolve(...args) {\n    let resolvedDevice = '';\n    let resolvedTail = '';\n    let resolvedAbsolute = false;\n\n    for (let i = args.length - 1; i >= -1; i--) {\n      let path;\n      if (i >= 0) {\n        path = args[i];\n        validateString(path, 'path');\n\n        // Skip empty entries\n        if (path.length === 0) {\n          continue;\n        }\n      } else if (resolvedDevice.length === 0) {\n        path = process.cwd();\n      } else {\n        // Windows has the concept of drive-specific current working\n        // directories. If we've resolved a drive letter but not yet an\n        // absolute path, get cwd for that drive, or the process cwd if\n        // the drive cwd is not available. We're sure the device is not\n        // a UNC path at this points, because UNC paths are always absolute.\n        path = process.env[`=${resolvedDevice}`] || process.cwd();\n\n        // Verify that a cwd was found and that it actually points\n        // to our drive. If not, default to the drive's root.\n        if (path === undefined ||\n            (path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() &&\n            path.charCodeAt(2) === CHAR_BACKWARD_SLASH)) {\n          path = `${resolvedDevice}\\\\`;\n        }\n      }\n\n      const len = path.length;\n      let rootEnd = 0;\n      let device = '';\n      let isAbsolute = false;\n      const code = path.charCodeAt(0);\n\n      // Try to match a root\n      if (len === 1) {\n        if (isPathSeparator(code)) {\n          // `path` contains just a path separator\n          rootEnd = 1;\n          isAbsolute = true;\n        }\n      } else if (isPathSeparator(code)) {\n        // Possible UNC root\n\n        // If we started with a separator, we know we at least have an\n        // absolute path of some kind (UNC or otherwise)\n        isAbsolute = true;\n\n        if (isPathSeparator(path.charCodeAt(1))) {\n          // Matched double path separator at beginning\n          let j = 2;\n          let last = j;\n          // Match 1 or more non-path separators\n          while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            const firstPart = path.slice(last, j);\n            // Matched!\n            last = j;\n            // Match 1 or more path separators\n            while (j < len && isPathSeparator(path.charCodeAt(j))) {\n              j++;\n            }\n            if (j < len && j !== last) {\n              // Matched!\n              last = j;\n              // Match 1 or more non-path separators\n              while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                j++;\n              }\n              if (j === len || j !== last) {\n                // We matched a UNC root\n                device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n                rootEnd = j;\n              }\n            }\n          }\n        } else {\n          rootEnd = 1;\n        }\n      } else if (isWindowsDeviceRoot(code) &&\n                  path.charCodeAt(1) === CHAR_COLON) {\n        // Possible device root\n        device = path.slice(0, 2);\n        rootEnd = 2;\n        if (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n          // Treat separator following drive name as an absolute path\n          // indicator\n          isAbsolute = true;\n          rootEnd = 3;\n        }\n      }\n\n      if (device.length > 0) {\n        if (resolvedDevice.length > 0) {\n          if (device.toLowerCase() !== resolvedDevice.toLowerCase())\n            // This path points to another device so it is not applicable\n            continue;\n        } else {\n          resolvedDevice = device;\n        }\n      }\n\n      if (resolvedAbsolute) {\n        if (resolvedDevice.length > 0)\n          break;\n      } else {\n        resolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\n        resolvedAbsolute = isAbsolute;\n        if (isAbsolute && resolvedDevice.length > 0) {\n          break;\n        }\n      }\n    }\n\n    // At this point the path should be resolved to a full absolute path,\n    // but handle relative paths to be safe (might happen when process.cwd()\n    // fails)\n\n    // Normalize the tail path\n    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\',\n                                   isPathSeparator);\n\n    return resolvedAbsolute ?\n      `${resolvedDevice}\\\\${resolvedTail}` :\n      `${resolvedDevice}${resolvedTail}` || '.';\n  },\n\n  normalize(path) {\n    validateString(path, 'path');\n    const len = path.length;\n    if (len === 0)\n      return '.';\n    let rootEnd = 0;\n    let device;\n    let isAbsolute = false;\n    const code = path.charCodeAt(0);\n\n    // Try to match a root\n    if (len === 1) {\n      // `path` contains just a single char, exit early to avoid\n      // unnecessary work\n      return isPosixPathSeparator(code) ? '\\\\' : path;\n    }\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      // If we started with a separator, we know we at least have an absolute\n      // path of some kind (UNC or otherwise)\n      isAbsolute = true;\n\n      if (isPathSeparator(path.charCodeAt(1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          const firstPart = path.slice(last, j);\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len && isPathSeparator(path.charCodeAt(j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              // Return the normalized version of the UNC root since there\n              // is nothing left to process\n              return `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\n            }\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n              device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n              rootEnd = j;\n            }\n          }\n        }\n      } else {\n        rootEnd = 1;\n      }\n    } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n      // Possible device root\n      device = path.slice(0, 2);\n      rootEnd = 2;\n      if (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n        // Treat separator following drive name as an absolute path\n        // indicator\n        isAbsolute = true;\n        rootEnd = 3;\n      }\n    }\n\n    let tail = rootEnd < len ?\n      normalizeString(path.slice(rootEnd), !isAbsolute, '\\\\', isPathSeparator) :\n      '';\n    if (tail.length === 0 && !isAbsolute)\n      tail = '.';\n    if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1)))\n      tail += '\\\\';\n    if (device === undefined) {\n      return isAbsolute ? `\\\\${tail}` : tail;\n    }\n    return isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n  },\n\n  isAbsolute(path) {\n    validateString(path, 'path');\n    const len = path.length;\n    if (len === 0)\n      return false;\n\n    const code = path.charCodeAt(0);\n    return isPathSeparator(code) ||\n      // Possible device root\n      (len > 2 &&\n      isWindowsDeviceRoot(code) &&\n      path.charCodeAt(1) === CHAR_COLON &&\n      isPathSeparator(path.charCodeAt(2)));\n  },\n\n  join(...args) {\n    if (args.length === 0)\n      return '.';\n\n    let joined;\n    let firstPart;\n    for (let i = 0; i < args.length; ++i) {\n      const arg = args[i];\n      validateString(arg, 'path');\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = firstPart = arg;\n        else\n          joined += `\\\\${arg}`;\n      }\n    }\n\n    if (joined === undefined)\n      return '.';\n\n    // Make sure that the joined path doesn't start with two slashes, because\n    // normalize() will mistake it for a UNC path then.\n    //\n    // This step is skipped when it is very clear that the user actually\n    // intended to point at a UNC path. This is assumed when the first\n    // non-empty string arguments starts with exactly two slashes followed by\n    // at least one more non-slash character.\n    //\n    // Note that for normalize() to treat a path as a UNC path it needs to\n    // have at least 2 components, so we don't filter for that here.\n    // This means that the user can use join to construct UNC paths from\n    // a server name and a share name; for example:\n    //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n    let needsReplace = true;\n    let slashCount = 0;\n    if (isPathSeparator(firstPart.charCodeAt(0))) {\n      ++slashCount;\n      const firstLen = firstPart.length;\n      if (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {\n        ++slashCount;\n        if (firstLen > 2) {\n          if (isPathSeparator(firstPart.charCodeAt(2)))\n            ++slashCount;\n          else {\n            // We matched a UNC path in the first part\n            needsReplace = false;\n          }\n        }\n      }\n    }\n    if (needsReplace) {\n      // Find any more consecutive slashes we need to replace\n      while (slashCount < joined.length &&\n             isPathSeparator(joined.charCodeAt(slashCount))) {\n        slashCount++;\n      }\n\n      // Replace the slashes if needed\n      if (slashCount >= 2)\n        joined = `\\\\${joined.slice(slashCount)}`;\n    }\n\n    return win32.normalize(joined);\n  },\n\n  // It will solve the relative path from `from` to `to`, for instance:\n  //  from = 'C:\\\\orandea\\\\test\\\\aaa'\n  //  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n  // The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n  relative(from, to) {\n    validateString(from, 'from');\n    validateString(to, 'to');\n\n    if (from === to)\n      return '';\n\n    const fromOrig = win32.resolve(from);\n    const toOrig = win32.resolve(to);\n\n    if (fromOrig === toOrig)\n      return '';\n\n    from = fromOrig.toLowerCase();\n    to = toOrig.toLowerCase();\n\n    if (from === to)\n      return '';\n\n    // Trim any leading backslashes\n    let fromStart = 0;\n    while (fromStart < from.length &&\n           from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {\n      fromStart++;\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    let fromEnd = from.length;\n    while (fromEnd - 1 > fromStart &&\n           from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {\n      fromEnd--;\n    }\n    const fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    let toStart = 0;\n    while (toStart < to.length &&\n           to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n      toStart++;\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    let toEnd = to.length;\n    while (toEnd - 1 > toStart &&\n           to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {\n      toEnd--;\n    }\n    const toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    const length = fromLen < toLen ? fromLen : toLen;\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = from.charCodeAt(fromStart + i);\n      if (fromCode !== to.charCodeAt(toStart + i))\n        break;\n      else if (fromCode === CHAR_BACKWARD_SLASH)\n        lastCommonSep = i;\n    }\n\n    // We found a mismatch before the first common path separator was seen, so\n    // return the original `to`.\n    if (i !== length) {\n      if (lastCommonSep === -1)\n        return toOrig;\n    } else {\n      if (toLen > length) {\n        if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n          return toOrig.slice(toStart + i + 1);\n        }\n        if (i === 2) {\n          // We get here if `from` is the device root.\n          // For example: from='C:\\\\'; to='C:\\\\foo'\n          return toOrig.slice(toStart + i);\n        }\n      }\n      if (fromLen > length) {\n        if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n          lastCommonSep = i;\n        } else if (i === 2) {\n          // We get here if `to` is the device root.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n          lastCommonSep = 3;\n        }\n      }\n      if (lastCommonSep === -1)\n        lastCommonSep = 0;\n    }\n\n    let out = '';\n    // Generate the relative path based on the path difference between `to` and\n    // `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n        out += out.length === 0 ? '..' : '\\\\..';\n      }\n    }\n\n    toStart += lastCommonSep;\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return `${out}${toOrig.slice(toStart, toEnd)}`;\n\n    if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH)\n      ++toStart;\n    return toOrig.slice(toStart, toEnd);\n  },\n\n  toNamespacedPath(path) {\n    // Note: this will *probably* throw somewhere.\n    if (typeof path !== 'string')\n      return path;\n\n    if (path.length === 0) {\n      return '';\n    }\n\n    const resolvedPath = win32.resolve(path);\n\n    if (resolvedPath.length <= 2)\n      return path;\n\n    if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n      // Possible UNC root\n      if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n        const code = resolvedPath.charCodeAt(2);\n        if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n          // Matched non-long UNC root, convert the path to a long UNC path\n          return `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\n        }\n      }\n    } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) &&\n               resolvedPath.charCodeAt(1) === CHAR_COLON &&\n               resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n      // Matched device root, convert the path to a long UNC path\n      return `\\\\\\\\?\\\\${resolvedPath}`;\n    }\n\n    return path;\n  },\n\n  dirname(path) {\n    validateString(path, 'path');\n    const len = path.length;\n    if (len === 0)\n      return '.';\n    let rootEnd = -1;\n    let offset = 0;\n    const code = path.charCodeAt(0);\n\n    if (len === 1) {\n      // `path` contains just a path separator, exit early to avoid\n      // unnecessary work or a dot.\n      return isPathSeparator(code) ? path : '.';\n    }\n\n    // Try to match a root\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      rootEnd = offset = 1;\n\n      if (isPathSeparator(path.charCodeAt(1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len && isPathSeparator(path.charCodeAt(j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              return path;\n            }\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n\n              // Offset by 1 to include the separator after the UNC root to\n              // treat it as a \"normal root\" on top of a (UNC) root\n              rootEnd = offset = j + 1;\n            }\n          }\n        }\n      }\n    // Possible device root\n    } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n      rootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;\n      offset = rootEnd;\n    }\n\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = len - 1; i >= offset; --i) {\n      if (isPathSeparator(path.charCodeAt(i))) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) {\n      if (rootEnd === -1)\n        return '.';\n\n      end = rootEnd;\n    }\n    return path.slice(0, end);\n  },\n\n  basename(path, ext) {\n    if (ext !== undefined)\n      validateString(ext, 'ext');\n    validateString(path, 'path');\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n\n    // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n    if (path.length >= 2 &&\n        isWindowsDeviceRoot(path.charCodeAt(0)) &&\n        path.charCodeAt(1) === CHAR_COLON) {\n      start = 2;\n    }\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext === path)\n        return '';\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (let i = path.length - 1; i >= start; --i) {\n        const code = path.charCodeAt(i);\n        if (isPathSeparator(code)) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path.length;\n      return path.slice(start, end);\n    }\n    for (let i = path.length - 1; i >= start; --i) {\n      if (isPathSeparator(path.charCodeAt(i))) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1)\n      return '';\n    return path.slice(start, end);\n  },\n\n  extname(path) {\n    validateString(path, 'path');\n    let start = 0;\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n\n    if (path.length >= 2 &&\n        path.charCodeAt(1) === CHAR_COLON &&\n        isWindowsDeviceRoot(path.charCodeAt(0))) {\n      start = startPart = 2;\n    }\n\n    for (let i = path.length - 1; i >= start; --i) {\n      const code = path.charCodeAt(i);\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: _format.bind(null, '\\\\'),\n\n  parse(path) {\n    validateString(path, 'path');\n\n    const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0)\n      return ret;\n\n    const len = path.length;\n    let rootEnd = 0;\n    let code = path.charCodeAt(0);\n\n    if (len === 1) {\n      if (isPathSeparator(code)) {\n        // `path` contains just a path separator, exit early to avoid\n        // unnecessary work\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      ret.base = ret.name = path;\n      return ret;\n    }\n    // Try to match a root\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      rootEnd = 1;\n      if (isPathSeparator(path.charCodeAt(1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len && isPathSeparator(path.charCodeAt(j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              rootEnd = j;\n            } else if (j !== last) {\n              // We matched a UNC root with leftovers\n              rootEnd = j + 1;\n            }\n          }\n        }\n      }\n    } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n      // Possible device root\n      if (len <= 2) {\n        // `path` contains just a drive root, exit early to avoid\n        // unnecessary work\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      rootEnd = 2;\n      if (isPathSeparator(path.charCodeAt(2))) {\n        if (len === 3) {\n          // `path` contains just a drive root, exit early to avoid\n          // unnecessary work\n          ret.root = ret.dir = path;\n          return ret;\n        }\n        rootEnd = 3;\n      }\n    }\n    if (rootEnd > 0)\n      ret.root = path.slice(0, rootEnd);\n\n    let startDot = -1;\n    let startPart = rootEnd;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= rootEnd; --i) {\n      code = path.charCodeAt(i);\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (end !== -1) {\n      if (startDot === -1 ||\n          // We saw a non-dot character immediately before the dot\n          preDotState === 0 ||\n          // The (right-most) trimmed path component is exactly '..'\n          (preDotState === 1 &&\n           startDot === end - 1 &&\n           startDot === startPart + 1)) {\n        ret.base = ret.name = path.slice(startPart, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n        ret.ext = path.slice(startDot, end);\n      }\n    }\n\n    // If the directory is the root, use the entire root as the `dir` including\n    // the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n    // trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n    if (startPart > 0 && startPart !== rootEnd)\n      ret.dir = path.slice(0, startPart - 1);\n    else\n      ret.dir = ret.root;\n\n    return ret;\n  },\n\n  sep: '\\\\',\n  delimiter: ';',\n  win32: null,\n  posix: null\n};\n\nconst posix = {\n  // path.resolve([from ...], to)\n  resolve(...args) {\n    let resolvedPath = '';\n    let resolvedAbsolute = false;\n\n    for (let i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      const path = i >= 0 ? args[i] : process.cwd();\n\n      validateString(path, 'path');\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = `${path}/${resolvedPath}`;\n      resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/',\n                                   isPosixPathSeparator);\n\n    if (resolvedAbsolute) {\n      return `/${resolvedPath}`;\n    }\n    return resolvedPath.length > 0 ? resolvedPath : '.';\n  },\n\n  normalize(path) {\n    validateString(path, 'path');\n\n    if (path.length === 0)\n      return '.';\n\n    const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    const trailingSeparator =\n      path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n\n    // Normalize the path\n    path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n\n    if (path.length === 0) {\n      if (isAbsolute)\n        return '/';\n      return trailingSeparator ? './' : '.';\n    }\n    if (trailingSeparator)\n      path += '/';\n\n    return isAbsolute ? `/${path}` : path;\n  },\n\n  isAbsolute(path) {\n    validateString(path, 'path');\n    return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n  },\n\n  join(...args) {\n    if (args.length === 0)\n      return '.';\n    let joined;\n    for (let i = 0; i < args.length; ++i) {\n      const arg = args[i];\n      validateString(arg, 'path');\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += `/${arg}`;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative(from, to) {\n    validateString(from, 'from');\n    validateString(to, 'to');\n\n    if (from === to)\n      return '';\n\n    // Trim leading forward slashes.\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to)\n      return '';\n\n    const fromStart = 1;\n    const fromEnd = from.length;\n    const fromLen = fromEnd - fromStart;\n    const toStart = 1;\n    const toLen = to.length - toStart;\n\n    // Compare paths to find the longest common path from root\n    const length = (fromLen < toLen ? fromLen : toLen);\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = from.charCodeAt(fromStart + i);\n      if (fromCode !== to.charCodeAt(toStart + i))\n        break;\n      else if (fromCode === CHAR_FORWARD_SLASH)\n        lastCommonSep = i;\n    }\n    if (i === length) {\n      if (toLen > length) {\n        if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='/foo/bar'; to='/foo/bar/baz'\n          return to.slice(toStart + i + 1);\n        }\n        if (i === 0) {\n          // We get here if `from` is the root\n          // For example: from='/'; to='/foo'\n          return to.slice(toStart + i);\n        }\n      } else if (fromLen > length) {\n        if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='/foo/bar/baz'; to='/foo/bar'\n          lastCommonSep = i;\n        } else if (i === 0) {\n          // We get here if `to` is the root.\n          // For example: from='/foo/bar'; to='/'\n          lastCommonSep = 0;\n        }\n      }\n    }\n\n    let out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`.\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        out += out.length === 0 ? '..' : '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts.\n    return `${out}${to.slice(toStart + lastCommonSep)}`;\n  },\n\n  toNamespacedPath(path) {\n    // Non-op on posix systems\n    return path;\n  },\n\n  dirname(path) {\n    validateString(path, 'path');\n    if (path.length === 0)\n      return '.';\n    const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = path.length - 1; i >= 1; --i) {\n      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1)\n      return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1)\n      return '//';\n    return path.slice(0, end);\n  },\n\n  basename(path, ext) {\n    if (ext !== undefined)\n      validateString(ext, 'ext');\n    validateString(path, 'path');\n\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext === path)\n        return '';\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (let i = path.length - 1; i >= 0; --i) {\n        const code = path.charCodeAt(i);\n        if (code === CHAR_FORWARD_SLASH) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path.length;\n      return path.slice(start, end);\n    }\n    for (let i = path.length - 1; i >= 0; --i) {\n      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1)\n      return '';\n    return path.slice(start, end);\n  },\n\n  extname(path) {\n    validateString(path, 'path');\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n    for (let i = path.length - 1; i >= 0; --i) {\n      const code = path.charCodeAt(i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: _format.bind(null, '/'),\n\n  parse(path) {\n    validateString(path, 'path');\n\n    const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0)\n      return ret;\n    const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    let start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      const code = path.charCodeAt(i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (end !== -1) {\n      const start = startPart === 0 && isAbsolute ? 1 : startPart;\n      if (startDot === -1 ||\n          // We saw a non-dot character immediately before the dot\n          preDotState === 0 ||\n          // The (right-most) trimmed path component is exactly '..'\n          (preDotState === 1 &&\n          startDot === end - 1 &&\n          startDot === startPart + 1)) {\n        ret.base = ret.name = path.slice(start, end);\n      } else {\n        ret.name = path.slice(start, startDot);\n        ret.base = path.slice(start, end);\n        ret.ext = path.slice(startDot, end);\n      }\n    }\n\n    if (startPart > 0)\n      ret.dir = path.slice(0, startPart - 1);\n    else if (isAbsolute)\n      ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\n\n// Legacy internal API, docs-only deprecated: DEP0080\nwin32._makeLong = win32.toNamespacedPath;\nposix._makeLong = posix.toNamespacedPath;\n\nmodule.exports = process.platform === 'win32' ? win32 : posix;\n"
  },
  {
    "url": "timers.js",
    "ranges": [
      {
        "start": 0,
        "end": 1805
      },
      {
        "start": 1830,
        "end": 2306
      },
      {
        "start": 3490,
        "end": 3697
      },
      {
        "start": 3950,
        "end": 3982
      },
      {
        "start": 4627,
        "end": 4659
      },
      {
        "start": 4892,
        "end": 4895
      },
      {
        "start": 5261,
        "end": 5263
      },
      {
        "start": 5910,
        "end": 5912
      },
      {
        "start": 6210,
        "end": 6238
      },
      {
        "start": 6289,
        "end": 6331
      },
      {
        "start": 6492,
        "end": 6533
      },
      {
        "start": 6855,
        "end": 6859
      },
      {
        "start": 7032,
        "end": 7036
      },
      {
        "start": 7212,
        "end": 7216
      },
      {
        "start": 7257,
        "end": 7262
      },
      {
        "start": 7803,
        "end": 7837
      },
      {
        "start": 7924,
        "end": 7927
      },
      {
        "start": 8349,
        "end": 8988
      }
    ],
    "text": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ObjectCreate,\n  MathTrunc,\n  Promise,\n  SymbolToPrimitive\n} = primordials;\n\nconst {\n  immediateInfo,\n  toggleImmediateRef\n} = internalBinding('timers');\nconst L = require('internal/linkedlist');\nconst {\n  async_id_symbol,\n  Timeout,\n  decRefCount,\n  immediateInfoFields: {\n    kCount,\n    kRefCount\n  },\n  kRefed,\n  kHasPrimitive,\n  initAsyncResource,\n  getTimerDuration,\n  timerListMap,\n  timerListQueue,\n  immediateQueue,\n  active,\n  unrefActive,\n  insert\n} = require('internal/timers');\nconst {\n  promisify: { custom: customPromisify },\n  deprecate\n} = require('internal/util');\nlet debug = require('internal/util/debuglog').debuglog('timer', (fn) => {\n  debug = fn;\n});\nconst { validateCallback } = require('internal/validators');\n\nconst {\n  destroyHooksExist,\n  // The needed emit*() functions.\n  emitDestroy\n} = require('internal/async_hooks');\n\n// This stores all the known timer async ids to allow users to clearTimeout and\n// clearInterval using those ids, to match the spec and the rest of the web\n// platform.\nconst knownTimersById = ObjectCreate(null);\n\n// Remove a timer. Cancels the timeout and resets the relevant timer properties.\nfunction unenroll(item) {\n  if (item._destroyed)\n    return;\n\n  item._destroyed = true;\n\n  if (item[kHasPrimitive])\n    delete knownTimersById[item[async_id_symbol]];\n\n  // Fewer checks may be possible, but these cover everything.\n  if (destroyHooksExist() && item[async_id_symbol] !== undefined)\n    emitDestroy(item[async_id_symbol]);\n\n  L.remove(item);\n\n  // We only delete refed lists because unrefed ones are incredibly likely\n  // to come from http and be recreated shortly after.\n  // TODO: Long-term this could instead be handled by creating an internal\n  // clearTimeout that makes it clear that the list should not be deleted.\n  // That function could then be used by http and other similar modules.\n  if (item[kRefed]) {\n    // Compliment truncation during insert().\n    const msecs = MathTrunc(item._idleTimeout);\n    const list = timerListMap[msecs];\n    if (list !== undefined && L.isEmpty(list)) {\n      debug('unenroll: list empty');\n      timerListQueue.removeAt(list.priorityQueuePosition);\n      delete timerListMap[list.msecs];\n    }\n\n    decRefCount();\n  }\n\n  // If active is called later, then we want to make sure not to insert again\n  item._idleTimeout = -1;\n}\n\n// Make a regular object able to act as a timer by setting some properties.\n// This function does not start the timer, see `active()`.\n// Using existing objects as timers slightly reduces object overhead.\nfunction enroll(item, msecs) {\n  msecs = getTimerDuration(msecs, 'msecs');\n\n  // If this item was already in a list somewhere\n  // then we should unenroll it from that\n  if (item._idleNext) unenroll(item);\n\n  L.init(item);\n  item._idleTimeout = msecs;\n}\n\n\n/*\n * DOM-style timers\n */\n\n\nfunction setTimeout(callback, after, arg1, arg2, arg3) {\n  validateCallback(callback);\n\n  let i, args;\n  switch (arguments.length) {\n    // fast cases\n    case 1:\n    case 2:\n      break;\n    case 3:\n      args = [arg1];\n      break;\n    case 4:\n      args = [arg1, arg2];\n      break;\n    default:\n      args = [arg1, arg2, arg3];\n      for (i = 5; i < arguments.length; i++) {\n        // Extend array dynamically, makes .apply run much faster in v6.0.0\n        args[i - 2] = arguments[i];\n      }\n      break;\n  }\n\n  const timeout = new Timeout(callback, after, args, false, true);\n  insert(timeout, timeout._idleTimeout);\n\n  return timeout;\n}\n\nsetTimeout[customPromisify] = function(after, value) {\n  const args = value !== undefined ? [value] : value;\n  return new Promise((resolve) => {\n    const timeout = new Timeout(resolve, after, args, false, true);\n    insert(timeout, timeout._idleTimeout);\n  });\n};\n\nfunction clearTimeout(timer) {\n  if (timer && timer._onTimeout) {\n    timer._onTimeout = null;\n    unenroll(timer);\n    return;\n  }\n  if (typeof timer === 'number' || typeof timer === 'string') {\n    const timerInstance = knownTimersById[timer];\n    if (timerInstance !== undefined) {\n      timerInstance._onTimeout = null;\n      unenroll(timerInstance);\n    }\n  }\n}\n\nfunction setInterval(callback, repeat, arg1, arg2, arg3) {\n  validateCallback(callback);\n\n  let i, args;\n  switch (arguments.length) {\n    // fast cases\n    case 1:\n    case 2:\n      break;\n    case 3:\n      args = [arg1];\n      break;\n    case 4:\n      args = [arg1, arg2];\n      break;\n    default:\n      args = [arg1, arg2, arg3];\n      for (i = 5; i < arguments.length; i++) {\n        // Extend array dynamically, makes .apply run much faster in v6.0.0\n        args[i - 2] = arguments[i];\n      }\n      break;\n  }\n\n  const timeout = new Timeout(callback, repeat, args, true, true);\n  insert(timeout, timeout._idleTimeout);\n\n  return timeout;\n}\n\nfunction clearInterval(timer) {\n  // clearTimeout and clearInterval can be used to clear timers created from\n  // both setTimeout and setInterval, as specified by HTML Living Standard:\n  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval\n  clearTimeout(timer);\n}\n\nTimeout.prototype.close = function() {\n  clearTimeout(this);\n  return this;\n};\n\nTimeout.prototype[SymbolToPrimitive] = function() {\n  const id = this[async_id_symbol];\n  if (!this[kHasPrimitive]) {\n    this[kHasPrimitive] = true;\n    knownTimersById[id] = this;\n  }\n  return id;\n};\n\nconst Immediate = class Immediate {\n  constructor(callback, args) {\n    this._idleNext = null;\n    this._idlePrev = null;\n    this._onImmediate = callback;\n    this._argv = args;\n    this._destroyed = false;\n    this[kRefed] = false;\n\n    initAsyncResource(this, 'Immediate');\n\n    this.ref();\n    immediateInfo[kCount]++;\n\n    immediateQueue.append(this);\n  }\n\n  ref() {\n    if (this[kRefed] === false) {\n      this[kRefed] = true;\n      if (immediateInfo[kRefCount]++ === 0)\n        toggleImmediateRef(true);\n    }\n    return this;\n  }\n\n  unref() {\n    if (this[kRefed] === true) {\n      this[kRefed] = false;\n      if (--immediateInfo[kRefCount] === 0)\n        toggleImmediateRef(false);\n    }\n    return this;\n  }\n\n  hasRef() {\n    return !!this[kRefed];\n  }\n};\n\nfunction setImmediate(callback, arg1, arg2, arg3) {\n  validateCallback(callback);\n\n  let i, args;\n  switch (arguments.length) {\n    // fast cases\n    case 1:\n      break;\n    case 2:\n      args = [arg1];\n      break;\n    case 3:\n      args = [arg1, arg2];\n      break;\n    default:\n      args = [arg1, arg2, arg3];\n      for (i = 4; i < arguments.length; i++) {\n        // Extend array dynamically, makes .apply run much faster in v6.0.0\n        args[i - 1] = arguments[i];\n      }\n      break;\n  }\n\n  return new Immediate(callback, args);\n}\n\nsetImmediate[customPromisify] = function(value) {\n  return new Promise((resolve) => new Immediate(resolve, [value]));\n};\n\nfunction clearImmediate(immediate) {\n  if (!immediate || immediate._destroyed)\n    return;\n\n  immediateInfo[kCount]--;\n  immediate._destroyed = true;\n\n  if (immediate[kRefed] && --immediateInfo[kRefCount] === 0)\n    toggleImmediateRef(false);\n  immediate[kRefed] = null;\n\n  if (destroyHooksExist()) {\n    emitDestroy(immediate[async_id_symbol]);\n  }\n\n  immediate._onImmediate = null;\n\n  immediateQueue.remove(immediate);\n}\n\nmodule.exports = {\n  setTimeout,\n  clearTimeout,\n  setImmediate,\n  clearImmediate,\n  setInterval,\n  clearInterval,\n  _unrefActive: deprecate(\n    unrefActive,\n    'timers._unrefActive() is deprecated.' +\n    ' Please use timeout.refresh() instead.',\n    'DEP0127'),\n  active: deprecate(\n    active,\n    'timers.active() is deprecated. Please use timeout.refresh() instead.',\n    'DEP0126'),\n  unenroll: deprecate(\n    unenroll,\n    'timers.unenroll() is deprecated. Please use clearTimeout instead.',\n    'DEP0096'),\n  enroll: deprecate(\n    enroll,\n    'timers.enroll() is deprecated. Please use setTimeout instead.',\n    'DEP0095')\n};\n"
  },
  {
    "url": "url.js",
    "ranges": [
      {
        "start": 0,
        "end": 1850
      },
      {
        "start": 2126,
        "end": 3804
      },
      {
        "start": 4018,
        "end": 4042
      },
      {
        "start": 13470,
        "end": 13473
      },
      {
        "start": 14198,
        "end": 15254
      },
      {
        "start": 15960,
        "end": 16006
      },
      {
        "start": 16716,
        "end": 17423
      },
      {
        "start": 19839,
        "end": 19842
      },
      {
        "start": 19941,
        "end": 19967
      },
      {
        "start": 20068,
        "end": 20071
      },
      {
        "start": 20214,
        "end": 20246
      },
      {
        "start": 29365,
        "end": 29394
      },
      {
        "start": 29667,
        "end": 29943
      }
    ],
    "text": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  Int8Array,\n  ObjectCreate,\n  ObjectKeys,\n  SafeSet,\n} = primordials;\n\nconst { toASCII } = require('internal/idna');\nconst { encodeStr, hexTable } = require('internal/querystring');\n\nconst {\n  ERR_INVALID_ARG_TYPE\n} = require('internal/errors').codes;\nconst { validateString } = require('internal/validators');\n\n// This ensures setURLConstructor() is called before the native\n// URL::ToObject() method is used.\nconst { spliceOne } = require('internal/util');\n\n// WHATWG URL implementation provided by internal/url\nconst {\n  URL,\n  URLSearchParams,\n  domainToASCII,\n  domainToUnicode,\n  formatSymbol,\n  pathToFileURL,\n  fileURLToPath\n} = require('internal/url');\n\n// Original url.parse() API\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nconst protocolPattern = /^[a-z0-9.+-]+:/i;\nconst portPattern = /:[0-9]*$/;\nconst hostPattern = /^\\/\\/[^@/]+@[^@/]+/;\n\n// Special case for a simple path URL\nconst simplePathPattern = /^(\\/\\/?(?!\\/)[^?\\s]*)(\\?[^\\s]*)?$/;\n\nconst hostnameMaxLen = 255;\n// Protocols that can allow \"unsafe\" and \"unwise\" chars.\nconst unsafeProtocol = new SafeSet([\n  'javascript',\n  'javascript:'\n]);\n// Protocols that never have a hostname.\nconst hostlessProtocol = new SafeSet([\n  'javascript',\n  'javascript:'\n]);\n// Protocols that always contain a // bit.\nconst slashedProtocol = new SafeSet([\n  'http',\n  'http:',\n  'https',\n  'https:',\n  'ftp',\n  'ftp:',\n  'gopher',\n  'gopher:',\n  'file',\n  'file:',\n  'ws',\n  'ws:',\n  'wss',\n  'wss:'\n]);\nconst {\n  CHAR_SPACE,\n  CHAR_TAB,\n  CHAR_CARRIAGE_RETURN,\n  CHAR_LINE_FEED,\n  CHAR_FORM_FEED,\n  CHAR_NO_BREAK_SPACE,\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE,\n  CHAR_HASH,\n  CHAR_FORWARD_SLASH,\n  CHAR_LEFT_SQUARE_BRACKET,\n  CHAR_RIGHT_SQUARE_BRACKET,\n  CHAR_LEFT_ANGLE_BRACKET,\n  CHAR_RIGHT_ANGLE_BRACKET,\n  CHAR_LEFT_CURLY_BRACKET,\n  CHAR_RIGHT_CURLY_BRACKET,\n  CHAR_QUESTION_MARK,\n  CHAR_LOWERCASE_A,\n  CHAR_LOWERCASE_Z,\n  CHAR_UPPERCASE_A,\n  CHAR_UPPERCASE_Z,\n  CHAR_DOT,\n  CHAR_0,\n  CHAR_9,\n  CHAR_HYPHEN_MINUS,\n  CHAR_PLUS,\n  CHAR_UNDERSCORE,\n  CHAR_DOUBLE_QUOTE,\n  CHAR_SINGLE_QUOTE,\n  CHAR_PERCENT,\n  CHAR_SEMICOLON,\n  CHAR_BACKWARD_SLASH,\n  CHAR_CIRCUMFLEX_ACCENT,\n  CHAR_GRAVE_ACCENT,\n  CHAR_VERTICAL_LINE,\n  CHAR_AT,\n} = require('internal/constants');\n\n// Lazy loaded for startup performance.\nlet querystring;\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url instanceof Url) return url;\n\n  const urlObject = new Url();\n  urlObject.parse(url, parseQueryString, slashesDenoteHost);\n  return urlObject;\n}\n\nUrl.prototype.parse = function parse(url, parseQueryString, slashesDenoteHost) {\n  validateString(url, 'url');\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  let hasHash = false;\n  let start = -1;\n  let end = -1;\n  let rest = '';\n  let lastPos = 0;\n  for (let i = 0, inWs = false, split = false; i < url.length; ++i) {\n    const code = url.charCodeAt(i);\n\n    // Find first and last non-whitespace characters for trimming\n    const isWs = code === CHAR_SPACE ||\n                 code === CHAR_TAB ||\n                 code === CHAR_CARRIAGE_RETURN ||\n                 code === CHAR_LINE_FEED ||\n                 code === CHAR_FORM_FEED ||\n                 code === CHAR_NO_BREAK_SPACE ||\n                 code === CHAR_ZERO_WIDTH_NOBREAK_SPACE;\n    if (start === -1) {\n      if (isWs)\n        continue;\n      lastPos = start = i;\n    } else if (inWs) {\n      if (!isWs) {\n        end = -1;\n        inWs = false;\n      }\n    } else if (isWs) {\n      end = i;\n      inWs = true;\n    }\n\n    // Only convert backslashes while we haven't seen a split character\n    if (!split) {\n      switch (code) {\n        case CHAR_HASH:\n          hasHash = true;\n        // Fall through\n        case CHAR_QUESTION_MARK:\n          split = true;\n          break;\n        case CHAR_BACKWARD_SLASH:\n          if (i - lastPos > 0)\n            rest += url.slice(lastPos, i);\n          rest += '/';\n          lastPos = i + 1;\n          break;\n      }\n    } else if (!hasHash && code === CHAR_HASH) {\n      hasHash = true;\n    }\n  }\n\n  // Check if string was non-empty (including strings with only whitespace)\n  if (start !== -1) {\n    if (lastPos === start) {\n      // We didn't convert any backslashes\n\n      if (end === -1) {\n        if (start === 0)\n          rest = url;\n        else\n          rest = url.slice(start);\n      } else {\n        rest = url.slice(start, end);\n      }\n    } else if (end === -1 && lastPos < url.length) {\n      // We converted some backslashes and have only part of the entire string\n      rest += url.slice(lastPos);\n    } else if (end !== -1 && lastPos < end) {\n      // We converted some backslashes and have only part of the entire string\n      rest += url.slice(lastPos, end);\n    }\n  }\n\n  if (!slashesDenoteHost && !hasHash) {\n    // Try fast path regexp\n    const simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          if (querystring === undefined) querystring = require('querystring');\n          this.query = querystring.parse(this.search.slice(1));\n        } else {\n          this.query = this.search.slice(1);\n        }\n      } else if (parseQueryString) {\n        this.search = null;\n        this.query = ObjectCreate(null);\n      }\n      return this;\n    }\n  }\n\n  let proto = protocolPattern.exec(rest);\n  let lowerProto;\n  if (proto) {\n    proto = proto[0];\n    lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.slice(proto.length);\n  }\n\n  // Figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  let slashes;\n  if (slashesDenoteHost || proto || hostPattern.test(rest)) {\n    slashes = rest.charCodeAt(0) === CHAR_FORWARD_SLASH &&\n              rest.charCodeAt(1) === CHAR_FORWARD_SLASH;\n    if (slashes && !(proto && hostlessProtocol.has(lowerProto))) {\n      rest = rest.slice(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol.has(lowerProto) &&\n      (slashes || (proto && !slashedProtocol.has(proto)))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:b path:/?@c\n\n    let hostEnd = -1;\n    let atSign = -1;\n    let nonHost = -1;\n    for (let i = 0; i < rest.length; ++i) {\n      switch (rest.charCodeAt(i)) {\n        case CHAR_TAB:\n        case CHAR_LINE_FEED:\n        case CHAR_CARRIAGE_RETURN:\n        case CHAR_SPACE:\n        case CHAR_DOUBLE_QUOTE:\n        case CHAR_PERCENT:\n        case CHAR_SINGLE_QUOTE:\n        case CHAR_SEMICOLON:\n        case CHAR_LEFT_ANGLE_BRACKET:\n        case CHAR_RIGHT_ANGLE_BRACKET:\n        case CHAR_BACKWARD_SLASH:\n        case CHAR_CIRCUMFLEX_ACCENT:\n        case CHAR_GRAVE_ACCENT:\n        case CHAR_LEFT_CURLY_BRACKET:\n        case CHAR_VERTICAL_LINE:\n        case CHAR_RIGHT_CURLY_BRACKET:\n          // Characters that are never ever allowed in a hostname from RFC 2396\n          if (nonHost === -1)\n            nonHost = i;\n          break;\n        case CHAR_HASH:\n        case CHAR_FORWARD_SLASH:\n        case CHAR_QUESTION_MARK:\n          // Find the first instance of any host-ending characters\n          if (nonHost === -1)\n            nonHost = i;\n          hostEnd = i;\n          break;\n        case CHAR_AT:\n          // At this point, either we have an explicit point where the\n          // auth portion cannot go past, or the last @ char is the decider.\n          atSign = i;\n          nonHost = -1;\n          break;\n      }\n      if (hostEnd !== -1)\n        break;\n    }\n    start = 0;\n    if (atSign !== -1) {\n      this.auth = decodeURIComponent(rest.slice(0, atSign));\n      start = atSign + 1;\n    }\n    if (nonHost === -1) {\n      this.host = rest.slice(start);\n      rest = '';\n    } else {\n      this.host = rest.slice(start, nonHost);\n      rest = rest.slice(nonHost);\n    }\n\n    // pull out port.\n    this.parseHost();\n\n    // We've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    if (typeof this.hostname !== 'string')\n      this.hostname = '';\n\n    const hostname = this.hostname;\n\n    // If hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    const ipv6Hostname = hostname.charCodeAt(0) === CHAR_LEFT_SQUARE_BRACKET &&\n      hostname.charCodeAt(hostname.length - 1) === CHAR_RIGHT_SQUARE_BRACKET;\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      rest = getHostname(this, rest, hostname);\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // Hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n\n      // Use lenient mode (`true`) to try to support even non-compliant\n      // URLs.\n      this.hostname = toASCII(this.hostname, true);\n    }\n\n    const p = this.port ? ':' + this.port : '';\n    const h = this.hostname || '';\n    this.host = h + p;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.slice(1, -1);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // Now rest is set to the post-host stuff.\n  // Chop off any delim chars.\n  if (!unsafeProtocol.has(lowerProto)) {\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    rest = autoEscapeStr(rest);\n  }\n\n  let questionIdx = -1;\n  let hashIdx = -1;\n  for (let i = 0; i < rest.length; ++i) {\n    const code = rest.charCodeAt(i);\n    if (code === CHAR_HASH) {\n      this.hash = rest.slice(i);\n      hashIdx = i;\n      break;\n    } else if (code === CHAR_QUESTION_MARK && questionIdx === -1) {\n      questionIdx = i;\n    }\n  }\n\n  if (questionIdx !== -1) {\n    if (hashIdx === -1) {\n      this.search = rest.slice(questionIdx);\n      this.query = rest.slice(questionIdx + 1);\n    } else {\n      this.search = rest.slice(questionIdx, hashIdx);\n      this.query = rest.slice(questionIdx + 1, hashIdx);\n    }\n    if (parseQueryString) {\n      if (querystring === undefined) querystring = require('querystring');\n      this.query = querystring.parse(this.query);\n    }\n  } else if (parseQueryString) {\n    // No query string, but parseQueryString still requested\n    this.search = null;\n    this.query = ObjectCreate(null);\n  }\n\n  const useQuestionIdx =\n    questionIdx !== -1 && (hashIdx === -1 || questionIdx < hashIdx);\n  const firstIdx = useQuestionIdx ? questionIdx : hashIdx;\n  if (firstIdx === -1) {\n    if (rest.length > 0)\n      this.pathname = rest;\n  } else if (firstIdx > 0) {\n    this.pathname = rest.slice(0, firstIdx);\n  }\n  if (slashedProtocol.has(lowerProto) &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  // To support http.request\n  if (this.pathname || this.search) {\n    const p = this.pathname || '';\n    const s = this.search || '';\n    this.path = p + s;\n  }\n\n  // Finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\nfunction getHostname(self, rest, hostname) {\n  for (let i = 0; i < hostname.length; ++i) {\n    const code = hostname.charCodeAt(i);\n    const isValid = (code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z) ||\n                    code === CHAR_DOT ||\n                    (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z) ||\n                    (code >= CHAR_0 && code <= CHAR_9) ||\n                    code === CHAR_HYPHEN_MINUS ||\n                    code === CHAR_PLUS ||\n                    code === CHAR_UNDERSCORE ||\n                    code > 127;\n\n    // Invalid host character\n    if (!isValid) {\n      self.hostname = hostname.slice(0, i);\n      return `/${hostname.slice(i)}${rest}`;\n    }\n  }\n  return rest;\n}\n\n// Escaped characters. Use empty strings to fill up unused entries.\n// Using Array is faster than Object/Map\nconst escapedCodes = [\n  /* 0 - 9 */ '', '', '', '', '', '', '', '', '', '%09',\n  /* 10 - 19 */ '%0A', '', '', '%0D', '', '', '', '', '', '',\n  /* 20 - 29 */ '', '', '', '', '', '', '', '', '', '',\n  /* 30 - 39 */ '', '', '%20', '', '%22', '', '', '', '', '%27',\n  /* 40 - 49 */ '', '', '', '', '', '', '', '', '', '',\n  /* 50 - 59 */ '', '', '', '', '', '', '', '', '', '',\n  /* 60 - 69 */ '%3C', '', '%3E', '', '', '', '', '', '', '',\n  /* 70 - 79 */ '', '', '', '', '', '', '', '', '', '',\n  /* 80 - 89 */ '', '', '', '', '', '', '', '', '', '',\n  /* 90 - 99 */ '', '', '%5C', '', '%5E', '', '%60', '', '', '',\n  /* 100 - 109 */ '', '', '', '', '', '', '', '', '', '',\n  /* 110 - 119 */ '', '', '', '', '', '', '', '', '', '',\n  /* 120 - 125 */ '', '', '', '%7B', '%7C', '%7D'\n];\n\n// Automatically escape all delimiters and unwise characters from RFC 2396.\n// Also escape single quotes in case of an XSS attack.\n// Return the escaped string.\nfunction autoEscapeStr(rest) {\n  let escaped = '';\n  let lastEscapedPos = 0;\n  for (let i = 0; i < rest.length; ++i) {\n    // `escaped` contains substring up to the last escaped character.\n    const escapedChar = escapedCodes[rest.charCodeAt(i)];\n    if (escapedChar) {\n      // Concat if there are ordinary characters in the middle.\n      if (i > lastEscapedPos)\n        escaped += rest.slice(lastEscapedPos, i);\n      escaped += escapedChar;\n      lastEscapedPos = i + 1;\n    }\n  }\n  if (lastEscapedPos === 0)  // Nothing has been escaped.\n    return rest;\n\n  // There are ordinary characters at the end.\n  if (lastEscapedPos < rest.length)\n    escaped += rest.slice(lastEscapedPos);\n\n  return escaped;\n}\n\n// Format a parsed object into a url string\nfunction urlFormat(urlObject, options) {\n  // Ensure it's an object, and not a string url.\n  // If it's an object, this is a no-op.\n  // this way, you can call urlParse() on strings\n  // to clean up potentially wonky urls.\n  if (typeof urlObject === 'string') {\n    urlObject = urlParse(urlObject);\n  } else if (typeof urlObject !== 'object' || urlObject === null) {\n    throw new ERR_INVALID_ARG_TYPE('urlObject',\n                                   ['Object', 'string'], urlObject);\n  } else if (!(urlObject instanceof Url)) {\n    const format = urlObject[formatSymbol];\n    return format ?\n      format.call(urlObject, options) :\n      Url.prototype.format.call(urlObject);\n  }\n  return urlObject.format();\n}\n\n// These characters do not need escaping:\n// ! - . _ ~\n// ' ( ) * :\n// digits\n// alpha (uppercase)\n// alpha (lowercase)\nconst noEscapeAuth = new Int8Array([\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0x00 - 0x0F\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0x10 - 0x1F\n  0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, // 0x20 - 0x2F\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, // 0x30 - 0x3F\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 0x40 - 0x4F\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, // 0x50 - 0x5F\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 0x60 - 0x6F\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0  // 0x70 - 0x7F\n]);\n\nUrl.prototype.format = function format() {\n  let auth = this.auth || '';\n  if (auth) {\n    auth = encodeStr(auth, noEscapeAuth, hexTable);\n    auth += '@';\n  }\n\n  let protocol = this.protocol || '';\n  let pathname = this.pathname || '';\n  let hash = this.hash || '';\n  let host = '';\n  let query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (\n      this.hostname.includes(':') ?\n        '[' + this.hostname + ']' :\n        this.hostname\n    );\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query !== null && typeof this.query === 'object') {\n    if (querystring === undefined) querystring = require('querystring');\n    query = querystring.stringify(this.query);\n  }\n\n  let search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.charCodeAt(protocol.length - 1) !== 58/* : */)\n    protocol += ':';\n\n  let newPathname = '';\n  let lastPos = 0;\n  for (let i = 0; i < pathname.length; ++i) {\n    switch (pathname.charCodeAt(i)) {\n      case CHAR_HASH:\n        if (i - lastPos > 0)\n          newPathname += pathname.slice(lastPos, i);\n        newPathname += '%23';\n        lastPos = i + 1;\n        break;\n      case CHAR_QUESTION_MARK:\n        if (i - lastPos > 0)\n          newPathname += pathname.slice(lastPos, i);\n        newPathname += '%3F';\n        lastPos = i + 1;\n        break;\n    }\n  }\n  if (lastPos > 0) {\n    if (lastPos !== pathname.length)\n      pathname = newPathname + pathname.slice(lastPos);\n    else\n      pathname = newPathname;\n  }\n\n  // Only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes || slashedProtocol.has(protocol)) {\n    if (this.slashes || host) {\n      if (pathname && pathname.charCodeAt(0) !== CHAR_FORWARD_SLASH)\n        pathname = '/' + pathname;\n      host = '//' + host;\n    } else if (protocol.length >= 4 &&\n               protocol.charCodeAt(0) === 102/* f */ &&\n               protocol.charCodeAt(1) === 105/* i */ &&\n               protocol.charCodeAt(2) === 108/* l */ &&\n               protocol.charCodeAt(3) === 101/* e */) {\n      host = '//';\n    }\n  }\n\n  search = search.replace(/#/g, '%23');\n\n  if (hash && hash.charCodeAt(0) !== CHAR_HASH)\n    hash = '#' + hash;\n  if (search && search.charCodeAt(0) !== CHAR_QUESTION_MARK)\n    search = '?' + search;\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function resolve(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function resolveObject(relative) {\n  if (typeof relative === 'string') {\n    const rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  const result = new Url();\n  const tkeys = ObjectKeys(this);\n  for (let tk = 0; tk < tkeys.length; tk++) {\n    const tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // Hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // If the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // Hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // Take everything except the protocol from relative\n    const rkeys = ObjectKeys(relative);\n    for (let rk = 0; rk < rkeys.length; rk++) {\n      const rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    // urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol.has(result.protocol) &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // If it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol.has(relative.protocol)) {\n      const keys = ObjectKeys(relative);\n      for (let v = 0; v < keys.length; v++) {\n        const k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host &&\n        !/^file:?$/.test(relative.protocol) &&\n        !hostlessProtocol.has(relative.protocol)) {\n      const relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // To support http.request\n    if (result.pathname || result.search) {\n      const p = result.pathname || '';\n      const s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  const isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/');\n  const isRelAbs = (\n    relative.host || (relative.pathname && relative.pathname.charAt(0) === '/')\n  );\n  let mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname));\n  const removeAllDots = mustEndAbs;\n  let srcPath = (result.pathname && result.pathname.split('/')) || [];\n  const relPath = (relative.pathname && relative.pathname.split('/')) || [];\n  const noLeadingSlashes = result.protocol &&\n      !slashedProtocol.has(result.protocol);\n\n  // If the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (noLeadingSlashes) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      result.auth = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    if (relative.host || relative.host === '') {\n      if (result.host !== relative.host) result.auth = null;\n      result.host = relative.host;\n      result.port = relative.port;\n    }\n    if (relative.hostname || relative.hostname === '') {\n      if (result.hostname !== relative.hostname) result.auth = null;\n      result.hostname = relative.hostname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // Fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (relative.search !== null && relative.search !== undefined) {\n    // Just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (noLeadingSlashes) {\n      result.hostname = result.host = srcPath.shift();\n      // Occasionally the auth can get stuck only in host.\n      // This especially happens in cases like\n      // url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      const authInHost =\n        result.host && result.host.indexOf('@') > 0 && result.host.split('@');\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    // To support http.request\n    if (result.pathname !== null || result.search !== null) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // No path at all. All other things were already handled above.\n    result.pathname = null;\n    // To support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // If a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  let last = srcPath.slice(-1)[0];\n  const hasTrailingSlash = (\n    ((result.host || relative.host || srcPath.length > 1) &&\n    (last === '.' || last === '..')) || last === '');\n\n  // Strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  let up = 0;\n  for (let i = srcPath.length - 1; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      spliceOne(srcPath, i);\n    } else if (last === '..') {\n      spliceOne(srcPath, i);\n      up++;\n    } else if (up) {\n      spliceOne(srcPath, i);\n      up--;\n    }\n  }\n\n  // If the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    while (up--) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  const isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (noLeadingSlashes) {\n    result.hostname =\n      result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';\n    // Occasionally the auth can get stuck only in host.\n    // This especially happens in cases like\n    // url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    const authInHost = result.host && result.host.indexOf('@') > 0 ?\n      result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  // To support request.http\n  if (result.pathname !== null || result.search !== null) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function parseHost() {\n  let host = this.host;\n  let port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.slice(1);\n    }\n    host = host.slice(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n\nmodule.exports = {\n  // Original API\n  Url,\n  parse: urlParse,\n  resolve: urlResolve,\n  resolveObject: urlResolveObject,\n  format: urlFormat,\n\n  // WHATWG API\n  URL,\n  URLSearchParams,\n  domainToASCII,\n  domainToUnicode,\n\n  // Utilities\n  pathToFileURL,\n  fileURLToPath\n};\n"
  },
  {
    "url": "util.js",
    "ranges": [
      {
        "start": 0,
        "end": 2076
      },
      {
        "start": 2138,
        "end": 2140
      },
      {
        "start": 2187,
        "end": 2189
      },
      {
        "start": 2268,
        "end": 2270
      },
      {
        "start": 2330,
        "end": 2332
      },
      {
        "start": 2392,
        "end": 2394
      },
      {
        "start": 2454,
        "end": 2456
      },
      {
        "start": 2513,
        "end": 2515
      },
      {
        "start": 2591,
        "end": 2593
      },
      {
        "start": 2696,
        "end": 2698
      },
      {
        "start": 2762,
        "end": 2764
      },
      {
        "start": 2883,
        "end": 2885
      },
      {
        "start": 2944,
        "end": 3083
      },
      {
        "start": 3313,
        "end": 3399
      },
      {
        "start": 3552,
        "end": 4288
      },
      {
        "start": 4904,
        "end": 4906
      },
      {
        "start": 5194,
        "end": 5242
      },
      {
        "start": 5667,
        "end": 5671
      },
      {
        "start": 7052,
        "end": 7054
      },
      {
        "start": 7270,
        "end": 7650
      },
      {
        "start": 7855,
        "end": 8104
      }
    ],
    "text": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayIsArray,\n  Error,\n  NumberIsSafeInteger,\n  ObjectDefineProperties,\n  ObjectDefineProperty,\n  ObjectGetOwnPropertyDescriptors,\n  ObjectKeys,\n  ObjectPrototypeToString,\n  ObjectSetPrototypeOf,\n  ReflectApply,\n} = primordials;\n\nconst {\n  codes: {\n    ERR_FALSY_VALUE_REJECTION,\n    ERR_INVALID_ARG_TYPE,\n    ERR_OUT_OF_RANGE\n  },\n  errnoException,\n  exceptionWithHostPort,\n  hideStackFrames\n} = require('internal/errors');\nconst {\n  format,\n  formatWithOptions,\n  inspect\n} = require('internal/util/inspect');\nconst { debuglog } = require('internal/util/debuglog');\nconst { validateNumber } = require('internal/validators');\nconst { TextDecoder, TextEncoder } = require('internal/encoding');\nconst { isBuffer } = require('buffer').Buffer;\nconst types = require('internal/util/types');\n\nconst {\n  deprecate,\n  getSystemErrorName: internalErrorName,\n  promisify\n} = require('internal/util');\n\nlet internalDeepEqual;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\n\nfunction isNull(arg) {\n  return arg === null;\n}\n\nfunction isNullOrUndefined(arg) {\n  return arg === null || arg === undefined;\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\n\nfunction isUndefined(arg) {\n  return arg === undefined;\n}\n\nfunction isObject(arg) {\n  return arg !== null && typeof arg === 'object';\n}\n\nfunction isError(e) {\n  return ObjectPrototypeToString(e) === '[object Error]' || e instanceof Error;\n}\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         (typeof arg !== 'object' && typeof arg !== 'function');\n}\n\nfunction pad(n) {\n  return n.toString().padStart(2, '0');\n}\n\nconst months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n                'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  const d = new Date();\n  const time = [pad(d.getHours()),\n                pad(d.getMinutes()),\n                pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\nlet console;\n// Log is just a thin wrapper to console.log that prepends a timestamp\nfunction log(...args) {\n  if (!console) {\n    console = require('internal/console/global');\n  }\n  console.log('%s - %s', timestamp(), format(...args));\n}\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n * @throws {TypeError} Will error if either constructor is null, or if\n *     the super constructor lacks a prototype.\n */\nfunction inherits(ctor, superCtor) {\n\n  if (ctor === undefined || ctor === null)\n    throw new ERR_INVALID_ARG_TYPE('ctor', 'Function', ctor);\n\n  if (superCtor === undefined || superCtor === null)\n    throw new ERR_INVALID_ARG_TYPE('superCtor', 'Function', superCtor);\n\n  if (superCtor.prototype === undefined) {\n    throw new ERR_INVALID_ARG_TYPE('superCtor.prototype',\n                                   'Object', superCtor.prototype);\n  }\n  ObjectDefineProperty(ctor, 'super_', {\n    value: superCtor,\n    writable: true,\n    configurable: true\n  });\n  ObjectSetPrototypeOf(ctor.prototype, superCtor.prototype);\n}\n\nfunction _extend(target, source) {\n  // Don't do anything if source isn't an object\n  if (source === null || typeof source !== 'object') return target;\n\n  const keys = ObjectKeys(source);\n  let i = keys.length;\n  while (i--) {\n    target[keys[i]] = source[keys[i]];\n  }\n  return target;\n}\n\nconst callbackifyOnRejected = hideStackFrames((reason, cb) => {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    reason = new ERR_FALSY_VALUE_REJECTION(reason);\n  }\n  return cb(reason);\n});\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('original', 'Function', original);\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified(...args) {\n    const maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE('last argument', 'Function', maybeCb);\n    }\n    const cb = (...args) => { ReflectApply(maybeCb, this, args); };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    ReflectApply(original, this, args)\n      .then((ret) => process.nextTick(cb, null, ret),\n            (rej) => process.nextTick(callbackifyOnRejected, rej, cb));\n  }\n\n  const descriptors = ObjectGetOwnPropertyDescriptors(original);\n  // It is possible to manipulate a functions `length` or `name` property. This\n  // guards against the manipulation.\n  if (typeof descriptors.length.value === 'number') {\n    descriptors.length.value++;\n  }\n  if (typeof descriptors.name.value === 'string') {\n    descriptors.name.value += 'Callbackified';\n  }\n  ObjectDefineProperties(callbackified, descriptors);\n  return callbackified;\n}\n\nfunction getSystemErrorName(err) {\n  validateNumber(err, 'err');\n  if (err >= 0 || !NumberIsSafeInteger(err)) {\n    throw new ERR_OUT_OF_RANGE('err', 'a negative integer', err);\n  }\n  return internalErrorName(err);\n}\n\n// Keep the `exports =` so that various functions can still be monkeypatched\nmodule.exports = {\n  _errnoException: errnoException,\n  _exceptionWithHostPort: exceptionWithHostPort,\n  _extend,\n  callbackify,\n  debug: debuglog,\n  debuglog,\n  deprecate,\n  format,\n  formatWithOptions,\n  getSystemErrorName,\n  inherits,\n  inspect,\n  isArray: ArrayIsArray,\n  isBoolean,\n  isBuffer,\n  isDeepStrictEqual(a, b) {\n    if (internalDeepEqual === undefined) {\n      internalDeepEqual = require('internal/util/comparisons')\n        .isDeepStrictEqual;\n    }\n    return internalDeepEqual(a, b);\n  },\n  isNull,\n  isNullOrUndefined,\n  isNumber,\n  isString,\n  isSymbol,\n  isUndefined,\n  isRegExp: types.isRegExp,\n  isObject,\n  isDate: types.isDate,\n  isError,\n  isFunction,\n  isPrimitive,\n  log,\n  promisify,\n  TextDecoder,\n  TextEncoder,\n  types\n};\n"
  },
  {
    "url": "vm.js",
    "ranges": [
      {
        "start": 0,
        "end": 1992
      },
      {
        "start": 4152,
        "end": 4156
      },
      {
        "start": 4436,
        "end": 4440
      },
      {
        "start": 4846,
        "end": 4850
      },
      {
        "start": 5021,
        "end": 5025
      },
      {
        "start": 5244,
        "end": 5246
      },
      {
        "start": 5837,
        "end": 5839
      },
      {
        "start": 6907,
        "end": 6909
      },
      {
        "start": 7091,
        "end": 7126
      },
      {
        "start": 8261,
        "end": 8263
      },
      {
        "start": 8339,
        "end": 8493
      },
      {
        "start": 8939,
        "end": 8941
      },
      {
        "start": 9338,
        "end": 9340
      },
      {
        "start": 9692,
        "end": 9694
      },
      {
        "start": 9880,
        "end": 9882
      },
      {
        "start": 11615,
        "end": 11892
      },
      {
        "start": 12454,
        "end": 12941
      }
    ],
    "text": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeForEach,\n  Symbol,\n  PromiseReject,\n  ReflectApply,\n} = primordials;\n\nconst {\n  ContextifyScript,\n  MicrotaskQueue,\n  makeContext,\n  isContext: _isContext,\n  constants,\n  compileFunction: _compileFunction,\n  measureMemory: _measureMemory,\n} = internalBinding('contextify');\nconst {\n  ERR_CONTEXT_NOT_INITIALIZED,\n  ERR_INVALID_ARG_TYPE,\n} = require('internal/errors').codes;\nconst {\n  isArrayBufferView,\n} = require('internal/util/types');\nconst {\n  validateInt32,\n  validateUint32,\n  validateString,\n  validateArray,\n  validateBoolean,\n  validateBuffer,\n  validateObject,\n  validateOneOf,\n} = require('internal/validators');\nconst {\n  kVmBreakFirstLineSymbol,\n  emitExperimentalWarning,\n} = require('internal/util');\nconst kParsingContext = Symbol('script parsing context');\n\nclass Script extends ContextifyScript {\n  constructor(code, options = {}) {\n    code = `${code}`;\n    if (typeof options === 'string') {\n      options = { filename: options };\n    } else if (typeof options !== 'object' || options === null) {\n      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);\n    }\n\n    const {\n      filename = 'evalmachine.<anonymous>',\n      lineOffset = 0,\n      columnOffset = 0,\n      cachedData,\n      produceCachedData = false,\n      importModuleDynamically,\n      [kParsingContext]: parsingContext,\n    } = options;\n\n    validateString(filename, 'options.filename');\n    validateInt32(lineOffset, 'options.lineOffset');\n    validateInt32(columnOffset, 'options.columnOffset');\n    if (cachedData !== undefined && !isArrayBufferView(cachedData)) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.cachedData',\n        ['Buffer', 'TypedArray', 'DataView'],\n        cachedData\n      );\n    }\n    if (typeof produceCachedData !== 'boolean') {\n      throw new ERR_INVALID_ARG_TYPE('options.produceCachedData', 'boolean',\n                                     produceCachedData);\n    }\n\n    // Calling `ReThrow()` on a native TryCatch does not generate a new\n    // abort-on-uncaught-exception check. A dummy try/catch in JS land\n    // protects against that.\n    try { // eslint-disable-line no-useless-catch\n      super(code,\n            filename,\n            lineOffset,\n            columnOffset,\n            cachedData,\n            produceCachedData,\n            parsingContext);\n    } catch (e) {\n      throw e; /* node-do-not-add-exception-line */\n    }\n\n    if (importModuleDynamically !== undefined) {\n      if (typeof importModuleDynamically !== 'function') {\n        throw new ERR_INVALID_ARG_TYPE('options.importModuleDynamically',\n                                       'function',\n                                       importModuleDynamically);\n      }\n      const { importModuleDynamicallyWrap } =\n        require('internal/vm/module');\n      const { callbackMap } = internalBinding('module_wrap');\n      callbackMap.set(this, {\n        importModuleDynamically:\n          importModuleDynamicallyWrap(importModuleDynamically),\n      });\n    }\n  }\n\n  runInThisContext(options) {\n    const { breakOnSigint, args } = getRunInContextArgs(options);\n    if (breakOnSigint && process.listenerCount('SIGINT') > 0) {\n      return sigintHandlersWrap(super.runInThisContext, this, args);\n    }\n    return super.runInThisContext(...args);\n  }\n\n  runInContext(contextifiedObject, options) {\n    validateContext(contextifiedObject);\n    const { breakOnSigint, args } = getRunInContextArgs(options);\n    if (breakOnSigint && process.listenerCount('SIGINT') > 0) {\n      return sigintHandlersWrap(super.runInContext, this,\n                                [contextifiedObject, ...args]);\n    }\n    return super.runInContext(contextifiedObject, ...args);\n  }\n\n  runInNewContext(contextObject, options) {\n    const context = createContext(contextObject, getContextOptions(options));\n    return this.runInContext(context, options);\n  }\n}\n\nfunction validateContext(contextifiedObject) {\n  if (!isContext(contextifiedObject)) {\n    throw new ERR_INVALID_ARG_TYPE('contextifiedObject', 'vm.Context',\n                                   contextifiedObject);\n  }\n}\n\nfunction getRunInContextArgs(options = {}) {\n  validateObject(options, 'options');\n\n  let timeout = options.timeout;\n  if (timeout === undefined) {\n    timeout = -1;\n  } else {\n    validateUint32(timeout, 'options.timeout', true);\n  }\n\n  const {\n    displayErrors = true,\n    breakOnSigint = false,\n    [kVmBreakFirstLineSymbol]: breakFirstLine = false,\n  } = options;\n\n  validateBoolean(displayErrors, 'options.displayErrors');\n  validateBoolean(breakOnSigint, 'options.breakOnSigint');\n\n  return {\n    breakOnSigint,\n    args: [timeout, displayErrors, breakOnSigint, breakFirstLine]\n  };\n}\n\nfunction getContextOptions(options) {\n  if (!options)\n    return {};\n  const contextOptions = {\n    name: options.contextName,\n    origin: options.contextOrigin,\n    codeGeneration: undefined,\n    microtaskMode: options.microtaskMode,\n  };\n  if (contextOptions.name !== undefined)\n    validateString(contextOptions.name, 'options.contextName');\n  if (contextOptions.origin !== undefined)\n    validateString(contextOptions.origin, 'options.contextOrigin');\n  if (options.contextCodeGeneration !== undefined) {\n    validateObject(options.contextCodeGeneration,\n                   'options.contextCodeGeneration');\n    const { strings, wasm } = options.contextCodeGeneration;\n    if (strings !== undefined)\n      validateBoolean(strings, 'options.contextCodeGeneration.strings');\n    if (wasm !== undefined)\n      validateBoolean(wasm, 'options.contextCodeGeneration.wasm');\n    contextOptions.codeGeneration = { strings, wasm };\n  }\n  if (options.microtaskMode !== undefined)\n    validateString(options.microtaskMode, 'options.microtaskMode');\n  return contextOptions;\n}\n\nfunction isContext(object) {\n  if (typeof object !== 'object' || object === null) {\n    throw new ERR_INVALID_ARG_TYPE('object', 'Object', object);\n  }\n  return _isContext(object);\n}\n\nlet defaultContextNameIndex = 1;\nfunction createContext(contextObject = {}, options = {}) {\n  if (isContext(contextObject)) {\n    return contextObject;\n  }\n\n  validateObject(options, 'options');\n\n  const {\n    name = `VM Context ${defaultContextNameIndex++}`,\n    origin,\n    codeGeneration,\n    microtaskMode\n  } = options;\n\n  validateString(name, 'options.name');\n  if (origin !== undefined)\n    validateString(origin, 'options.origin');\n  if (codeGeneration !== undefined)\n    validateObject(codeGeneration, 'options.codeGeneration');\n\n  let strings = true;\n  let wasm = true;\n  if (codeGeneration !== undefined) {\n    ({ strings = true, wasm = true } = codeGeneration);\n    validateBoolean(strings, 'options.codeGeneration.strings');\n    validateBoolean(wasm, 'options.codeGeneration.wasm');\n  }\n\n  let microtaskQueue = null;\n  if (microtaskMode !== undefined) {\n    validateOneOf(microtaskMode, 'options.microtaskMode',\n                  ['afterEvaluate', undefined]);\n\n    if (microtaskMode === 'afterEvaluate')\n      microtaskQueue = new MicrotaskQueue();\n  }\n\n  makeContext(contextObject, name, origin, strings, wasm, microtaskQueue);\n  return contextObject;\n}\n\nfunction createScript(code, options) {\n  return new Script(code, options);\n}\n\n// Remove all SIGINT listeners and re-attach them after the wrapped function\n// has executed, so that caught SIGINT are handled by the listeners again.\nfunction sigintHandlersWrap(fn, thisArg, argsArray) {\n  const sigintListeners = process.rawListeners('SIGINT');\n\n  process.removeAllListeners('SIGINT');\n\n  try {\n    return ReflectApply(fn, thisArg, argsArray);\n  } finally {\n    // Add using the public methods so that the `newListener` handler of\n    // process can re-attach the listeners.\n    for (const listener of sigintListeners) {\n      process.addListener('SIGINT', listener);\n    }\n  }\n}\n\nfunction runInContext(code, contextifiedObject, options) {\n  validateContext(contextifiedObject);\n  if (typeof options === 'string') {\n    options = {\n      filename: options,\n      [kParsingContext]: contextifiedObject\n    };\n  } else {\n    options = { ...options, [kParsingContext]: contextifiedObject };\n  }\n  return createScript(code, options)\n    .runInContext(contextifiedObject, options);\n}\n\nfunction runInNewContext(code, contextObject, options) {\n  if (typeof options === 'string') {\n    options = { filename: options };\n  }\n  contextObject = createContext(contextObject, getContextOptions(options));\n  options = { ...options, [kParsingContext]: contextObject };\n  return createScript(code, options).runInNewContext(contextObject, options);\n}\n\nfunction runInThisContext(code, options) {\n  if (typeof options === 'string') {\n    options = { filename: options };\n  }\n  return createScript(code, options).runInThisContext(options);\n}\n\nfunction compileFunction(code, params, options = {}) {\n  validateString(code, 'code');\n  if (params !== undefined) {\n    validateArray(params, 'params');\n    ArrayPrototypeForEach(params,\n                          (param, i) => validateString(param, `params[${i}]`));\n  }\n\n  const {\n    filename = '',\n    columnOffset = 0,\n    lineOffset = 0,\n    cachedData = undefined,\n    produceCachedData = false,\n    parsingContext = undefined,\n    contextExtensions = [],\n  } = options;\n\n  validateString(filename, 'options.filename');\n  validateUint32(columnOffset, 'options.columnOffset');\n  validateUint32(lineOffset, 'options.lineOffset');\n  if (cachedData !== undefined)\n    validateBuffer(cachedData, 'options.cachedData');\n  validateBoolean(produceCachedData, 'options.produceCachedData');\n  if (parsingContext !== undefined) {\n    if (\n      typeof parsingContext !== 'object' ||\n      parsingContext === null ||\n      !isContext(parsingContext)\n    ) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.parsingContext',\n        'Context',\n        parsingContext\n      );\n    }\n  }\n  validateArray(contextExtensions, 'options.contextExtensions');\n  ArrayPrototypeForEach(contextExtensions, (extension, i) => {\n    const name = `options.contextExtensions[${i}]`;\n    validateObject(extension, name, { nullable: true });\n  });\n\n  const result = _compileFunction(\n    code,\n    filename,\n    lineOffset,\n    columnOffset,\n    cachedData,\n    produceCachedData,\n    parsingContext,\n    contextExtensions,\n    params\n  );\n\n  if (produceCachedData) {\n    result.function.cachedDataProduced = result.cachedDataProduced;\n  }\n\n  if (result.cachedData) {\n    result.function.cachedData = result.cachedData;\n  }\n\n  return result.function;\n}\n\nconst measureMemoryModes = {\n  summary: constants.measureMemory.mode.SUMMARY,\n  detailed: constants.measureMemory.mode.DETAILED,\n};\n\nconst measureMemoryExecutions = {\n  default: constants.measureMemory.execution.DEFAULT,\n  eager: constants.measureMemory.execution.EAGER,\n};\n\nfunction measureMemory(options = {}) {\n  emitExperimentalWarning('vm.measureMemory');\n  validateObject(options, 'options');\n  const { mode = 'summary', execution = 'default' } = options;\n  validateOneOf(mode, 'options.mode', ['summary', 'detailed']);\n  validateOneOf(execution, 'options.execution', ['default', 'eager']);\n  const result = _measureMemory(measureMemoryModes[mode],\n                                measureMemoryExecutions[execution]);\n  if (result === undefined) {\n    return PromiseReject(new ERR_CONTEXT_NOT_INITIALIZED());\n  }\n  return result;\n}\n\nmodule.exports = {\n  Script,\n  createContext,\n  createScript,\n  runInContext,\n  runInNewContext,\n  runInThisContext,\n  isContext,\n  compileFunction,\n  measureMemory,\n};\n\nif (require('internal/options').getOptionValue('--experimental-vm-modules')) {\n  const {\n    Module, SourceTextModule, SyntheticModule,\n  } = require('internal/vm/module');\n  module.exports.Module = Module;\n  module.exports.SourceTextModule = SourceTextModule;\n  module.exports.SyntheticModule = SyntheticModule;\n}\n"
  }
]